
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">nancalacc/api/account/v1/account.pb.go (0.0%)</option>
				
				<option value="file1">nancalacc/api/account/v1/account_grpc.pb.go (0.0%)</option>
				
				<option value="file2">nancalacc/api/account/v1/account_http.pb.go (0.0%)</option>
				
				<option value="file3">nancalacc/cmd/client/main.go (0.0%)</option>
				
				<option value="file4">nancalacc/cmd/nancalacc/main.go (0.0%)</option>
				
				<option value="file5">nancalacc/cmd/nancalacc/wire_gen.go (0.0%)</option>
				
				<option value="file6">nancalacc/cmd/test/main.go (0.0%)</option>
				
				<option value="file7">nancalacc/internal/auth/cache.go (0.0%)</option>
				
				<option value="file8">nancalacc/internal/auth/common.go (0.0%)</option>
				
				<option value="file9">nancalacc/internal/auth/dingtalk_auth.go (0.0%)</option>
				
				<option value="file10">nancalacc/internal/auth/wpsapp_auth.go (0.0%)</option>
				
				<option value="file11">nancalacc/internal/biz/account.go (0.0%)</option>
				
				<option value="file12">nancalacc/internal/biz/full_sync.go (0.0%)</option>
				
				<option value="file13">nancalacc/internal/biz/incre_sync.go (0.0%)</option>
				
				<option value="file14">nancalacc/internal/biz/oauth2.go (0.0%)</option>
				
				<option value="file15">nancalacc/internal/conf/conf.pb.go (0.0%)</option>
				
				<option value="file16">nancalacc/internal/conf/envvars.go (0.0%)</option>
				
				<option value="file17">nancalacc/internal/conf/example_usage.go (0.0%)</option>
				
				<option value="file18">nancalacc/internal/conf/loader.go (0.0%)</option>
				
				<option value="file19">nancalacc/internal/conf/validator.go (0.0%)</option>
				
				<option value="file20">nancalacc/internal/data/account.go (0.0%)</option>
				
				<option value="file21">nancalacc/internal/data/data.go (0.0%)</option>
				
				<option value="file22">nancalacc/internal/data/data_sync.go (0.0%)</option>
				
				<option value="file23">nancalacc/internal/data/etcd/client.go (0.0%)</option>
				
				<option value="file24">nancalacc/internal/data/etcd/config.go (0.0%)</option>
				
				<option value="file25">nancalacc/internal/data/gorm_logger.go (0.0%)</option>
				
				<option value="file26">nancalacc/internal/data/local_cache.go (0.0%)</option>
				
				<option value="file27">nancalacc/internal/data/migrations.go (0.0%)</option>
				
				<option value="file28">nancalacc/internal/data/models/account.go (0.0%)</option>
				
				<option value="file29">nancalacc/internal/data/models/company.go (0.0%)</option>
				
				<option value="file30">nancalacc/internal/data/models/converter.go (0.0%)</option>
				
				<option value="file31">nancalacc/internal/data/models/department.go (0.0%)</option>
				
				<option value="file32">nancalacc/internal/data/models/department_user.go (0.0%)</option>
				
				<option value="file33">nancalacc/internal/data/models/task.go (0.0%)</option>
				
				<option value="file34">nancalacc/internal/data/models/user.go (0.0%)</option>
				
				<option value="file35">nancalacc/internal/data/mysql.go (0.0%)</option>
				
				<option value="file36">nancalacc/internal/data/redis.go (0.0%)</option>
				
				<option value="file37">nancalacc/internal/data/redis_cache.go (0.0%)</option>
				
				<option value="file38">nancalacc/internal/dingtalk/dingtalk.go (0.0%)</option>
				
				<option value="file39">nancalacc/internal/dingtalk/validate.go (0.0%)</option>
				
				<option value="file40">nancalacc/internal/middleware/log_middleware.go (0.0%)</option>
				
				<option value="file41">nancalacc/internal/pkg/cache/redis.go (0.0%)</option>
				
				<option value="file42">nancalacc/internal/pkg/cipherutil/cipherutil.go (0.0%)</option>
				
				<option value="file43">nancalacc/internal/pkg/fileutil/excell.go (0.0%)</option>
				
				<option value="file44">nancalacc/internal/pkg/limiter/limiter.go (0.0%)</option>
				
				<option value="file45">nancalacc/internal/pkg/utils/slice.go (0.0%)</option>
				
				<option value="file46">nancalacc/internal/server/grpc.go (0.0%)</option>
				
				<option value="file47">nancalacc/internal/server/http.go (0.0%)</option>
				
				<option value="file48">nancalacc/internal/service/account.go (0.0%)</option>
				
				<option value="file49">nancalacc/internal/service/dingtalkevent.go (0.0%)</option>
				
				<option value="file50">nancalacc/internal/task/cron.go (0.0%)</option>
				
				<option value="file51">nancalacc/internal/task/jobs.go (0.0%)</option>
				
				<option value="file52">nancalacc/internal/task/provider.go (0.0%)</option>
				
				<option value="file53">nancalacc/internal/tracer/tracer.go (0.0%)</option>
				
				<option value="file54">nancalacc/internal/wps/signature.go (0.0%)</option>
				
				<option value="file55">nancalacc/internal/wps/validate.go (0.0%)</option>
				
				<option value="file56">nancalacc/internal/wps/wps.go (0.0%)</option>
				
				<option value="file57">nancalacc/internal/wps/wps4sign.go (0.0%)</option>
				
				<option value="file58">nancalacc/internal/wps/wpsrequest.go (0.0%)</option>
				
				<option value="file59">nancalacc/internal/wps/wpssync.go (0.0%)</option>
				
				<option value="file60">nancalacc/pkg/httputil/http.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v5.29.3
// source: api/account/v1/account.proto

package v1

import (
        _ "google.golang.org/genproto/googleapis/api/annotations"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TriggerType int32

const (
        TriggerType_TRIGGER_UNKNOWN   TriggerType = 0 // 未知触发方式（默认值）
        TriggerType_TRIGGER_MANUAL    TriggerType = 1 // 手动触发（如管理员点击按钮）
        TriggerType_TRIGGER_SCHEDULED TriggerType = 2 // 定时任务触发（如每天凌晨2点自动同步）
)

// Enum value maps for TriggerType.
var (
        TriggerType_name = map[int32]string{
                0: "TRIGGER_UNKNOWN",
                1: "TRIGGER_MANUAL",
                2: "TRIGGER_SCHEDULED",
        }
        TriggerType_value = map[string]int32{
                "TRIGGER_UNKNOWN":   0,
                "TRIGGER_MANUAL":    1,
                "TRIGGER_SCHEDULED": 2,
        }
)

func (x TriggerType) Enum() *TriggerType <span class="cov0" title="0">{
        p := new(TriggerType)
        *p = x
        return p
}</span>

func (x TriggerType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (TriggerType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_enumTypes[0].Descriptor()
}</span>

func (TriggerType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_api_account_v1_account_proto_enumTypes[0]
}</span>

func (x TriggerType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use TriggerType.Descriptor instead.
func (TriggerType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{0}
}</span>

type SyncType int32

const (
        SyncType_FULL        SyncType = 0 // 全量同步
        SyncType_INCREMENTAL SyncType = 1 // 增量同步
)

// Enum value maps for SyncType.
var (
        SyncType_name = map[int32]string{
                0: "FULL",
                1: "INCREMENTAL",
        }
        SyncType_value = map[string]int32{
                "FULL":        0,
                "INCREMENTAL": 1,
        }
)

func (x SyncType) Enum() *SyncType <span class="cov0" title="0">{
        p := new(SyncType)
        *p = x
        return p
}</span>

func (x SyncType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (SyncType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_enumTypes[1].Descriptor()
}</span>

func (SyncType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_api_account_v1_account_proto_enumTypes[1]
}</span>

func (x SyncType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use SyncType.Descriptor instead.
func (SyncType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{1}
}</span>

type GetSyncAccountReply_Status int32

const (
        GetSyncAccountReply_PENDING GetSyncAccountReply_Status = 0 // 待执行
        GetSyncAccountReply_RUNNING GetSyncAccountReply_Status = 1 // 执行中
        GetSyncAccountReply_SUCCESS GetSyncAccountReply_Status = 2 // 成功
        GetSyncAccountReply_FAILED  GetSyncAccountReply_Status = 3 // 失败
)

// Enum value maps for GetSyncAccountReply_Status.
var (
        GetSyncAccountReply_Status_name = map[int32]string{
                0: "PENDING",
                1: "RUNNING",
                2: "SUCCESS",
                3: "FAILED",
        }
        GetSyncAccountReply_Status_value = map[string]int32{
                "PENDING": 0,
                "RUNNING": 1,
                "SUCCESS": 2,
                "FAILED":  3,
        }
)

func (x GetSyncAccountReply_Status) Enum() *GetSyncAccountReply_Status <span class="cov0" title="0">{
        p := new(GetSyncAccountReply_Status)
        *p = x
        return p
}</span>

func (x GetSyncAccountReply_Status) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (GetSyncAccountReply_Status) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_enumTypes[2].Descriptor()
}</span>

func (GetSyncAccountReply_Status) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_api_account_v1_account_proto_enumTypes[2]
}</span>

func (x GetSyncAccountReply_Status) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use GetSyncAccountReply_Status.Descriptor instead.
func (GetSyncAccountReply_Status) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{7, 0}
}</span>

type GetTaskRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        TaskName      string                 `protobuf:"bytes,1,opt,name=task_name,json=taskName,proto3" json:"task_name,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetTaskRequest) Reset() <span class="cov0" title="0">{
        *x = GetTaskRequest{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTaskRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTaskRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTaskRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTaskRequest.ProtoReflect.Descriptor instead.
func (*GetTaskRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{0}
}</span>

func (x *GetTaskRequest) GetTaskName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TaskName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetTaskReply struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Task          *GetTaskReply_Task     `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetTaskReply) Reset() <span class="cov0" title="0">{
        *x = GetTaskReply{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTaskReply) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTaskReply) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTaskReply) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTaskReply.ProtoReflect.Descriptor instead.
func (*GetTaskReply) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GetTaskReply) GetTask() *GetTaskReply_Task <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Task
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UploadRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        File          []byte                 `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
        Filename      string                 `protobuf:"bytes,2,opt,name=filename,proto3" json:"filename,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UploadRequest) Reset() <span class="cov0" title="0">{
        *x = UploadRequest{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UploadRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UploadRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UploadRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UploadRequest.ProtoReflect.Descriptor instead.
func (*UploadRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{2}
}</span>

func (x *UploadRequest) GetFile() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.File
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UploadRequest) GetFilename() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Filename
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UploadReply struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Url           string                 `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
        Task          string                 `protobuf:"bytes,2,opt,name=task,proto3" json:"task,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UploadReply) Reset() <span class="cov0" title="0">{
        *x = UploadReply{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UploadReply) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UploadReply) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UploadReply) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UploadReply.ProtoReflect.Descriptor instead.
func (*UploadReply) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{3}
}</span>

func (x *UploadReply) GetUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Url
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UploadReply) GetTask() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Task
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// 创建同步请求
type CreateSyncAccountRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        TriggerType   TriggerType            `protobuf:"varint,1,opt,name=trigger_type,json=triggerType,proto3,enum=api.account.v1.TriggerType" json:"trigger_type,omitempty"` // 触发类型
        SyncType      SyncType               `protobuf:"varint,2,opt,name=sync_type,json=syncType,proto3,enum=api.account.v1.SyncType" json:"sync_type,omitempty"`             // 同步类型
        TaskName      *string                `protobuf:"bytes,3,opt,name=task_name,json=taskName,proto3,oneof" json:"task_name,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateSyncAccountRequest) Reset() <span class="cov0" title="0">{
        *x = CreateSyncAccountRequest{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateSyncAccountRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateSyncAccountRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateSyncAccountRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateSyncAccountRequest.ProtoReflect.Descriptor instead.
func (*CreateSyncAccountRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{4}
}</span>

func (x *CreateSyncAccountRequest) GetTriggerType() TriggerType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TriggerType
        }</span>
        <span class="cov0" title="0">return TriggerType_TRIGGER_UNKNOWN</span>
}

func (x *CreateSyncAccountRequest) GetSyncType() SyncType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SyncType
        }</span>
        <span class="cov0" title="0">return SyncType_FULL</span>
}

func (x *CreateSyncAccountRequest) GetTaskName() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.TaskName != nil </span><span class="cov0" title="0">{
                return *x.TaskName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// 创建同步响应
type CreateSyncAccountReply struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        TaskId        string                 `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`             // 生成的任务ID
        CreateTime    *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"` // 任务创建时间
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateSyncAccountReply) Reset() <span class="cov0" title="0">{
        *x = CreateSyncAccountReply{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateSyncAccountReply) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateSyncAccountReply) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateSyncAccountReply) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateSyncAccountReply.ProtoReflect.Descriptor instead.
func (*CreateSyncAccountReply) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{5}
}</span>

func (x *CreateSyncAccountReply) GetTaskId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TaskId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateSyncAccountReply) GetCreateTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreateTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// 查询同步请求
type GetSyncAccountRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        TaskId        string                 `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"` // 要查询的任务ID
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetSyncAccountRequest) Reset() <span class="cov0" title="0">{
        *x = GetSyncAccountRequest{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSyncAccountRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSyncAccountRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSyncAccountRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSyncAccountRequest.ProtoReflect.Descriptor instead.
func (*GetSyncAccountRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{6}
}</span>

func (x *GetSyncAccountRequest) GetTaskId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TaskId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// 查询同步响应
type GetSyncAccountReply struct {
        state                       protoimpl.MessageState     `protogen:"open.v1"`
        Status                      GetSyncAccountReply_Status `protobuf:"varint,1,opt,name=status,proto3,enum=api.account.v1.GetSyncAccountReply_Status" json:"status,omitempty"`
        UserCount                   int64                      `protobuf:"varint,2,opt,name=user_count,json=userCount,proto3" json:"user_count,omitempty"`
        DepartmentCount             int64                      `protobuf:"varint,3,opt,name=department_count,json=departmentCount,proto3" json:"department_count,omitempty"`
        UserDepartmentRelationCount int64                      `protobuf:"varint,4,opt,name=user_department_relation_count,json=userDepartmentRelationCount,proto3" json:"user_department_relation_count,omitempty"`
        LatestSyncTime              *timestamppb.Timestamp     `protobuf:"bytes,5,opt,name=latest_sync_time,json=latestSyncTime,proto3" json:"latest_sync_time,omitempty"`
        unknownFields               protoimpl.UnknownFields
        sizeCache                   protoimpl.SizeCache
}

func (x *GetSyncAccountReply) Reset() <span class="cov0" title="0">{
        *x = GetSyncAccountReply{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSyncAccountReply) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSyncAccountReply) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSyncAccountReply) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSyncAccountReply.ProtoReflect.Descriptor instead.
func (*GetSyncAccountReply) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{7}
}</span>

func (x *GetSyncAccountReply) GetStatus() GetSyncAccountReply_Status <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return GetSyncAccountReply_PENDING</span>
}

func (x *GetSyncAccountReply) GetUserCount() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetSyncAccountReply) GetDepartmentCount() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DepartmentCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetSyncAccountReply) GetUserDepartmentRelationCount() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserDepartmentRelationCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetSyncAccountReply) GetLatestSyncTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LatestSyncTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CancelSyncAccountRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        TaskId        string                 `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"` // 要删除的任务ID
        Tags          []string               `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CancelSyncAccountRequest) Reset() <span class="cov0" title="0">{
        *x = CancelSyncAccountRequest{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CancelSyncAccountRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CancelSyncAccountRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CancelSyncAccountRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CancelSyncAccountRequest.ProtoReflect.Descriptor instead.
func (*CancelSyncAccountRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{8}
}</span>

func (x *CancelSyncAccountRequest) GetTaskId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TaskId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CancelSyncAccountRequest) GetTags() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetAccessTokenRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Code          string                 `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetAccessTokenRequest) Reset() <span class="cov0" title="0">{
        *x = GetAccessTokenRequest{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetAccessTokenRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetAccessTokenRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetAccessTokenRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetAccessTokenRequest.ProtoReflect.Descriptor instead.
func (*GetAccessTokenRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{9}
}</span>

func (x *GetAccessTokenRequest) GetCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetAccessTokenResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        AccessToken   string                 `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        RefreshToken  string                 `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
        ExpiresIn     int64                  `protobuf:"varint,3,opt,name=expires_in,json=expiresIn,proto3" json:"expires_in,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetAccessTokenResponse) Reset() <span class="cov0" title="0">{
        *x = GetAccessTokenResponse{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetAccessTokenResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetAccessTokenResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetAccessTokenResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetAccessTokenResponse.ProtoReflect.Descriptor instead.
func (*GetAccessTokenResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{10}
}</span>

func (x *GetAccessTokenResponse) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetAccessTokenResponse) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetAccessTokenResponse) GetExpiresIn() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresIn
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetUserInfoRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        AccessToken   string                 `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserInfoRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserInfoRequest{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserInfoRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserInfoRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserInfoRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserInfoRequest.ProtoReflect.Descriptor instead.
func (*GetUserInfoRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{11}
}</span>

func (x *GetUserInfoRequest) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetUserInfoResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UnionId       string                 `protobuf:"bytes,1,opt,name=union_id,json=unionId,proto3" json:"union_id,omitempty"`
        UserId        string                 `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Name          string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
        Email         string                 `protobuf:"bytes,4,opt,name=email,proto3" json:"email,omitempty"`
        Avatar        string                 `protobuf:"bytes,5,opt,name=avatar,proto3" json:"avatar,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserInfoResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserInfoResponse{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserInfoResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserInfoResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserInfoResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserInfoResponse.ProtoReflect.Descriptor instead.
func (*GetUserInfoResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{12}
}</span>

func (x *GetUserInfoResponse) GetUnionId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UnionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetUserInfoResponse) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetUserInfoResponse) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetUserInfoResponse) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetUserInfoResponse) GetAvatar() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Avatar
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CallbackRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Code          string                 `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`   // OAuth2 授权码
        State         string                 `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"` // 防止 CSRF 的随机字符串
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CallbackRequest) Reset() <span class="cov0" title="0">{
        *x = CallbackRequest{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CallbackRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CallbackRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CallbackRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CallbackRequest.ProtoReflect.Descriptor instead.
func (*CallbackRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{13}
}</span>

func (x *CallbackRequest) GetCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CallbackRequest) GetState() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.State
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// 定义回调响应
type CallbackResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Status        string                 `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`   // 例如 "success" 或 "error"
        Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"` // 可选描述信息
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CallbackResponse) Reset() <span class="cov0" title="0">{
        *x = CallbackResponse{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CallbackResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CallbackResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CallbackResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CallbackResponse.ProtoReflect.Descriptor instead.
func (*CallbackResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{14}
}</span>

func (x *CallbackResponse) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CallbackResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetTaskReply_Task struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Status        string                 `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
        CreateTime    *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
        StartTime     *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
        CompletedTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=completed_time,json=completedTime,proto3" json:"completed_time,omitempty"`
        ActurlTime    int32                  `protobuf:"varint,6,opt,name=acturl_time,json=acturlTime,proto3" json:"acturl_time,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetTaskReply_Task) Reset() <span class="cov0" title="0">{
        *x = GetTaskReply_Task{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTaskReply_Task) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTaskReply_Task) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTaskReply_Task) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTaskReply_Task.ProtoReflect.Descriptor instead.
func (*GetTaskReply_Task) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{1, 0}
}</span>

func (x *GetTaskReply_Task) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetTaskReply_Task) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetTaskReply_Task) GetCreateTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreateTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetTaskReply_Task) GetStartTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StartTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetTaskReply_Task) GetCompletedTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CompletedTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetTaskReply_Task) GetActurlTime() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ActurlTime
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_api_account_v1_account_proto protoreflect.FileDescriptor

const file_api_account_v1_account_proto_rawDesc = "" +
        "\n" +
        "\x1capi/account/v1/account.proto\x12\x0eapi.account.v1\x1a\x1cgoogle/api/annotations.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bgoogle/protobuf/empty.proto\"-\n" +
        "\x0eGetTaskRequest\x12\x1b\n" +
        "\ttask_name\x18\x01 \x01(\tR\btaskName\"\xd6\x02\n" +
        "\fGetTaskReply\x125\n" +
        "\x04task\x18\x01 \x01(\v2!.api.account.v1.GetTaskReply.TaskR\x04task\x1a\x8e\x02\n" +
        "\x04Task\x12\x12\n" +
        "\x04name\x18\x01 \x01(\tR\x04name\x12\x16\n" +
        "\x06status\x18\x02 \x01(\tR\x06status\x12;\n" +
        "\vcreate_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
        "createTime\x129\n" +
        "\n" +
        "start_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\tstartTime\x12A\n" +
        "\x0ecompleted_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\rcompletedTime\x12\x1f\n" +
        "\vacturl_time\x18\x06 \x01(\x05R\n" +
        "acturlTime\"?\n" +
        "\rUploadRequest\x12\x12\n" +
        "\x04file\x18\x01 \x01(\fR\x04file\x12\x1a\n" +
        "\bfilename\x18\x02 \x01(\tR\bfilename\"3\n" +
        "\vUploadReply\x12\x10\n" +
        "\x03url\x18\x01 \x01(\tR\x03url\x12\x12\n" +
        "\x04task\x18\x02 \x01(\tR\x04task\"\xc1\x01\n" +
        "\x18CreateSyncAccountRequest\x12&gt;\n" +
        "\ftrigger_type\x18\x01 \x01(\x0e2\x1b.api.account.v1.TriggerTypeR\vtriggerType\x125\n" +
        "\tsync_type\x18\x02 \x01(\x0e2\x18.api.account.v1.SyncTypeR\bsyncType\x12 \n" +
        "\ttask_name\x18\x03 \x01(\tH\x00R\btaskName\x88\x01\x01B\f\n" +
        "\n" +
        "_task_name\"n\n" +
        "\x16CreateSyncAccountReply\x12\x17\n" +
        "\atask_id\x18\x01 \x01(\tR\x06taskId\x12;\n" +
        "\vcreate_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
        "createTime\"0\n" +
        "\x15GetSyncAccountRequest\x12\x17\n" +
        "\atask_id\x18\x01 \x01(\tR\x06taskId\"\xeb\x02\n" +
        "\x13GetSyncAccountReply\x12B\n" +
        "\x06status\x18\x01 \x01(\x0e2*.api.account.v1.GetSyncAccountReply.StatusR\x06status\x12\x1d\n" +
        "\n" +
        "user_count\x18\x02 \x01(\x03R\tuserCount\x12)\n" +
        "\x10department_count\x18\x03 \x01(\x03R\x0fdepartmentCount\x12C\n" +
        "\x1euser_department_relation_count\x18\x04 \x01(\x03R\x1buserDepartmentRelationCount\x12D\n" +
        "\x10latest_sync_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\x0elatestSyncTime\";\n" +
        "\x06Status\x12\v\n" +
        "\aPENDING\x10\x00\x12\v\n" +
        "\aRUNNING\x10\x01\x12\v\n" +
        "\aSUCCESS\x10\x02\x12\n" +
        "\n" +
        "\x06FAILED\x10\x03\"G\n" +
        "\x18CancelSyncAccountRequest\x12\x17\n" +
        "\atask_id\x18\x01 \x01(\tR\x06taskId\x12\x12\n" +
        "\x04tags\x18\x02 \x03(\tR\x04tags\"+\n" +
        "\x15GetAccessTokenRequest\x12\x12\n" +
        "\x04code\x18\x02 \x01(\tR\x04code\"\x7f\n" +
        "\x16GetAccessTokenResponse\x12!\n" +
        "\faccess_token\x18\x01 \x01(\tR\vaccessToken\x12#\n" +
        "\rrefresh_token\x18\x02 \x01(\tR\frefreshToken\x12\x1d\n" +
        "\n" +
        "expires_in\x18\x03 \x01(\x03R\texpiresIn\"7\n" +
        "\x12GetUserInfoRequest\x12!\n" +
        "\faccess_token\x18\x01 \x01(\tR\vaccessToken\"\x8b\x01\n" +
        "\x13GetUserInfoResponse\x12\x19\n" +
        "\bunion_id\x18\x01 \x01(\tR\aunionId\x12\x17\n" +
        "\auser_id\x18\x02 \x01(\tR\x06userId\x12\x12\n" +
        "\x04name\x18\x03 \x01(\tR\x04name\x12\x14\n" +
        "\x05email\x18\x04 \x01(\tR\x05email\x12\x16\n" +
        "\x06avatar\x18\x05 \x01(\tR\x06avatar\";\n" +
        "\x0fCallbackRequest\x12\x12\n" +
        "\x04code\x18\x01 \x01(\tR\x04code\x12\x14\n" +
        "\x05state\x18\x02 \x01(\tR\x05state\"D\n" +
        "\x10CallbackResponse\x12\x16\n" +
        "\x06status\x18\x01 \x01(\tR\x06status\x12\x18\n" +
        "\amessage\x18\x02 \x01(\tR\amessage*M\n" +
        "\vTriggerType\x12\x13\n" +
        "\x0fTRIGGER_UNKNOWN\x10\x00\x12\x12\n" +
        "\x0eTRIGGER_MANUAL\x10\x01\x12\x15\n" +
        "\x11TRIGGER_SCHEDULED\x10\x02*%\n" +
        "\bSyncType\x12\b\n" +
        "\x04FULL\x10\x00\x12\x0f\n" +
        "\vINCREMENTAL\x10\x012\x87\a\n" +
        "\aAccount\x12}\n" +
        "\x11CreateSyncAccount\x12(.api.account.v1.CreateSyncAccountRequest\x1a&amp;.api.account.v1.CreateSyncAccountReply\"\x16\x82\xd3\xe4\x93\x02\x10:\x01*\"\v/v1/account\x12q\n" +
        "\x0eGetSyncAccount\x12%.api.account.v1.GetSyncAccountRequest\x1a#.api.account.v1.GetSyncAccountReply\"\x13\x82\xd3\xe4\x93\x02\r\x12\v/v1/account\x12g\n" +
        "\x0eCancelSyncTask\x12(.api.account.v1.CancelSyncAccountRequest\x1a\x16.google.protobuf.Empty\"\x13\x82\xd3\xe4\x93\x02\r*\v/v1/account\x12u\n" +
        "\vGetUserInfo\x12\".api.account.v1.GetUserInfoRequest\x1a#.api.account.v1.GetUserInfoResponse\"\x1d\x82\xd3\xe4\x93\x02\x17\x12\x15/v1/oauth/userinfo/me\x12\x82\x01\n" +
        "\x0eGetAccessToken\x12%.api.account.v1.GetAccessTokenRequest\x1a&amp;.api.account.v1.GetAccessTokenResponse\"!\x82\xd3\xe4\x93\x02\x1b\x12\x19/v1/oauth/userAccessToken\x12i\n" +
        "\bCallback\x12\x1f.api.account.v1.CallbackRequest\x1a .api.account.v1.CallbackResponse\"\x1a\x82\xd3\xe4\x93\x02\x14\x12\x12/v1/oauth/callback\x12_\n" +
        "\n" +
        "UploadFile\x12\x1d.api.account.v1.UploadRequest\x1a\x1b.api.account.v1.UploadReply\"\x15\x82\xd3\xe4\x93\x02\x0f:\x01*\"\n" +
        "/v1/upload\x12Y\n" +
        "\aGetTask\x12\x1e.api.account.v1.GetTaskRequest\x1a\x1c.api.account.v1.GetTaskReply\"\x10\x82\xd3\xe4\x93\x02\n" +
        "\x12\b/v1/taskB?\n" +
        "\x0eapi.account.v1B\x0eAccountProtoV1P\x01Z\x1bnancalacc/api/account/v1;v1b\x06proto3"

var (
        file_api_account_v1_account_proto_rawDescOnce sync.Once
        file_api_account_v1_account_proto_rawDescData []byte
)

func file_api_account_v1_account_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_api_account_v1_account_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_api_account_v1_account_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_account_v1_account_proto_rawDesc), len(file_api_account_v1_account_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_api_account_v1_account_proto_rawDescData</span>
}

var file_api_account_v1_account_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_api_account_v1_account_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_api_account_v1_account_proto_goTypes = []any{
        (TriggerType)(0),                 // 0: api.account.v1.TriggerType
        (SyncType)(0),                    // 1: api.account.v1.SyncType
        (GetSyncAccountReply_Status)(0),  // 2: api.account.v1.GetSyncAccountReply.Status
        (*GetTaskRequest)(nil),           // 3: api.account.v1.GetTaskRequest
        (*GetTaskReply)(nil),             // 4: api.account.v1.GetTaskReply
        (*UploadRequest)(nil),            // 5: api.account.v1.UploadRequest
        (*UploadReply)(nil),              // 6: api.account.v1.UploadReply
        (*CreateSyncAccountRequest)(nil), // 7: api.account.v1.CreateSyncAccountRequest
        (*CreateSyncAccountReply)(nil),   // 8: api.account.v1.CreateSyncAccountReply
        (*GetSyncAccountRequest)(nil),    // 9: api.account.v1.GetSyncAccountRequest
        (*GetSyncAccountReply)(nil),      // 10: api.account.v1.GetSyncAccountReply
        (*CancelSyncAccountRequest)(nil), // 11: api.account.v1.CancelSyncAccountRequest
        (*GetAccessTokenRequest)(nil),    // 12: api.account.v1.GetAccessTokenRequest
        (*GetAccessTokenResponse)(nil),   // 13: api.account.v1.GetAccessTokenResponse
        (*GetUserInfoRequest)(nil),       // 14: api.account.v1.GetUserInfoRequest
        (*GetUserInfoResponse)(nil),      // 15: api.account.v1.GetUserInfoResponse
        (*CallbackRequest)(nil),          // 16: api.account.v1.CallbackRequest
        (*CallbackResponse)(nil),         // 17: api.account.v1.CallbackResponse
        (*GetTaskReply_Task)(nil),        // 18: api.account.v1.GetTaskReply.Task
        (*timestamppb.Timestamp)(nil),    // 19: google.protobuf.Timestamp
        (*emptypb.Empty)(nil),            // 20: google.protobuf.Empty
}
var file_api_account_v1_account_proto_depIdxs = []int32{
        18, // 0: api.account.v1.GetTaskReply.task:type_name -&gt; api.account.v1.GetTaskReply.Task
        0,  // 1: api.account.v1.CreateSyncAccountRequest.trigger_type:type_name -&gt; api.account.v1.TriggerType
        1,  // 2: api.account.v1.CreateSyncAccountRequest.sync_type:type_name -&gt; api.account.v1.SyncType
        19, // 3: api.account.v1.CreateSyncAccountReply.create_time:type_name -&gt; google.protobuf.Timestamp
        2,  // 4: api.account.v1.GetSyncAccountReply.status:type_name -&gt; api.account.v1.GetSyncAccountReply.Status
        19, // 5: api.account.v1.GetSyncAccountReply.latest_sync_time:type_name -&gt; google.protobuf.Timestamp
        19, // 6: api.account.v1.GetTaskReply.Task.create_time:type_name -&gt; google.protobuf.Timestamp
        19, // 7: api.account.v1.GetTaskReply.Task.start_time:type_name -&gt; google.protobuf.Timestamp
        19, // 8: api.account.v1.GetTaskReply.Task.completed_time:type_name -&gt; google.protobuf.Timestamp
        7,  // 9: api.account.v1.Account.CreateSyncAccount:input_type -&gt; api.account.v1.CreateSyncAccountRequest
        9,  // 10: api.account.v1.Account.GetSyncAccount:input_type -&gt; api.account.v1.GetSyncAccountRequest
        11, // 11: api.account.v1.Account.CancelSyncTask:input_type -&gt; api.account.v1.CancelSyncAccountRequest
        14, // 12: api.account.v1.Account.GetUserInfo:input_type -&gt; api.account.v1.GetUserInfoRequest
        12, // 13: api.account.v1.Account.GetAccessToken:input_type -&gt; api.account.v1.GetAccessTokenRequest
        16, // 14: api.account.v1.Account.Callback:input_type -&gt; api.account.v1.CallbackRequest
        5,  // 15: api.account.v1.Account.UploadFile:input_type -&gt; api.account.v1.UploadRequest
        3,  // 16: api.account.v1.Account.GetTask:input_type -&gt; api.account.v1.GetTaskRequest
        8,  // 17: api.account.v1.Account.CreateSyncAccount:output_type -&gt; api.account.v1.CreateSyncAccountReply
        10, // 18: api.account.v1.Account.GetSyncAccount:output_type -&gt; api.account.v1.GetSyncAccountReply
        20, // 19: api.account.v1.Account.CancelSyncTask:output_type -&gt; google.protobuf.Empty
        15, // 20: api.account.v1.Account.GetUserInfo:output_type -&gt; api.account.v1.GetUserInfoResponse
        13, // 21: api.account.v1.Account.GetAccessToken:output_type -&gt; api.account.v1.GetAccessTokenResponse
        17, // 22: api.account.v1.Account.Callback:output_type -&gt; api.account.v1.CallbackResponse
        6,  // 23: api.account.v1.Account.UploadFile:output_type -&gt; api.account.v1.UploadReply
        4,  // 24: api.account.v1.Account.GetTask:output_type -&gt; api.account.v1.GetTaskReply
        17, // [17:25] is the sub-list for method output_type
        9,  // [9:17] is the sub-list for method input_type
        9,  // [9:9] is the sub-list for extension type_name
        9,  // [9:9] is the sub-list for extension extendee
        0,  // [0:9] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_api_account_v1_account_proto_init() }</span>
func file_api_account_v1_account_proto_init() <span class="cov0" title="0">{
        if File_api_account_v1_account_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_api_account_v1_account_proto_msgTypes[4].OneofWrappers = []any{}
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_account_v1_account_proto_rawDesc), len(file_api_account_v1_account_proto_rawDesc)),
                        NumEnums:      3,
                        NumMessages:   16,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_api_account_v1_account_proto_goTypes,
                DependencyIndexes: file_api_account_v1_account_proto_depIdxs,
                EnumInfos:         file_api_account_v1_account_proto_enumTypes,
                MessageInfos:      file_api_account_v1_account_proto_msgTypes,
        }.Build()
        File_api_account_v1_account_proto = out.File
        file_api_account_v1_account_proto_goTypes = nil
        file_api_account_v1_account_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: api/account/v1/account.proto

package v1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Account_CreateSyncAccount_FullMethodName = "/api.account.v1.Account/CreateSyncAccount"
        Account_GetSyncAccount_FullMethodName    = "/api.account.v1.Account/GetSyncAccount"
        Account_CancelSyncTask_FullMethodName    = "/api.account.v1.Account/CancelSyncTask"
        Account_GetUserInfo_FullMethodName       = "/api.account.v1.Account/GetUserInfo"
        Account_GetAccessToken_FullMethodName    = "/api.account.v1.Account/GetAccessToken"
        Account_Callback_FullMethodName          = "/api.account.v1.Account/Callback"
        Account_UploadFile_FullMethodName        = "/api.account.v1.Account/UploadFile"
        Account_GetTask_FullMethodName           = "/api.account.v1.Account/GetTask"
)

// AccountClient is the client API for Account service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AccountClient interface {
        CreateSyncAccount(ctx context.Context, in *CreateSyncAccountRequest, opts ...grpc.CallOption) (*CreateSyncAccountReply, error)
        GetSyncAccount(ctx context.Context, in *GetSyncAccountRequest, opts ...grpc.CallOption) (*GetSyncAccountReply, error)
        CancelSyncTask(ctx context.Context, in *CancelSyncAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*GetUserInfoResponse, error)
        GetAccessToken(ctx context.Context, in *GetAccessTokenRequest, opts ...grpc.CallOption) (*GetAccessTokenResponse, error)
        Callback(ctx context.Context, in *CallbackRequest, opts ...grpc.CallOption) (*CallbackResponse, error)
        UploadFile(ctx context.Context, in *UploadRequest, opts ...grpc.CallOption) (*UploadReply, error)
        GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*GetTaskReply, error)
}

type accountClient struct {
        cc grpc.ClientConnInterface
}

func NewAccountClient(cc grpc.ClientConnInterface) AccountClient <span class="cov0" title="0">{
        return &amp;accountClient{cc}
}</span>

func (c *accountClient) CreateSyncAccount(ctx context.Context, in *CreateSyncAccountRequest, opts ...grpc.CallOption) (*CreateSyncAccountReply, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateSyncAccountReply)
        err := c.cc.Invoke(ctx, Account_CreateSyncAccount_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *accountClient) GetSyncAccount(ctx context.Context, in *GetSyncAccountRequest, opts ...grpc.CallOption) (*GetSyncAccountReply, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetSyncAccountReply)
        err := c.cc.Invoke(ctx, Account_GetSyncAccount_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *accountClient) CancelSyncTask(ctx context.Context, in *CancelSyncAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, Account_CancelSyncTask_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *accountClient) GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*GetUserInfoResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserInfoResponse)
        err := c.cc.Invoke(ctx, Account_GetUserInfo_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *accountClient) GetAccessToken(ctx context.Context, in *GetAccessTokenRequest, opts ...grpc.CallOption) (*GetAccessTokenResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetAccessTokenResponse)
        err := c.cc.Invoke(ctx, Account_GetAccessToken_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *accountClient) Callback(ctx context.Context, in *CallbackRequest, opts ...grpc.CallOption) (*CallbackResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CallbackResponse)
        err := c.cc.Invoke(ctx, Account_Callback_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *accountClient) UploadFile(ctx context.Context, in *UploadRequest, opts ...grpc.CallOption) (*UploadReply, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UploadReply)
        err := c.cc.Invoke(ctx, Account_UploadFile_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *accountClient) GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*GetTaskReply, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetTaskReply)
        err := c.cc.Invoke(ctx, Account_GetTask_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AccountServer is the server API for Account service.
// All implementations must embed UnimplementedAccountServer
// for forward compatibility.
type AccountServer interface {
        CreateSyncAccount(context.Context, *CreateSyncAccountRequest) (*CreateSyncAccountReply, error)
        GetSyncAccount(context.Context, *GetSyncAccountRequest) (*GetSyncAccountReply, error)
        CancelSyncTask(context.Context, *CancelSyncAccountRequest) (*emptypb.Empty, error)
        GetUserInfo(context.Context, *GetUserInfoRequest) (*GetUserInfoResponse, error)
        GetAccessToken(context.Context, *GetAccessTokenRequest) (*GetAccessTokenResponse, error)
        Callback(context.Context, *CallbackRequest) (*CallbackResponse, error)
        UploadFile(context.Context, *UploadRequest) (*UploadReply, error)
        GetTask(context.Context, *GetTaskRequest) (*GetTaskReply, error)
        mustEmbedUnimplementedAccountServer()
}

// UnimplementedAccountServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAccountServer struct{}

func (UnimplementedAccountServer) CreateSyncAccount(context.Context, *CreateSyncAccountRequest) (*CreateSyncAccountReply, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateSyncAccount not implemented")
}</span>
func (UnimplementedAccountServer) GetSyncAccount(context.Context, *GetSyncAccountRequest) (*GetSyncAccountReply, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSyncAccount not implemented")
}</span>
func (UnimplementedAccountServer) CancelSyncTask(context.Context, *CancelSyncAccountRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CancelSyncTask not implemented")
}</span>
func (UnimplementedAccountServer) GetUserInfo(context.Context, *GetUserInfoRequest) (*GetUserInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserInfo not implemented")
}</span>
func (UnimplementedAccountServer) GetAccessToken(context.Context, *GetAccessTokenRequest) (*GetAccessTokenResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetAccessToken not implemented")
}</span>
func (UnimplementedAccountServer) Callback(context.Context, *CallbackRequest) (*CallbackResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Callback not implemented")
}</span>
func (UnimplementedAccountServer) UploadFile(context.Context, *UploadRequest) (*UploadReply, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UploadFile not implemented")
}</span>
func (UnimplementedAccountServer) GetTask(context.Context, *GetTaskRequest) (*GetTaskReply, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetTask not implemented")
}</span>
func (UnimplementedAccountServer) mustEmbedUnimplementedAccountServer() {<span class="cov0" title="0">}</span>
func (UnimplementedAccountServer) testEmbeddedByValue()                 {<span class="cov0" title="0">}</span>

// UnsafeAccountServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccountServer will
// result in compilation errors.
type UnsafeAccountServer interface {
        mustEmbedUnimplementedAccountServer()
}

func RegisterAccountServer(s grpc.ServiceRegistrar, srv AccountServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedAccountServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Account_ServiceDesc, srv)</span>
}

func _Account_CreateSyncAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateSyncAccountRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AccountServer).CreateSyncAccount(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Account_CreateSyncAccount_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AccountServer).CreateSyncAccount(ctx, req.(*CreateSyncAccountRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Account_GetSyncAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetSyncAccountRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AccountServer).GetSyncAccount(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Account_GetSyncAccount_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AccountServer).GetSyncAccount(ctx, req.(*GetSyncAccountRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Account_CancelSyncTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CancelSyncAccountRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AccountServer).CancelSyncTask(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Account_CancelSyncTask_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AccountServer).CancelSyncTask(ctx, req.(*CancelSyncAccountRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Account_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AccountServer).GetUserInfo(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Account_GetUserInfo_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AccountServer).GetUserInfo(ctx, req.(*GetUserInfoRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Account_GetAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetAccessTokenRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AccountServer).GetAccessToken(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Account_GetAccessToken_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AccountServer).GetAccessToken(ctx, req.(*GetAccessTokenRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Account_Callback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CallbackRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AccountServer).Callback(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Account_Callback_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AccountServer).Callback(ctx, req.(*CallbackRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Account_UploadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UploadRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AccountServer).UploadFile(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Account_UploadFile_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AccountServer).UploadFile(ctx, req.(*UploadRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Account_GetTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetTaskRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AccountServer).GetTask(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Account_GetTask_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AccountServer).GetTask(ctx, req.(*GetTaskRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Account_ServiceDesc is the grpc.ServiceDesc for Account service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Account_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "api.account.v1.Account",
        HandlerType: (*AccountServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateSyncAccount",
                        Handler:    _Account_CreateSyncAccount_Handler,
                },
                {
                        MethodName: "GetSyncAccount",
                        Handler:    _Account_GetSyncAccount_Handler,
                },
                {
                        MethodName: "CancelSyncTask",
                        Handler:    _Account_CancelSyncTask_Handler,
                },
                {
                        MethodName: "GetUserInfo",
                        Handler:    _Account_GetUserInfo_Handler,
                },
                {
                        MethodName: "GetAccessToken",
                        Handler:    _Account_GetAccessToken_Handler,
                },
                {
                        MethodName: "Callback",
                        Handler:    _Account_Callback_Handler,
                },
                {
                        MethodName: "UploadFile",
                        Handler:    _Account_UploadFile_Handler,
                },
                {
                        MethodName: "GetTask",
                        Handler:    _Account_GetTask_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "api/account/v1/account.proto",
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.4
// - protoc             v5.29.3
// source: api/account/v1/account.proto

package v1

import (
        context "context"
        http "github.com/go-kratos/kratos/v2/transport/http"
        binding "github.com/go-kratos/kratos/v2/transport/http/binding"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationAccountCallback = "/api.account.v1.Account/Callback"
const OperationAccountCancelSyncTask = "/api.account.v1.Account/CancelSyncTask"
const OperationAccountCreateSyncAccount = "/api.account.v1.Account/CreateSyncAccount"
const OperationAccountGetAccessToken = "/api.account.v1.Account/GetAccessToken"
const OperationAccountGetSyncAccount = "/api.account.v1.Account/GetSyncAccount"
const OperationAccountGetTask = "/api.account.v1.Account/GetTask"
const OperationAccountGetUserInfo = "/api.account.v1.Account/GetUserInfo"
const OperationAccountUploadFile = "/api.account.v1.Account/UploadFile"

type AccountHTTPServer interface {
        Callback(context.Context, *CallbackRequest) (*CallbackResponse, error)
        CancelSyncTask(context.Context, *CancelSyncAccountRequest) (*emptypb.Empty, error)
        CreateSyncAccount(context.Context, *CreateSyncAccountRequest) (*CreateSyncAccountReply, error)
        GetAccessToken(context.Context, *GetAccessTokenRequest) (*GetAccessTokenResponse, error)
        GetSyncAccount(context.Context, *GetSyncAccountRequest) (*GetSyncAccountReply, error)
        GetTask(context.Context, *GetTaskRequest) (*GetTaskReply, error)
        GetUserInfo(context.Context, *GetUserInfoRequest) (*GetUserInfoResponse, error)
        UploadFile(context.Context, *UploadRequest) (*UploadReply, error)
}

func RegisterAccountHTTPServer(s *http.Server, srv AccountHTTPServer) <span class="cov0" title="0">{
        r := s.Route("/")
        r.POST("/v1/account", _Account_CreateSyncAccount0_HTTP_Handler(srv))
        r.GET("/v1/account", _Account_GetSyncAccount0_HTTP_Handler(srv))
        r.DELETE("/v1/account", _Account_CancelSyncTask0_HTTP_Handler(srv))
        r.GET("/v1/oauth/userinfo/me", _Account_GetUserInfo0_HTTP_Handler(srv))
        r.GET("/v1/oauth/userAccessToken", _Account_GetAccessToken0_HTTP_Handler(srv))
        r.GET("/v1/oauth/callback", _Account_Callback0_HTTP_Handler(srv))
        r.POST("/v1/upload", _Account_UploadFile0_HTTP_Handler(srv))
        r.GET("/v1/task", _Account_GetTask0_HTTP_Handler(srv))
}</span>

func _Account_CreateSyncAccount0_HTTP_Handler(srv AccountHTTPServer) func(ctx http.Context) error <span class="cov0" title="0">{
        return func(ctx http.Context) error </span><span class="cov0" title="0">{
                var in CreateSyncAccountRequest
                if err := ctx.Bind(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := ctx.BindQuery(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">http.SetOperation(ctx, OperationAccountCreateSyncAccount)
                h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return srv.CreateSyncAccount(ctx, req.(*CreateSyncAccountRequest))
                }</span>)
                <span class="cov0" title="0">out, err := h(ctx, &amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reply := out.(*CreateSyncAccountReply)
                return ctx.Result(200, reply)</span>
        }
}

func _Account_GetSyncAccount0_HTTP_Handler(srv AccountHTTPServer) func(ctx http.Context) error <span class="cov0" title="0">{
        return func(ctx http.Context) error </span><span class="cov0" title="0">{
                var in GetSyncAccountRequest
                if err := ctx.BindQuery(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">http.SetOperation(ctx, OperationAccountGetSyncAccount)
                h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return srv.GetSyncAccount(ctx, req.(*GetSyncAccountRequest))
                }</span>)
                <span class="cov0" title="0">out, err := h(ctx, &amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reply := out.(*GetSyncAccountReply)
                return ctx.Result(200, reply)</span>
        }
}

func _Account_CancelSyncTask0_HTTP_Handler(srv AccountHTTPServer) func(ctx http.Context) error <span class="cov0" title="0">{
        return func(ctx http.Context) error </span><span class="cov0" title="0">{
                var in CancelSyncAccountRequest
                if err := ctx.BindQuery(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">http.SetOperation(ctx, OperationAccountCancelSyncTask)
                h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return srv.CancelSyncTask(ctx, req.(*CancelSyncAccountRequest))
                }</span>)
                <span class="cov0" title="0">out, err := h(ctx, &amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reply := out.(*emptypb.Empty)
                return ctx.Result(200, reply)</span>
        }
}

func _Account_GetUserInfo0_HTTP_Handler(srv AccountHTTPServer) func(ctx http.Context) error <span class="cov0" title="0">{
        return func(ctx http.Context) error </span><span class="cov0" title="0">{
                var in GetUserInfoRequest
                if err := ctx.BindQuery(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">http.SetOperation(ctx, OperationAccountGetUserInfo)
                h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return srv.GetUserInfo(ctx, req.(*GetUserInfoRequest))
                }</span>)
                <span class="cov0" title="0">out, err := h(ctx, &amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reply := out.(*GetUserInfoResponse)
                return ctx.Result(200, reply)</span>
        }
}

func _Account_GetAccessToken0_HTTP_Handler(srv AccountHTTPServer) func(ctx http.Context) error <span class="cov0" title="0">{
        return func(ctx http.Context) error </span><span class="cov0" title="0">{
                var in GetAccessTokenRequest
                if err := ctx.BindQuery(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">http.SetOperation(ctx, OperationAccountGetAccessToken)
                h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return srv.GetAccessToken(ctx, req.(*GetAccessTokenRequest))
                }</span>)
                <span class="cov0" title="0">out, err := h(ctx, &amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reply := out.(*GetAccessTokenResponse)
                return ctx.Result(200, reply)</span>
        }
}

func _Account_Callback0_HTTP_Handler(srv AccountHTTPServer) func(ctx http.Context) error <span class="cov0" title="0">{
        return func(ctx http.Context) error </span><span class="cov0" title="0">{
                var in CallbackRequest
                if err := ctx.BindQuery(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">http.SetOperation(ctx, OperationAccountCallback)
                h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return srv.Callback(ctx, req.(*CallbackRequest))
                }</span>)
                <span class="cov0" title="0">out, err := h(ctx, &amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reply := out.(*CallbackResponse)
                return ctx.Result(200, reply)</span>
        }
}

func _Account_UploadFile0_HTTP_Handler(srv AccountHTTPServer) func(ctx http.Context) error <span class="cov0" title="0">{
        return func(ctx http.Context) error </span><span class="cov0" title="0">{
                var in UploadRequest
                if err := ctx.Bind(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := ctx.BindQuery(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">http.SetOperation(ctx, OperationAccountUploadFile)
                h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return srv.UploadFile(ctx, req.(*UploadRequest))
                }</span>)
                <span class="cov0" title="0">out, err := h(ctx, &amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reply := out.(*UploadReply)
                return ctx.Result(200, reply)</span>
        }
}

func _Account_GetTask0_HTTP_Handler(srv AccountHTTPServer) func(ctx http.Context) error <span class="cov0" title="0">{
        return func(ctx http.Context) error </span><span class="cov0" title="0">{
                var in GetTaskRequest
                if err := ctx.BindQuery(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">http.SetOperation(ctx, OperationAccountGetTask)
                h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return srv.GetTask(ctx, req.(*GetTaskRequest))
                }</span>)
                <span class="cov0" title="0">out, err := h(ctx, &amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reply := out.(*GetTaskReply)
                return ctx.Result(200, reply)</span>
        }
}

type AccountHTTPClient interface {
        Callback(ctx context.Context, req *CallbackRequest, opts ...http.CallOption) (rsp *CallbackResponse, err error)
        CancelSyncTask(ctx context.Context, req *CancelSyncAccountRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
        CreateSyncAccount(ctx context.Context, req *CreateSyncAccountRequest, opts ...http.CallOption) (rsp *CreateSyncAccountReply, err error)
        GetAccessToken(ctx context.Context, req *GetAccessTokenRequest, opts ...http.CallOption) (rsp *GetAccessTokenResponse, err error)
        GetSyncAccount(ctx context.Context, req *GetSyncAccountRequest, opts ...http.CallOption) (rsp *GetSyncAccountReply, err error)
        GetTask(ctx context.Context, req *GetTaskRequest, opts ...http.CallOption) (rsp *GetTaskReply, err error)
        GetUserInfo(ctx context.Context, req *GetUserInfoRequest, opts ...http.CallOption) (rsp *GetUserInfoResponse, err error)
        UploadFile(ctx context.Context, req *UploadRequest, opts ...http.CallOption) (rsp *UploadReply, err error)
}

type AccountHTTPClientImpl struct {
        cc *http.Client
}

func NewAccountHTTPClient(client *http.Client) AccountHTTPClient <span class="cov0" title="0">{
        return &amp;AccountHTTPClientImpl{client}
}</span>

func (c *AccountHTTPClientImpl) Callback(ctx context.Context, in *CallbackRequest, opts ...http.CallOption) (*CallbackResponse, error) <span class="cov0" title="0">{
        var out CallbackResponse
        pattern := "/v1/oauth/callback"
        path := binding.EncodeURL(pattern, in, true)
        opts = append(opts, http.Operation(OperationAccountCallback))
        opts = append(opts, http.PathTemplate(pattern))
        err := c.cc.Invoke(ctx, "GET", path, nil, &amp;out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;out, nil</span>
}

func (c *AccountHTTPClientImpl) CancelSyncTask(ctx context.Context, in *CancelSyncAccountRequest, opts ...http.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        var out emptypb.Empty
        pattern := "/v1/account"
        path := binding.EncodeURL(pattern, in, true)
        opts = append(opts, http.Operation(OperationAccountCancelSyncTask))
        opts = append(opts, http.PathTemplate(pattern))
        err := c.cc.Invoke(ctx, "DELETE", path, nil, &amp;out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;out, nil</span>
}

func (c *AccountHTTPClientImpl) CreateSyncAccount(ctx context.Context, in *CreateSyncAccountRequest, opts ...http.CallOption) (*CreateSyncAccountReply, error) <span class="cov0" title="0">{
        var out CreateSyncAccountReply
        pattern := "/v1/account"
        path := binding.EncodeURL(pattern, in, false)
        opts = append(opts, http.Operation(OperationAccountCreateSyncAccount))
        opts = append(opts, http.PathTemplate(pattern))
        err := c.cc.Invoke(ctx, "POST", path, in, &amp;out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;out, nil</span>
}

func (c *AccountHTTPClientImpl) GetAccessToken(ctx context.Context, in *GetAccessTokenRequest, opts ...http.CallOption) (*GetAccessTokenResponse, error) <span class="cov0" title="0">{
        var out GetAccessTokenResponse
        pattern := "/v1/oauth/userAccessToken"
        path := binding.EncodeURL(pattern, in, true)
        opts = append(opts, http.Operation(OperationAccountGetAccessToken))
        opts = append(opts, http.PathTemplate(pattern))
        err := c.cc.Invoke(ctx, "GET", path, nil, &amp;out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;out, nil</span>
}

func (c *AccountHTTPClientImpl) GetSyncAccount(ctx context.Context, in *GetSyncAccountRequest, opts ...http.CallOption) (*GetSyncAccountReply, error) <span class="cov0" title="0">{
        var out GetSyncAccountReply
        pattern := "/v1/account"
        path := binding.EncodeURL(pattern, in, true)
        opts = append(opts, http.Operation(OperationAccountGetSyncAccount))
        opts = append(opts, http.PathTemplate(pattern))
        err := c.cc.Invoke(ctx, "GET", path, nil, &amp;out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;out, nil</span>
}

func (c *AccountHTTPClientImpl) GetTask(ctx context.Context, in *GetTaskRequest, opts ...http.CallOption) (*GetTaskReply, error) <span class="cov0" title="0">{
        var out GetTaskReply
        pattern := "/v1/task"
        path := binding.EncodeURL(pattern, in, true)
        opts = append(opts, http.Operation(OperationAccountGetTask))
        opts = append(opts, http.PathTemplate(pattern))
        err := c.cc.Invoke(ctx, "GET", path, nil, &amp;out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;out, nil</span>
}

func (c *AccountHTTPClientImpl) GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...http.CallOption) (*GetUserInfoResponse, error) <span class="cov0" title="0">{
        var out GetUserInfoResponse
        pattern := "/v1/oauth/userinfo/me"
        path := binding.EncodeURL(pattern, in, true)
        opts = append(opts, http.Operation(OperationAccountGetUserInfo))
        opts = append(opts, http.PathTemplate(pattern))
        err := c.cc.Invoke(ctx, "GET", path, nil, &amp;out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;out, nil</span>
}

func (c *AccountHTTPClientImpl) UploadFile(ctx context.Context, in *UploadRequest, opts ...http.CallOption) (*UploadReply, error) <span class="cov0" title="0">{
        var out UploadReply
        pattern := "/v1/upload"
        path := binding.EncodeURL(pattern, in, false)
        opts = append(opts, http.Operation(OperationAccountUploadFile))
        opts = append(opts, http.PathTemplate(pattern))
        err := c.cc.Invoke(ctx, "POST", path, in, &amp;out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;out, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "flag"
        "fmt"

        // "fmt"
        "nancalacc/internal/conf"

        "github.com/go-kratos/kratos/v2/config"
        "github.com/go-kratos/kratos/v2/config/file"
)

var (
        bc conf.Bootstrap
)

func init() <span class="cov0" title="0">{
        var flagconf string
        flag.StringVar(&amp;flagconf, "conf", "../../configs", "config path, eg: -conf config.yaml")
        flag.Parse()

        c := config.New(
                config.WithSource(
                        file.NewSource(flagconf),
                ),
        )
        defer c.Close()

        if err := c.Load(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">if err := c.Scan(&amp;bc); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func main() <span class="cov0" title="0">{

        fmt.Println("start...")

        // CheckReadExcell()
        // ctx := context.Background()
        // fmt.Printf("bc: %+v\n", bc.Service)
        // 初始化 WpsSync
        // token, err := auth.NewAppAuthenticator(bc.Service).GetAccessToken(ctx)

        // if err != nil {
        //         panic(err)
        // }

        // fmt.Printf("token: %+v\n", token)

        //token := GetToken()
        //fmt.Println(token)
        // token := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NTM2MTU2MTgsImNvbXBfaWQiOiIxIiwiY2xpZW50X2lkIjoiY29tLmFjYy5hc3luYyIsInRrX3R5cGUiOiJhcHAiLCJzY29wZSI6Imtzby5hY2NvdW50c3luYy5zeW5jLGtzby5jb250YWN0LnJlYWQsa3NvLmNvbnRhY3QucmVhZHdyaXRlIiwiY29tcGFueV9pZCI6MSwiY2xpZW50X3ByaW5jaXBhbF9pZCI6IjczIiwiaXNfd3BzMzY1Ijp0cnVlfQ.ZOkiwnZ6f1uW45_sq5uT_ZW3dmA6yCXuKetMaUI7mCw"
        // 29290326581145992
        //CheckBatchGetDepartment(token)
        //CheckPostBatchUsersByExDepIds(token)
        // CheckPostBatchDepartmentsByExDepIds(token)
        //CheckGetUserByUserId(token)
        //CheckBatchPostUsers(token)

        // CheckPostBatchDepartmentsByExDepIds(token)
        // CheckUserLeaveOrg()
        // CheckPostBatchUsersByExDepIds(token)
        // CheckGetDepartmentRoot(token)
        //CheckBatchGetDepartment(token)
        // 033014104332101118010 test
        // CheckCallEcisaccountsync(token)
        // CheckGetDingtalkUserDetail()
        // "29290326581145992"
        // 03301410433273270
        //users, err := FindWpsUser(context.Background(), []string{"29290326581145992"})

        // if err != nil {
        //         panic(err)
        // }
        // for _, u := range users {
        //         fmt.Printf("FindWpsUser user: %v\n", *u)
        // }
        //CheckGetCompAllUsers()
        // CheckGetCompAllDepts()
        // FindAndDeleteUser()
        //FindAndDeleteDept("存在应用授权")
        // ctx := context.Background()
        // appAccessToken, err := auth.NewAppAuthenticator(bc.Service).GetAccessToken(ctx)
        // if err != nil {
        //         panic(err)
        // }
        //fmt.Printf("appAccessToken: %s\n", appAccessToken.AccessToken)
        // CheckPostCreateUser(appAccessToken.AccessToken)
        //CheckDeleteDept(appAccessToken.AccessToken)
        // authApp := auth.NewAppAuthenticator(bc.Service)

        // authCache := auth.NewAppCacheAuthenticator(authApp)

        // AesEncryptGcmByKey

        // mobile, err := cipherutil.DecryptValueWithEnvSalt("HyyjnqUeVqHoid9cprHMoPgkOAVu8farJigGpvOi+xm0aLO2ZytG")
        // fmt.Printf("mobile: %s, err:%v\n", mobile, err)
        // CheckGetCompAllUsers(appAccessToken.AccessToken)
        // CheckInternalGateWay(appAccessToken.AccessToken)

        // 81
        // CheckGetUsersSearch(appAccessToken.AccessToken)
        // authDingtalk := auth.NewDingTalkAuthenticator(bc.Service)
        // authCache := auth.NewDingtalkCacheAuthenticator(authDingtalk)

        // // authCache := auth.NewDingtalkCacheAuthenticator(authDingtalk, auth.WithKey[*auth.DingtalkCacheConfig]("custom_key"))

        // token, err := authCache.GetAccessToken(ctx)
        // if err != nil {
        //         panic(err)
        // }
        // dingtalkRepo := dingtalk.NewDingTalkRepo(bc.Service.Auth.Dingtalk, authCache, log.GetLogger())

        // depts, err := dingtalkRepo.FetchDepartments(ctx, token.AccessToken)
        // log.Infof("CreateSyncAccount.FetchDepartments: depts: %+v, err: %v", depts, err)
        // if err != nil {
        //         panic(err)
        // }
        // for _, dept := range depts {
        //         log.Infof("biz.CreateSyncAccount: dept: %+v", dept)
        // }
        // var deptIds []int64
        // for _, dept := range depts {
        //         deptIds = append(deptIds, dept.DeptID)
        // }

        // deptUsers, err := dingtalkRepo.FetchDepartmentUsers(ctx, token.AccessToken, deptIds)

        // log.Infof("CreateSyncAccount.FetchDepartmentUsers deptUsers: %v, err: %v", deptUsers, err)
        // for _, deptUser := range deptUsers {
        //         log.Infof("biz.CreateSyncAccount: deptUser: %+v", deptUser)
        // }
        // if err != nil {
        //         panic(err)
        // }
        // fmt.Println("success")
        // for i := 1; i &lt;= 3; i++ {
        //         token, err := authCache.GetAccessToken(ctx)
        //         fmt.Printf("GetAccessToken i:%d, token:%s, err:%v", i, token.AccessToken, err)
        //         // return
        // }

}</span>

// func CheckInternalGateWay(token string) {
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())
//         // 批量删除用户
//         res, err := wpsClient.GetObjUploadUrl(context.Background(), token, wps.GetObjUploadUrlRequest{})

//         fmt.Printf("res:%+v, err:%+v", res, err)

// }
// func CheckPostBatchDeleteUser(token string, userids []string) {
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())
//         // 批量删除用户
//         delUserRes, err := wpsClient.PostBatchDeleteUser(context.Background(), token, wps.PostBatchDeleteUserRequest{
//                 UserIDs: userids,
//         })
//         fmt.Printf("delUserRes:%v, err:%v", delUserRes, err)
// }
// func CheckPostCreateUser(appToken string) {
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())
//         createUserRes, err := wpsClient.PostCreateUser(context.Background(), appToken, wps.PostCreateUserRequest{
//                 ExUserID:  "test01_user",
//                 Email:     "test01@163.com",
//                 UserName:  "test01",
//                 LoginName: "13888888888",
//                 Phone:     "13888888888",
//                 DeptIDs:   []string{"1"},
//                 Source:    "sync",
//                 WorkPlace: "bj",
//         })

//         fmt.Printf("createUserRes:%v, err:%v", createUserRes, err)
// }

// // 创建的也存在授权
// func CheckPostCreateDept(appToken string) {
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())
//         parentID := "1"
//         createDeptRes, err := wpsClient.PostCreateDept(context.Background(), appToken, wps.PostCreateDeptRequest{
//                 ExDeptID: "test01",
//                 Name:     "test01_dep",
//                 ParentID: parentID,
//                 Source:   "sync",
//                 Order:    99,
//         })
//         fmt.Printf("createDeptRes:%v, err:%v", createDeptRes, err)
// }
// func CheckGetUsersSearch(appToken string) {

//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())
//         // 批量删除部门
//         // := []string{"6", "4"}
//         // deleDeptRes, err := wpsClient.GetUsersSearch(context.Background(), appToken, wps.GetUsersSearchRequest{
//         //         Keyword:  "18910953345",
//         //         PageSize: 10,
//         //         //Status:                   []string{"active", "notactive", "disabled"},
//         //         //SearchSource:             []string{"company_user", "external_contact", "enterprise_partner"},
//         //         //SearchFieldConfigEnabled: false,
//         // })
//         // fmt.Printf("deleDeptRes:%v, err:%v", deleDeptRes, err)

//         // 获取通讯录权限
//         contactPermissionRes, err := wpsClient.GetContactPermission(context.Background(), appToken, wps.GetContactPermissionRequest{
//                 Scopes: []string{"org"},
//         })
//         if err != nil {
//                 panic(err)
//         }
//         fmt.Printf("contactPermissionRes:%v, err:%v", contactPermissionRes, err)
// }

// func CheckDeleteDept(appToken string) {

//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())
//         // 批量删除部门
//         needDeldept := []string{"6000", "4000"}
//         deleDeptRes, err := wpsClient.PostBatchDeleteDept(context.Background(), appToken, wps.PostBatchDeleteDeptRequest{
//                 DeptIDs: needDeldept,
//         })
//         fmt.Printf("deleDeptRes:%v, err:%v", deleDeptRes, err)
// }
// func FindAndDeleteDept() {
//         ctx := context.Background()
//         appAccessToken, err := auth.NewAppAuthenticator(bc.Service).GetAccessToken(ctx)
//         if err != nil {
//                 panic(err)
//         }
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())
//         //查询根部门
//         rootDept, err := wpsClient.GetDepartmentRoot(ctx, appAccessToken.AccessToken, wps.GetDepartmentRootRequest{})
//         if err != nil {
//                 panic(err)
//         }
//         log.Infof("rootDept: %v", rootDept)

//         // 2. 查询部门下的子部门(要递归)
//         allDepts, err := wpsClient.GetDeptChildren(ctx, appAccessToken.AccessToken, wps.GetDeptChildrenRequest{
//                 DeptID:    rootDept.Data.ID,
//                 Recursive: true,
//                 PageSize:  50,
//                 WithTotal: true,
//         })
//         if err != nil {
//                 panic(err)
//         }
//         log.Infof("children: %v", allDepts)

//         //删除部门除了根部门
//         var alldeptes []string
//         for _, dept := range allDepts.Data.Items {
//                 if dept.ID == rootDept.Data.ID {
//                         continue
//                 }
//                 alldeptes = append(alldeptes, dept.ID)
//         }

//         needDeldept := alldeptes[:2]
//         fmt.Printf("deletedept: %v", needDeldept)
//         // 批量删除部门
//         deleDeptRes, err := wpsClient.PostBatchDeleteDept(ctx, appAccessToken.AccessToken, wps.PostBatchDeleteDeptRequest{
//                 DeptIDs: needDeldept,
//         })
//         fmt.Printf("deleDeptRes:%v, err:%v", deleDeptRes, err)
// }
// func FindAndDeleteUser() {
//         ctx := context.Background()
//         appAccessToken, err := auth.NewAppAuthenticator(bc.Service).GetAccessToken(ctx)
//         if err != nil {
//                 panic(err)
//         }
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         users, err := wpsClient.GetCompAllUsers(ctx, appAccessToken.AccessToken, wps.GetCompAllUsersRequest{
//                 Recursive: true,
//                 PageSize:  50,
//                 WithTotal: true,
//                 Status:    []string{"active", "notactive", "disabled"},
//         })
//         if err != nil {
//                 panic(err)
//         }

//         var deleteUser *dingtalk.DingtalkDeptUser
//         for _, user := range users.Data.Items {
//                 log.Infof("user: %+v", user)
//                 if user.Phone == "18910953345" {
//                         deleteUser = &amp;dingtalk.DingtalkDeptUser{
//                                 Userid: user.ExUserID,
//                                 Mobile: user.Phone,
//                                 Name:   user.UserName,
//                                 Email:  user.Email,
//                         }
//                 }
//                 for _, dep := range user.Depts {
//                         depId, _ := strconv.ParseInt(dep.DeptID, 10, 64)
//                         deleteUser.DeptIDList = append(deleteUser.DeptIDList, depId)
//                 }
//         }
//         syncDB, err := data.NewMysqlSyncDB(bc.Data, log.GetLogger())
//         if err != nil {
//                 panic(err)
//                 //return nil, nil, err
//         }
//         mainDB, err := data.NewMysqlDB(bc.Data, log.GetLogger())
//         if err != nil {
//                 panic(err)
//                 //return nil, nil, err
//         }
//         client, err := data.NewRedisClient(bc.Data, log.GetLogger())
//         if err != nil {
//                 panic(err)
//                 //return nil, nil, err
//         }
//         dataData, _, err := data.NewData(syncDB, mainDB, client, log.GetLogger())
//         if err != nil {
//                 panic(err)
//                 // return nil, nil, err
//         }

//         accounterRepo := data.NewAccounterRepo(bc.Service, dataData, log.GetLogger())
//         err = accounterRepo.SaveIncrementUsers(ctx, nil, []*dingtalk.DingtalkDeptUser{deleteUser}, nil)
//         if err != nil {
//                 panic(err)
//                 //return err
//         }

//         wpsSync := wps.NewWpsSync(bc.Service, log.GetLogger())
//         res, err := wpsSync.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
//                 ThirdCompanyId: "1",
//         })
//         fmt.Printf("res:%v, err:%v", res, err)
//         return
//         // var alluserids []string
//         // for _, u := range users.Data.Items {
//         //         fmt.Printf("FindWpsUser user: %v\n", u)
//         //         if u.ID == "1" {
//         //                 continue
//         //         }
//         //         alluserids = append(alluserids, u.ID)
//         // }
//         // deleteuser := alluserids[:2]
//         // fmt.Printf("deleteuser: %v", deleteuser)
//         // // 存在授权问题
//         // delRes, err := wpsClient.PostBatchDeleteUser(ctx, appAccessToken.AccessToken, wps.PostBatchDeleteUserRequest{
//         //         UserIDs: deleteuser,
//         // })
//         // fmt.Printf("delRes:%v, err:%v", delRes, err)

// }
// func CheckGetCompAllDepts() {
//         appAccessToken, err := auth.NewAppAuthenticator(bc.Service).GetAccessToken(context.Background())
//         if err != nil {
//                 panic(err)
//         }
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())
//         rootDept, err := wpsClient.GetDepartmentRoot(context.Background(), appAccessToken.AccessToken, wps.GetDepartmentRootRequest{})
//         if err != nil {
//                 panic(err)
//         }
//         log.Infof("rootDept: %v", rootDept)

//         allDepts, err := wpsClient.GetDeptChildren(context.Background(), appAccessToken.AccessToken, wps.GetDeptChildrenRequest{
//                 DeptID:    rootDept.Data.ID,
//                 Recursive: true,
//                 PageSize:  50,
//                 WithTotal: true,
//         })
//         if err != nil {
//                 panic(err)
//         }

//         for _, d := range allDepts.Data.Items {
//                 fmt.Printf("CheckGetCompAllDepts dept: %v\n", d)
//         }
// }
// func CheckGetCompAllUsers(token string) {

//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         users, err := wpsClient.GetCompAllUsers(context.Background(), token, wps.GetCompAllUsersRequest{
//                 Recursive: true,
//                 PageSize:  50,
//                 WithTotal: true,
//                 Status:    []string{"active", "notactive", "disabled"},
//         })
//         if err != nil {
//                 panic(err)
//         }
//         for _, u := range users.Data.Items {
//                 fmt.Printf("FindWpsUser user: %+v\n", u)
//         }

// }
// func FindWpsUser(ctx context.Context, userids []string) ([]*dingtalk.DingtalkDeptUser, error) {
//         fmt.Printf("FindWpsUser userids: %v\n", userids)
//         var users []*dingtalk.DingtalkDeptUser

//         appAccessToken, err := auth.NewAppAuthenticator(bc.Service).GetAccessToken(context.Background())
//         if err != nil {
//                 return nil, err
//         }
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         for _, userId := range userids {
//                 wpsUserInfo, err := wpsClient.PostBatchUsersByExDepIds(ctx, appAccessToken.AccessToken, wps.PostBatchUsersByExDepIdsRequest{
//                         ExUserIDs: []string{userId},
//                         Status:    []string{wps.UserStatusActive, wps.UserStatusNoActive, wps.UserStatusDisabled},
//                 })
//                 fmt.Printf("FindWpsUser wpsUserInfo: %v, err: %v\n", wpsUserInfo, err)
//                 if err != nil {
//                         return nil, err
//                 }

//                 if len(wpsUserInfo.Data.Items) == 1 {
//                         fmt.Printf("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;wpsUserInfo: %v\n", wpsUserInfo)
//                         wpsUserid := wpsUserInfo.Data.Items[0].ID

//                         wpsDeptInfo, err := wpsClient.GetUserDeptsByUserId(ctx, appAccessToken.AccessToken, wps.GetUserDeptsByUserIdRequest{
//                                 UserID: wpsUserid,
//                         })
//                         if err != nil {
//                                 return nil, err
//                         }
//                         if len(wpsDeptInfo.Data.Items) &gt; 0 {
//                                 for _, item := range wpsDeptInfo.Data.Items {

//                                         //if _, ok := relationsMap[wpsUserid+item.ID]; !ok {
//                                         user := &amp;dingtalk.DingtalkDeptUser{
//                                                 Userid: userId,
//                                         }
//                                         deptId, err := strconv.ParseInt(item.ExDeptID, 10, 64)
//                                         if err != nil {
//                                                 return nil, err
//                                         }
//                                         user.DeptIDList = append(user.DeptIDList, deptId)
//                                         users = append(users, user)
//                                         //}
//                                 }
//                         }

//                 }
//         }
//         return users, nil
// }

// func CheckGetDingtalkUserDetail() {
//         confService := bc.GetService()
//         auth := auth.NewDingtalkCacheAuthenticator(auth.NewDingTalkAuthenticator(confService))
//         dingtalkRepo := dingtalk.NewDingTalkRepo(confService.Auth.Dingtalk, auth, log.GetLogger())
//         ctx := context.Background()
//         // accessToken, err := dingtalkRepo.GetAccessToken(ctx, "code")
//         // log.Infof("UserAddOrg.GetAccessToken accessToken: %v, err: %v", accessToken, err)
//         // if err != nil {
//         //         panic(err)
//         // }
//         accessToken := "2a99752c4fd9317f81d4a20c0f1d7c7e"
//         //user, err := dingtalkRepo.FetchUserDetail(ctx, accessToken, []string{"03301410433273270"})

//         depts, _ := dingtalkRepo.FetchDeptDetails(ctx, accessToken, []int64{1002216804})
//         fmt.Println()
//         for i, dept := range depts {
//                 fmt.Printf("部门 %d: %+v\n", i, *dept)
//         }
// }
// func CheckReadExcell() {
//         f, err := excelize.OpenFile("Book1.xlsx")
//         if err != nil {
//                 fmt.Println(err)
//                 return
//         }
//         defer func() {
//                 // Close the spreadsheet.
//                 if err := f.Close(); err != nil {
//                         fmt.Println(err)
//                 }
//         }()
//         // Get value from cell by given worksheet name and cell reference.
//         cell, err := f.GetCellValue("Sheet1", "B2")
//         if err != nil {
//                 fmt.Println(err)
//                 return
//         }
//         fmt.Println(cell)
//         // Get all the rows in the Sheet1.
//         rows, err := f.GetRows("Sheet1")
//         if err != nil {
//                 fmt.Println(err)
//                 return
//         }
//         for _, row := range rows {
//                 for _, colCell := range row {
//                         fmt.Print(colCell, "\t")
//                 }
//                 fmt.Println()
//         }
// }
// func CheckGetUserByUserId(token string) {
//         ctx := context.Background()
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         // 调用 Wps 接口
//         res, err := wpsClient.GetUserByUserId(ctx, token, wps.GetUserByUserIdRequest{
//                 UserID: "81",
//         })

//         fmt.Printf("CheckGetUserByUserId res: %+v, err:%+v\n", res, err)
// }
// func CheckUserLeaveOrg() {

//         ctx := context.Background()
//         nancalDB, _ := data.NewMysqlDB(bc.Data, log.GetLogger())

//         syncDB, _ := data.NewMysqlSyncDB(bc.Data, log.GetLogger())

//         client, _ := data.NewRedisClient(bc.Data, log.GetLogger())

//         dataData, _, err := data.NewData(syncDB, nancalDB, client, log.GetLogger())
//         if err != nil {
//                 panic(err)
//         }
//         confService := bc.GetService()
//         accounterRepo := data.NewAccounterRepo(confService, dataData, log.GetLogger())
//         authDingtalk := auth.NewDingtalkCacheAuthenticator(auth.NewDingTalkAuthenticator(confService))
//         dingtalkDingtalk := dingtalk.NewDingTalkRepo(service_Auth_Dingtalk, authDingtalk, log.GetLogger())
//         authenticator := auth.NewAppAuthenticator(confService)
//         wpsSync := wps.NewWpsSync(confService, log.GetLogger())
//         wpsWps := wps.NewWps(confService, log.GetLogger())
//         service_Business := conf.ProvideBusinessConfig(confService)
//         accounterIncreUsecase := biz.NewAccounterIncreUsecase(accounterRepo, dingtalkDingtalk, authenticator, wpsSync, wpsWps, service_Business, log.GetLogger())

//         // deptId
//         // org_dept_create
//         // org_dept_modify
//         // org_dept_remove
//         // userId
//         // user_add_org
//         // user_modify_org
//         // user_leave_org
//         // map[string]interface{"userId": []string{"033014104332101118010"}
//         event := &amp;clientV2.GenericOpenDingTalkEvent{
//                 EventId:           "111",
//                 EventBornTime:     "111",
//                 EventCorpId:       "111",
//                 EventType:         "user_leave_org",
//                 EventUnifiedAppId: "111",
//                 Data:              make(map[string]interface{}, 0),
//         }
//         event.Data["userId"] = []string{"033014104332101118010"}

//         err = accounterIncreUsecase.UserLeaveOrg(ctx, event)

//         fmt.Printf("err:%+v", err)
// }
// func CheckUserAddOrg(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) {

// }

// func GetToken() string {
//         // fmt.Printf("bc.Service: %v", bc.Service)
//         token, err := auth.NewAppAuthenticator(bc.Service).GetAccessToken(context.Background())

//         if err != nil {
//                 panic(err)
//         }

//         //fmt.Printf("token: %+v\n", token)
//         return token.AccessToken
// }
// func CheckBatchPostUsers(token string) {
//         ctx := context.Background()
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         // 调用 Wps 接口
//         res, err := wpsClient.BatchPostUsers(ctx, token, wps.BatchPostUsersRequest{
//                 UserIDs:  []string{"81", "2"},
//                 Status:   []string{wps.UserStatusActive, wps.UserStatusNoActive, wps.UserStatusDisabled},
//                 WithDept: true,
//         })

//         fmt.Printf("CheckBatchPostUsers res: %+v, err:%+v\n", res, err)
// }
// func CheckPostBatchUsersByExDepIds(token string) {
//         ctx := context.Background()
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         // 调用 Wps 接口
//         res, err := wpsClient.PostBatchUsersByExDepIds(ctx, token, wps.PostBatchUsersByExDepIdsRequest{
//                 ExUserIDs: []string{"033014104332101118010", "18910953345"},
//                 Status:    []string{wps.UserStatusActive, wps.UserStatusNoActive, wps.UserStatusDisabled},
//         })

//         fmt.Printf("CheckPostBatchUsersByExDepIds res: %+v, err:%+v\n", res, err)
// }

// func CheckPostBatchDepartmentsByExDepIds(token string) {
//         ctx := context.Background()
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         // 调用 Wps 接口
//         res, err := wpsClient.PostBatchDepartmentsByExDepIds(ctx, token, wps.PostBatchDepartmentsByExDepIdsRequest{
//                 ExDeptIDs: []string{"1002216804"},
//         })

//         fmt.Printf("CheckPostBatchDepartmentsByExDepIds res: %+v, err:%+v\n", res, err)
// }
// func CheckGetDepartmentRoot(token string) {
//         ctx := context.Background()
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         // 调用 Wps 接口
//         res, err := wpsClient.GetDepartmentRoot(ctx, token, wps.GetDepartmentRootRequest{})

//         fmt.Printf("CheckGetDepartmentRoot res: %+v, err:%+v\n", res, err)

// }
// func CheckBatchGetDepartment(token string) {
//         ctx := context.Background()
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         // 调用 Wps 接口
//         res, err := wpsClient.BatchPostDepartments(ctx, token, wps.BatchPostDepartmentsRequest{
//                 DeptIDs: []string{"201", "1", "33"},
//         })
//         fmt.Printf("CheckBatchGetDepartment res: %+v, err:%+v\n", res, err)

// }
// func CheckPostEcisaccountsync(token string) {
//         ctx := context.Background()
//         wpsSync := wps.NewWpsSync(bc.Service, log.GetLogger())
//         res, err := wpsSync.PostEcisaccountsyncIncrement(ctx, token, &amp;wps.EcisaccountsyncIncrementRequest{
//                 ThirdCompanyId: "1",
//         })

//         fmt.Printf("PostEcisaccountsyncIncrement res: %+v, err:%+v\n", res, err)
//         res1, err := wpsSync.PostEcisaccountsyncAll(ctx, token, &amp;wps.EcisaccountsyncAllRequest{
//                 ThirdCompanyId: "1",
//                 TaskId:         time.Now().Add(time.Duration(1) * time.Second).Format("20060102150405"),
//         })

//         fmt.Printf("PostEcisaccountsyncAll res: %+v, err:%+v\n", res1, err)
// }
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "os"

        "nancalacc/internal/conf"
        "nancalacc/internal/service"
        "nancalacc/internal/task"

        "github.com/go-kratos/kratos/v2"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/go-kratos/kratos/v2/transport/grpc"
        "github.com/go-kratos/kratos/v2/transport/http"

        _ "go.uber.org/automaxprocs"
)

// go build -ldflags "-X main.Version=x.y.z"
var (
        // Name is the name of the compiled software.
        Name string
        // Version is the version of the compiled software.
        Version string

        Env string
        // flagconf is the config flag.
        flagconf string

        id, _ = os.Hostname()
)

func init() <span class="cov0" title="0">{
        flag.StringVar(&amp;flagconf, "conf", "../../configs", "config path, eg: -conf config.yaml")
}</span>

func newApp(logger log.Logger, gs *grpc.Server, hs *http.Server, cronService *task.CronService, eventService *service.DingTalkEventService) *kratos.App <span class="cov0" title="0">{

        return kratos.New(
                kratos.ID(id),
                kratos.Name(Name),
                kratos.Version(Version),
                kratos.Metadata(map[string]string{}),
                kratos.Logger(logger),
                kratos.Server(
                        gs,
                        hs,
                ),
                kratos.BeforeStart(func(ctx context.Context) error </span><span class="cov0" title="0">{
                        cronService.Start()
                        return nil
                }</span>),
                kratos.AfterStop(func(ctx context.Context) error <span class="cov0" title="0">{
                        cronService.Stop()
                        return nil
                }</span>),
                kratos.BeforeStart(func(ctx context.Context) error <span class="cov0" title="0">{
                        eventService.Start()
                        return nil
                }</span>),
                kratos.AfterStop(func(ctx context.Context) error <span class="cov0" title="0">{
                        eventService.Stop()
                        return nil
                }</span>),
        )
}

func main() <span class="cov0" title="0">{
        flag.Parse()
        var bc *conf.Bootstrap
        bc, err := conf.Load(flagconf)

        if err != nil </span><span class="cov0" title="0">{
                panic("failed to load config: " + err.Error())</span>
        }
        //serverJson, _ := json.Marshal(bc.Server)
        //fmt.Printf("key: %s\n, value: %s\n", "/configs/nancalacc/server.json", string(serverJson))
        //cfg.Watch(configSource, bc)

        <span class="cov0" title="0">stdLogger := log.NewStdLogger(os.Stdout)

        //fmt.Println(bc.App.GetLogLevel())
        // 创建级别过滤器
        //_ = log.NewFilter(stdLogger, log.FilterLevel(log.LevelDebug), log.FilterLevel(log.LevelError), log.FilterLevel(log.LevelFatal))

        //id := bc.App.GetId()
        //Name := bc.App.GetName()
        //Version := bc.App.GetVersion()
        Env := bc.App.GetEnv()

        fmt.Println(Env)

        logger := log.With(stdLogger,
                //"ts", log.DefaultTimestamp,
                "caller", log.DefaultCaller,
                //"service.id", id,
                //"service.name", Name,
                //"service.version", Version,
                //"trace.id", tracing.TraceID(),
                //"span.id", tracing.SpanID(),
        )

        app, cleanup, err := wireApp(bc.Server, bc.App, bc.Data, bc.Auth, logger)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer cleanup()

        //app.Use(middleware.LogMiddleware(log.LevelError))

        // ttc := tracer.NewTracerManager()
        // ttc.Init(Env, Name)
        // defer ttc.Shutdown()

        // start and wait for stop signal
        if err := app.Run(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
        "github.com/go-kratos/kratos/v2"
        "github.com/go-kratos/kratos/v2/log"
        "nancalacc/internal/biz"
        "nancalacc/internal/conf"
        "nancalacc/internal/data"
        "nancalacc/internal/dingtalk"
        "nancalacc/internal/server"
        "nancalacc/internal/service"
        "nancalacc/internal/task"
        "nancalacc/internal/wps"
)

import (
        _ "go.uber.org/automaxprocs"
)

// Injectors from wire.go:

// wireApp init kratos application.
func wireApp(confServer *conf.Server, app *conf.App, confData *conf.Data, auth *conf.Auth, logger log.Logger) (*kratos.App, func(), error) <span class="cov0" title="0">{
        syncDB, err := data.NewMysqlSyncDB(confData, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">mainDB, err := data.NewMysqlDB(confData, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">client, err := data.NewRedisClient(confData, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">dataData, cleanup, err := data.NewData(syncDB, mainDB, client, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">accounterRepo := data.NewAccounterRepo(dataData, logger)
        dingtalkDingtalk := dingtalk.NewDingTalkRepo(logger)
        wpsWps := wps.NewWps(logger)
        cacheService := data.NewLocalCacheService(logger)
        accounterUsecase := biz.NewAccounterUsecase(accounterRepo, dingtalkDingtalk, wpsWps, cacheService, logger)
        oauth2Usecase := biz.NewOauth2Usecase(dingtalkDingtalk, logger)
        fullSyncUsecase := biz.NewFullSyncUsecase(accounterRepo, dingtalkDingtalk, wpsWps, cacheService, logger)
        accountService := service.NewAccountService(accounterUsecase, oauth2Usecase, fullSyncUsecase, logger)
        grpcServer := server.NewGRPCServer(confServer, accountService, logger)
        httpServer := server.NewHTTPServer(confServer, accountService, logger)
        cronService := task.NewCronServiceWithJobs(accounterUsecase, logger)
        incrementalSyncUsecase := biz.NewIncrementalSyncUsecase(accounterRepo, dingtalkDingtalk, wpsWps, logger)
        dingTalkEventService := service.NewDingTalkEventService(incrementalSyncUsecase, logger)
        kratosApp := newApp(logger, grpcServer, httpServer, cronService, dingTalkEventService)
        return kratosApp, func() </span><span class="cov0" title="0">{
                cleanup()
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

func main() {<span class="cov0" title="0">}</span>

// type KsoSign struct {
//         accessKey string
//         secretKey string
// }

// type Out struct {
//         Date          string // X-Kso-Date
//         Authorization string // X-Kso-Authorization
// }

// func NewKsoSign(accessKey, secretKey string) (*KsoSign, error) {
//         if accessKey == "" || secretKey == "" {
//                 return nil, errors.New("NewKsoSign error: AccessKey/SecretKey can not be empty")
//         }
//         return &amp;KsoSign{
//                 accessKey: accessKey,
//                 secretKey: secretKey,
//         }, nil
// }

// func (k *KsoSign) getKso1Signature(secretKey, method, uri, ksoDate, contentType string, requestBody []byte) string {
//         sha256Hex := ""
//         if len(requestBody) &gt; 0 {
//                 s := sha256.New()
//                 s.Write(requestBody)
//                 sha256Hex = hex.EncodeToString(s.Sum(nil))
//         }

//         mac := hmac.New(sha256.New, []byte(secretKey))
//         mac.Write([]byte("KSO-1" + method + uri + contentType + ksoDate + sha256Hex))
//         return hex.EncodeToString(mac.Sum(nil))
// }

// func (k *KsoSign) KSO1Sign(method, uri, contentType, ksoDate string, body []byte) (*Out, error) {

//         fmt.Println()
//         fmt.Println("KSO1Sign start:")
//         fmt.Printf("accessKey: %s\n", k.accessKey)
//         fmt.Printf("secretKey: %s\n", k.secretKey)
//         fmt.Printf("method: %s\n", method)
//         fmt.Printf("signPath: %s\n", uri)
//         fmt.Printf("contentType: %s\n", contentType)
//         fmt.Printf("ksoDate: %s\n", ksoDate)
//         fmt.Printf("body: %s\n", string(body))
//         fmt.Println("KSO1Sign end:")
//         fmt.Println()

//         ksoSignature := k.getKso1Signature(k.secretKey, method, uri, ksoDate, contentType, body)
//         authorization := fmt.Sprintf("%s %s:%s", "KSO-1", k.accessKey, ksoSignature)
//         return &amp;Out{
//                 Date:          ksoDate,
//                 Authorization: authorization,
//         }, nil
// }

// func main() {
//         accessKey := "AK123456"
//         secretKey := "sk098765"
//         method := "POST"
//         uri := "/v7/test/body"
//         contentType := "application/json"
//         ksoDate := "Mon, 02 Jan 2006 15:04:05 GMT"
//         body := `{"key":"value"}` // 注意 json 格式，会影响到签名计算

//         sign, err := NewKsoSign(accessKey, secretKey)
//         if err != nil {
//                 panic(err)
//         }

//         out, err := sign.KSO1Sign(method, uri, contentType, ksoDate, []byte(body))
//         if err != nil {
//                 panic(err)
//         }
//         fmt.Printf("out: %v\n", out)
//         // 输出：out: &amp;{Mon, 02 Jan 2006 15:04:05 GMT KSO-1 AK123456:c46e6c988130818ecba2484d51ac685948fbbef6814602c7874d6bfc41dc17b3}
// }
</pre>
		
		<pre class="file" id="file7" style="display: none">package auth

import (
        "time"

        gocache "github.com/patrickmn/go-cache"
)

// Cache 缓存接口
type Cache interface {
        Get(key string) (interface{}, bool)
        Set(key string, value interface{}, ttl time.Duration)
        Delete(key string)
}

// LocalCache 本地缓存实现
type LocalCache struct {
        cache *gocache.Cache
}

// NewLocalCache 创建新的本地缓存实例
func NewLocalCache() Cache <span class="cov0" title="0">{
        // 默认清理间隔为10分钟，默认过期时间为1小时
        return &amp;LocalCache{
                cache: gocache.New(1*time.Hour, 10*time.Minute),
        }
}</span>

func (lc *LocalCache) Get(key string) (interface{}, bool) <span class="cov0" title="0">{
        return lc.cache.Get(key)
}</span>

func (lc *LocalCache) Set(key string, value interface{}, ttl time.Duration) <span class="cov0" title="0">{
        lc.cache.Set(key, value, ttl)
}</span>

func (lc *LocalCache) Delete(key string) <span class="cov0" title="0">{
        lc.cache.Delete(key)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package auth

import (
        "crypto/sha256"
        "fmt"
        "net/http"
        "time"
)

func MakeSECSecret(clientId, clientSecret string, t time.Time) string <span class="cov0" title="0">{
        utc := t.Format(http.TimeFormat)
        return fmt.Sprintf("SEC %x;%s",
                sha256.Sum256([]byte(fmt.Sprintf("%s:%s:%s", clientId, clientSecret, utc))), utc)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package auth

import (
        "context"
        "fmt"
        "nancalacc/internal/conf"
        "time"

        openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
        dingtalkoauth2_1_0 "github.com/alibabacloud-go/dingtalk/oauth2_1_0"
        util "github.com/alibabacloud-go/tea-utils/v2/service"
        "github.com/alibabacloud-go/tea/tea"
)

const (
        DingtalkAuthType = "dingtalk"
)

type DingTalkAuthenticator interface {
        Authenticator
}

type DingTalkAuth struct {
        AppKey    string
        AppSecret string
        Endpoint  string
        //Timeout     string
        dingtalkCli *dingtalkoauth2_1_0.Client
        cache       Cache
}

func NewDingTalkAuthenticator() DingTalkAuthenticator <span class="cov0" title="0">{

        cfg := conf.Get().GetAuth().GetDingtalk()
        config := &amp;openapi.Config{
                Protocol: tea.String("https"),
                RegionId: tea.String("central"),
        }
        client, err := dingtalkoauth2_1_0.NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("NewClient err: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;DingTalkAuth{
                Endpoint:    cfg.Endpoint,
                AppKey:      cfg.AppKey,
                AppSecret:   cfg.AppSecret,
                dingtalkCli: client,
                cache:       NewLocalCache(),
        }</span>
}

func (r *DingTalkAuth) GetAccessToken(ctx context.Context) (*AccessTokenResp, error) <span class="cov0" title="0">{
        // 尝试从缓存获取
        cacheKey := fmt.Sprintf("dingtalk_token_%s", r.AppKey)
        if cached, found := r.cache.Get(cacheKey); found </span><span class="cov0" title="0">{
                if token, ok := cached.(*AccessTokenResp); ok </span><span class="cov0" title="0">{
                        return token, nil
                }</span>
        }

        // 缓存中没有，从API获取
        <span class="cov0" title="0">token, err := r.getAccessTokenFromAPI(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 缓存token，提前5分钟过期
        <span class="cov0" title="0">cacheTTL := time.Duration(token.ExpiresIn-300) * time.Second
        if cacheTTL &gt; 0 </span><span class="cov0" title="0">{
                r.cache.Set(cacheKey, token, cacheTTL)
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}

func (r *DingTalkAuth) getAccessTokenFromAPI(ctx context.Context) (*AccessTokenResp, error) <span class="cov0" title="0">{
        request := &amp;dingtalkoauth2_1_0.GetAccessTokenRequest{
                AppKey:    tea.String(r.AppKey),
                AppSecret: tea.String(r.AppSecret),
        }

        var res *AccessTokenResp
        var accessToken dingtalkoauth2_1_0.GetAccessTokenResponseBody

        tryErr := func() error </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := tea.Recover(recover()); r != nil </span><span class="cov0" title="0">{
                                err := r
                                fmt.Printf("恢复的错误: %v\n", err)
                        }</span>
                }()

                <span class="cov0" title="0">response, err := r.dingtalkCli.GetAccessToken(request)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">accessToken = *response.Body
                return nil</span>
        }()

        <span class="cov0" title="0">if tryErr != nil </span><span class="cov0" title="0">{
                // 处理错误
                var sdkErr = &amp;tea.SDKError{}
                if _t, ok := tryErr.(*tea.SDKError); ok </span><span class="cov0" title="0">{
                        sdkErr = _t
                }</span> else<span class="cov0" title="0"> {
                        sdkErr.Message = tea.String(tryErr.Error())
                }</span>

                <span class="cov0" title="0">if !tea.BoolValue(util.Empty(sdkErr.Code)) &amp;&amp; !tea.BoolValue(util.Empty(sdkErr.Message)) </span><span class="cov0" title="0">{
                        return res, fmt.Errorf("获取access_token失败: [%s] %s", *sdkErr.Code, *sdkErr.Message)
                }</span>
                <span class="cov0" title="0">return res, fmt.Errorf("获取access_token失败: %s", *sdkErr.Message)</span>
        }

        <span class="cov0" title="0">return &amp;AccessTokenResp{
                AccessToken: *accessToken.AccessToken,
                ExpiresIn:   int(*accessToken.ExpireIn),
        }, nil</span>
}

// InvalidateCache 清除缓存
func (r *DingTalkAuth) InvalidateCache() <span class="cov0" title="0">{
        cacheKey := fmt.Sprintf("dingtalk_token_%s", r.AppKey)
        r.cache.Delete(cacheKey)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package auth

import (
        "context"
        "encoding/json"
        "fmt"
        "nancalacc/internal/conf"
        "nancalacc/pkg/httputil"
        stdurl "net/url"
        "strings"
        "time"
)

const (
        AppAuthType = "app"
)

type WpsAppAuthenticator interface {
        Authenticator
}

type WpsAppAuth struct {
        clientId     string
        clientSecret string
        url          string
        cache        Cache
}

const (
        AppAuthPath = "/openapi/oauth2/token"
        grantType   = "client_credentials"
)

func NewWpsAppAuthenticator() WpsAppAuthenticator <span class="cov0" title="0">{
        cfg := conf.Get().GetAuth().GetWpsapp()
        return &amp;WpsAppAuth{
                clientId:     cfg.ClientId,
                clientSecret: cfg.ClientSecret,
                url:          cfg.AuthUrl,
                cache:        NewLocalCache(),
        }
}</span>

func (a *WpsAppAuth) GetAccessToken(ctx context.Context) (*AccessTokenResp, error) <span class="cov0" title="0">{
        // 尝试从缓存获取
        cacheKey := fmt.Sprintf("wps_token_%s", a.clientId)
        if cached, found := a.cache.Get(cacheKey); found </span><span class="cov0" title="0">{
                if token, ok := cached.(*AccessTokenResp); ok </span><span class="cov0" title="0">{
                        return token, nil
                }</span>
        }

        // 缓存中没有，从API获取
        <span class="cov0" title="0">token, err := a.getAccessTokenFromAPI(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 缓存token，提前5分钟过期
        <span class="cov0" title="0">cacheTTL := time.Duration(token.ExpiresIn-300) * time.Second
        if cacheTTL &gt; 0 </span><span class="cov0" title="0">{
                a.cache.Set(cacheKey, token, cacheTTL)
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}

func (a *WpsAppAuth) getAccessTokenFromAPI(ctx context.Context) (*AccessTokenResp, error) <span class="cov0" title="0">{
        clientId := a.clientId
        clientSecret := a.clientSecret
        url := a.url

        _, err := stdurl.Parse(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid URL: %v", err)
        }</span>

        <span class="cov0" title="0">if !strings.Contains(url, "https") &amp;&amp; !strings.Contains(url, "http") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("domain must be https or http")
        }</span>
        <span class="cov0" title="0">if strings.Contains(url, "https") </span><span class="cov0" title="0">{
                clientSecret = MakeSECSecret(clientId, clientSecret, time.Now())
        }</span>

        <span class="cov0" title="0">uri := fmt.Sprintf("%s%s", url, AppAuthPath)

        dataStr := fmt.Sprintf(`grant_type=%s&amp;client_id=%s&amp;client_secret=%s`, grantType, clientId, clientSecret)
        data := []byte(dataStr)
        bs, err := httputil.Post(uri, data, 5*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var resp *AccessTokenResp
        err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

// InvalidateCache 清除缓存
func (a *WpsAppAuth) InvalidateCache() <span class="cov0" title="0">{
        cacheKey := fmt.Sprintf("wps_token_%s", a.clientId)
        a.cache.Delete(cacheKey)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package biz

import (
        "context"
        "errors"
        v1 "nancalacc/api/account/v1"
        "nancalacc/internal/auth"
        "nancalacc/internal/data/models"
        "nancalacc/internal/dingtalk"
        "nancalacc/internal/wps"
        "time"

        //"github.com/go-kratos/kratos/v2/errors"
        "github.com/go-kratos/kratos/v2/log"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// GreeterUsecase is a Greeter usecase.
type AccounterUsecase struct {
        repo         AccounterRepo
        dingTalkRepo dingtalk.Dingtalk
        appAuth      auth.Authenticator
        wps          wps.Wps
        localCache   CacheService
        log          *log.Helper
}

var (
        prefix = "nancalacc:cache:"
)

// NewGreeterUsecase new a Greeter usecase.
func NewAccounterUsecase(repo AccounterRepo, dingTalkRepo dingtalk.Dingtalk, wps wps.Wps, cache CacheService, logger log.Logger) *AccounterUsecase <span class="cov0" title="0">{
        appAuth := auth.NewWpsAppAuthenticator()
        return &amp;AccounterUsecase{repo: repo, dingTalkRepo: dingTalkRepo, appAuth: appAuth, wps: wps, localCache: cache, log: log.NewHelper(logger)}
}</span>

func (uc *AccounterUsecase) CreateTask(ctx context.Context, taskName string) (int, error) <span class="cov0" title="0">{
        uc.log.WithContext(ctx).Infof("CreateTask taskName: %s", taskName)
        return uc.repo.CreateTask(ctx, taskName)

}</span>
func (uc *AccounterUsecase) GetTask(ctx context.Context, taskName string) (*v1.GetTaskReply_Task, error) <span class="cov0" title="0">{
        uc.log.WithContext(ctx).Infof("GetTask taskName: %s", taskName)

        taskInfo, err := uc.GetCacheTask(ctx, taskName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;v1.GetTaskReply_Task{
                Name:          taskInfo.Title,
                Status:        taskInfo.Status,
                CreateTime:    timestamppb.New(taskInfo.CreatedAt),
                StartTime:     timestamppb.New(taskInfo.StartDate),
                CompletedTime: timestamppb.New(taskInfo.CompletedAt),
                ActurlTime:    int32(taskInfo.ActualTime),
        }, nil</span>

}
func (uc *AccounterUsecase) UpdateTask(ctx context.Context, taskName, status string) error <span class="cov0" title="0">{
        uc.log.WithContext(ctx).Infof("UpdateTask taskId: %s, status %s", taskName, status)
        return uc.repo.UpdateTask(ctx, taskName, status)

}</span>

func (uc *AccounterUsecase) CreateCacheTask(ctx context.Context, taskName, status string) error <span class="cov0" title="0">{

        cacheKey := prefix + taskName
        task := &amp;models.Task{
                Title:         taskName,
                Description:   taskName,
                CreatedAt:     time.Now(),
                Status:        models.TaskStatusInProgress,
                Progress:      0,
                StartDate:     time.Now(),
                DueDate:       time.Now().Add(time.Minute * 30),
                CompletedAt:   time.Now(),
                CreatorID:     99,
                EstimatedTime: 10,
                ActualTime:    0,
        }
        return uc.localCache.Set(ctx, cacheKey, task, 300*time.Minute)
}</span>
func (uc *AccounterUsecase) UpdateCacheTask(ctx context.Context, taskName, status string) error <span class="cov0" title="0">{

        cacheKey := prefix + taskName
        oldTask, ok, err := uc.localCache.Get(ctx, cacheKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var task *models.Task
        var startDate time.Time
        now := time.Now()
        if ok </span><span class="cov0" title="0">{
                task, ok1 := oldTask.(*models.Task)
                if ok1 </span><span class="cov0" title="0">{
                        startDate = task.StartDate
                        task.ActualTime = int(now.Sub(startDate).Seconds()) + 20
                        task.Status = status
                        task.Progress = 100
                        task.CompletedAt = now
                        task.UpdatedAt = now
                }</span>
        }

        <span class="cov0" title="0">if task == nil </span><span class="cov0" title="0">{
                task = &amp;models.Task{
                        Title:         taskName,
                        Description:   taskName,
                        Status:        status,
                        Progress:      100,
                        StartDate:     time.Now(),
                        DueDate:       time.Now().Add(time.Minute * 30),
                        CompletedAt:   time.Now(),
                        CreatorID:     99,
                        EstimatedTime: 10,
                        ActualTime:    0,
                }
        }</span>
        <span class="cov0" title="0">return uc.localCache.Set(ctx, cacheKey, task, 300*time.Minute)</span>
}

func (uc *AccounterUsecase) GetCacheTask(ctx context.Context, taskName string) (*models.Task, error) <span class="cov0" title="0">{

        cacheKey := prefix + taskName
        var task *models.Task
        taskInfo, ok, err := uc.localCache.Get(ctx, cacheKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("notfound")
        }</span>
        <span class="cov0" title="0">task, ok1 := taskInfo.(*models.Task)
        if !ok1 </span><span class="cov0" title="0">{
                return nil, errors.New("type error")
        }</span>
        <span class="cov0" title="0">return task, nil</span>

}
</pre>
		
		<pre class="file" id="file12" style="display: none">package biz

import (
        "context"
        "fmt"
        v1 "nancalacc/api/account/v1"
        "nancalacc/internal/auth"
        "nancalacc/internal/conf"
        "nancalacc/internal/data/models"
        "nancalacc/internal/dingtalk"
        "nancalacc/internal/wps"
        "strconv"
        "time"

        //"github.com/go-kratos/kratos/v2/errors"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/xuri/excelize/v2"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// GreeterUsecase is a Greeter usecase.
type FullSyncUsecase struct {
        repo         AccounterRepo
        dingTalkRepo dingtalk.Dingtalk
        appAuth      auth.Authenticator
        wps          wps.Wps
        localCache   CacheService
        log          *log.Helper
}

// NewGreeterUsecase new a Greeter usecase.
func NewFullSyncUsecase(repo AccounterRepo, dingTalkRepo dingtalk.Dingtalk, wps wps.Wps, cache CacheService, logger log.Logger) *FullSyncUsecase <span class="cov0" title="0">{
        appAuth := auth.NewWpsAppAuthenticator()
        return &amp;FullSyncUsecase{repo: repo, dingTalkRepo: dingTalkRepo, appAuth: appAuth, wps: wps, localCache: cache, log: log.NewHelper(logger)}
}</span>

func (uc *FullSyncUsecase) CreateSyncAccount(ctx context.Context, req *v1.CreateSyncAccountRequest) (*v1.CreateSyncAccountReply, error) <span class="cov0" title="0">{
        // return &amp;v1.CreateSyncAccountReply{
        //         TaskId:     "taskId",
        //         CreateTime: timestamppb.Now(),
        // }, nil
        log := uc.log.WithContext(ctx)
        log.Infof("CreateSyncAccount: %v", req)

        taskId := req.GetTaskName()

        taskCachekey := prefix + taskId

        _, ok, err := uc.localCache.Get(ctx, taskCachekey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                return nil, status.Error(codes.AlreadyExists, "task name "+taskId+" exists")
        }</span>
        // num, err := uc.repo.CreateTask(ctx, taskId)
        // if err != nil {
        //         return nil, err
        // }
        // if num == 0 {
        //         return nil, status.Error(codes.AlreadyExists, "taskId  exists")
        // }

        <span class="cov0" title="0">uc.log.WithContext(ctx).Info("CreateSyncAccount.SaveCompanyCfg")
        err = uc.repo.SaveCompanyCfg(ctx, &amp;dingtalk.DingtalkCompanyCfg{})
        log.Infof("CreateSyncAccount.SaveCompanyCfg: err: %v", err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 1. 获取access_token
        <span class="cov0" title="0">dingTalkAccessToken, err := uc.dingTalkRepo.GetAccessToken(ctx)
        uc.log.WithContext(ctx).Infof("CreateSyncAccount dingTalkAccessToken: %+v, err: %v", dingTalkAccessToken, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">accessToken := dingTalkAccessToken.AccessToken

        // 1. 从第三方获取部门和用户数据

        log.Infof("CreateSyncAccount FetchDepartments")

        depts, err := uc.dingTalkRepo.FetchDepartments(ctx, accessToken)
        log.Infof("CreateSyncAccount FetchDepartments depts: %+v, err: %v", depts, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Infof("CreateSyncAccount depts size: %d, taskId: %v", len(depts), taskId)

        for _, dept := range depts </span><span class="cov0" title="0">{
                uc.log.WithContext(ctx).Infof("CreateSyncAccount dept: %+v", dept)
        }</span>

        // 2. 数据入库
        <span class="cov0" title="0">deptCount, err := uc.repo.SaveDepartments(ctx, depts, taskId)
        log.Infof("CreateSyncAccount SaveDepartments deptCount: %d, err: %v", deptCount, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var deptIds []int64
        for _, dept := range depts </span><span class="cov0" title="0">{
                deptIds = append(deptIds, dept.DeptID)
        }</span>

        <span class="cov0" title="0">log.Infof("CreateSyncAccount FetchDepartmentUsers accessToken: %s deptIds: %v", accessToken, deptIds)
        // 1. 从第三方获取用户数据
        deptUsers, err := uc.dingTalkRepo.FetchDepartmentUsers(ctx, accessToken, deptIds)

        log.Infof("CreateSyncAccount FetchDepartmentUsers deptUsers size: %v, err: %v", len(deptUsers), err)
        for _, deptUser := range deptUsers </span><span class="cov0" title="0">{
                uc.log.WithContext(ctx).Infof("biz.CreateSyncAccount deptUser: %+v", deptUser)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 2. 数据入库
        //这里可以 将deptUsers转为model.TbLasUser,
        // SaveUsers(ctx, TbLasUser)
        <span class="cov0" title="0">userCount, err := uc.repo.SaveUsers(ctx, deptUsers, taskId)
        log.Infof("CreateSyncAccount SaveUsers userCount: %d, err: %v", userCount, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 2. 关系数据入库
        <span class="cov0" title="0">var deptUserRelations []*dingtalk.DingtalkDeptUserRelation
        for _, deptUser := range deptUsers </span><span class="cov0" title="0">{
                order := make(map[int64]int64, 0)
                if len(deptUser.DeptOrderList) &gt; 0 </span><span class="cov0" title="0">{
                        for _, depIdOrder := range deptUser.DeptOrderList </span><span class="cov0" title="0">{
                                order[depIdOrder.DeptID] = depIdOrder.DeptID
                        }</span>
                }
                <span class="cov0" title="0">for _, depId := range deptUser.DeptIDList </span><span class="cov0" title="0">{

                        reliation := &amp;dingtalk.DingtalkDeptUserRelation{
                                Uid: deptUser.Userid,
                                Did: strconv.FormatInt(depId, 10),
                        }
                        if order, ok := order[depId]; ok </span><span class="cov0" title="0">{
                                reliation.Order = order
                        }</span>
                        <span class="cov0" title="0">deptUserRelations = append(deptUserRelations, reliation)</span>
                }

        }
        <span class="cov0" title="0">log.Infof("CreateSyncAccount deptUserRelations size: %d, taskId: %s", len(deptUserRelations), taskId)

        for _, deptUserRelation := range deptUserRelations </span><span class="cov0" title="0">{
                uc.log.WithContext(ctx).Infof("CreateSyncAccount deptUserRelation: %+v", deptUserRelation)
        }</span>

        // 3. 数据入库
        <span class="cov0" title="0">relationCount, err := uc.repo.SaveDepartmentUserRelations(ctx, deptUserRelations, taskId)
        uc.log.WithContext(ctx).Infof("CreateSyncAccount relationCount: %d, err: %v", relationCount, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Infof("CreateSyncAccount CallEcisaccountsyncAll taskId: %v", taskId)

        appAccessToken, err := uc.appAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Infof("appAccessToken", appAccessToken)

        res, err := uc.wps.PostEcisaccountsyncAll(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncAllRequest{
                TaskId:         taskId,
                ThirdCompanyId: conf.Get().GetApp().GetThirdCompanyId(),
        })
        log.Infof("CreateSyncAccount CallEcisaccountsyncAll res: %v, err: %v", res, err)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">taskInfo := &amp;models.Task{
                ID:          1,
                Title:       req.GetTaskName(),
                Description: req.GetTaskName(),
                Status:      "in_progress",
                CreatorID:   1,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
                DueDate:     time.Now(),
                StartDate:   time.Now(),
                Progress:    30,
                ActualTime:  0,
        }
        uc.localCache.Set(ctx, taskCachekey, taskInfo, 300*time.Minute)
        return &amp;v1.CreateSyncAccountReply{
                TaskId:     taskId,
                CreateTime: timestamppb.Now(),
        }, nil</span>
}

func (uc *FullSyncUsecase) GetSyncAccount(ctx context.Context, req *v1.GetSyncAccountRequest) (*v1.GetSyncAccountReply, error) <span class="cov0" title="0">{
        uc.log.WithContext(ctx).Infof("GetSyncAccount: %v", req)

        taskId := req.GetTaskId()

        taskCachekey := prefix + taskId

        taskCacheInfo, ok, err := uc.localCache.Get(ctx, taskCachekey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                taskInfo, ok1 := taskCacheInfo.(*models.Task)
                if ok1 </span><span class="cov0" title="0">{
                        return &amp;v1.GetSyncAccountReply{
                                Status:                      v1.GetSyncAccountReply_Status(taskInfo.Progress),
                                UserCount:                   1,
                                DepartmentCount:             1,
                                UserDepartmentRelationCount: 1,
                        }, nil
                }</span>

        }
        <span class="cov0" title="0">return nil, status.Error(codes.NotFound, "task "+taskId+" not found")</span>
}

func (uc *FullSyncUsecase) ParseExecell(ctx context.Context, taskId, filename string) (err error) <span class="cov0" title="0">{

        // defer func() {
        //         if err != nil {
        //                 uc.UpdateCacheTask(ctx, taskId, models.TaskStatusCancelled)
        //         } else {
        //                 uc.UpdateCacheTask(ctx, taskId, models.TaskStatusCompleted)
        //         }
        // }()
        log := uc.log.WithContext(ctx)
        log.Infof("ParseExecell taskId: %s,filename:%s", taskId, filename)

        f, err := excelize.OpenFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        }()

        <span class="cov0" title="0">processSheet := map[string]bool{
                "user":            true,
                "department":      true,
                "department_user": true,
        }
        sheets := f.GetSheetList()
        for _, sheet := range sheets </span><span class="cov0" title="0">{
                if _, ok := processSheet[sheet]; !ok </span><span class="cov0" title="0">{
                        fmt.Printf("sheetname: %s\n", sheet)
                        continue</span>
                }
                <span class="cov0" title="0">rows, err := f.Rows(sheet)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("err: %w", err)
                }</span>
                <span class="cov0" title="0">defer rows.Close()
                rows.Next()
                switch sheet </span>{
                case "user":<span class="cov0" title="0">
                        uc.transUser(ctx, taskId, rows)</span>
                case "department":<span class="cov0" title="0">
                        uc.transDept(ctx, taskId, rows)</span>
                case "department_user":<span class="cov0" title="0">
                        uc.transUserDept(ctx, taskId, rows)</span>
                default:<span class="cov0" title="0">
                        log.Infof("not found sheetname: %s\n", sheet)</span>
                }

        }
        // err = uc.repo.UpdateTask(ctx, taskId, models.TaskStatusCompleted)
        // if err != nil {
        //         return err
        // }
        <span class="cov0" title="0">appAccessToken, err := uc.appAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = uc.wps.PostEcisaccountsyncAll(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncAllRequest{
                TaskId:         taskId,
                ThirdCompanyId: conf.Get().GetApp().GetThirdCompanyId(),
        })
        return err</span>
}

func (uc *FullSyncUsecase) transUser(ctx context.Context, taskId string, rows *excelize.Rows) (err error) <span class="cov0" title="0">{

        log := uc.log.WithContext(ctx)
        log.Infof("transUser taskId: %s", taskId)

        //uc.repo.UpdateTask(ctx, taskId, models.TaskStatusInProgress)
        thirdCompanyId := conf.Get().GetApp().GetThirdCompanyId()
        platformIds := conf.Get().GetApp().GetPlatformIds()
        users := make([]*models.TbLasUser, 0, 100)
        now := time.Now()
        for rows.Next() </span><span class="cov0" title="0">{
                row, err := rows.Columns()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("err: %w", err)
                }</span>
                <span class="cov0" title="0">log.Info(row)
                if len(row) &lt; 3 </span><span class="cov0" title="0">{
                        log.Warnf("row len &lt; 3: %v", row)
                        continue</span>
                }

                <span class="cov0" title="0">users = append(users, &amp;models.TbLasUser{
                        TaskID:           taskId,
                        ThirdCompanyID:   thirdCompanyId,
                        PlatformID:       platformIds,
                        Uid:              row[0],
                        Account:          row[1],
                        NickName:         row[2],
                        EmploymentStatus: "active",
                        Source:           "sync",
                        Ctime:            now,
                        Mtime:            now,
                        CheckType:        1,
                })
                if len(users) &gt;= 100 </span><span class="cov0" title="0">{
                        if _, err := uc.repo.BatchSaveUsers(ctx, users); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">users = users[:0]</span> // 清空切片（保留底层数组，避免重新分配）
                }
                // num := SheetDataToModel(sheet, row)
        }
        <span class="cov0" title="0">if len(users) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := uc.repo.BatchSaveUsers(ctx, users); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := rows.Error(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (uc *FullSyncUsecase) transDept(ctx context.Context, taskId string, rows *excelize.Rows) (err error) <span class="cov0" title="0">{
        log := uc.log.WithContext(ctx)
        log.Infof("transDept taskId: %s", taskId)

        //uc.repo.UpdateTask(ctx, taskId, models.TaskStatusInProgress)
        thirdCompanyId := conf.Get().GetApp().GetThirdCompanyId()
        platformIds := conf.Get().GetApp().GetPlatformIds()
        depts := make([]*models.TbLasDepartment, 0, 100)
        now := time.Now()
        for rows.Next() </span><span class="cov0" title="0">{
                row, err := rows.Columns()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("err: %w", err)
                }</span>

                <span class="cov0" title="0">log.Info(row)
                if len(row) &lt; 3 </span><span class="cov0" title="0">{
                        log.Warnf("row len &lt; 3: %v", row)
                        continue</span>
                }

                //log.Info(row)

                <span class="cov0" title="0">depts = append(depts, &amp;models.TbLasDepartment{
                        TaskID:         taskId,
                        ThirdCompanyID: thirdCompanyId,
                        PlatformID:     platformIds,
                        Did:            row[0],
                        Pid:            row[1],
                        Name:           row[2],
                        // Order:          row[3],
                        Source:    "sync",
                        Ctime:     now,
                        Mtime:     now,
                        CheckType: 1,
                })
                if len(depts) &gt;= 100 </span><span class="cov0" title="0">{
                        if _, err := uc.repo.BatchSaveDepts(ctx, depts); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">depts = depts[:0]</span> // 清空切片
                }
        }
        <span class="cov0" title="0">if len(depts) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := uc.repo.BatchSaveDepts(ctx, depts); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := rows.Error(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (uc *FullSyncUsecase) transUserDept(ctx context.Context, taskId string, rows *excelize.Rows) (err error) <span class="cov0" title="0">{
        log := uc.log.WithContext(ctx)
        log.Infof("transUserDept taskId: %s", taskId)

        //uc.repo.UpdateTask(ctx, taskId, models.TaskStatusInProgress)
        thirdCompanyId := conf.Get().GetApp().GetThirdCompanyId()
        platformIds := conf.Get().GetApp().GetPlatformIds()
        deptusers := make([]*models.TbLasDepartmentUser, 0, 100)
        now := time.Now()
        for rows.Next() </span><span class="cov0" title="0">{
                row, err := rows.Columns()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("err: %w", err)
                }</span>
                <span class="cov0" title="0">log.Info(row)
                if len(row) &lt; 2 </span><span class="cov0" title="0">{
                        log.Warnf("row len &lt; 2: %v", row)
                        continue</span>
                }

                <span class="cov0" title="0">deptusers = append(deptusers, &amp;models.TbLasDepartmentUser{
                        TaskID:         taskId,
                        ThirdCompanyID: thirdCompanyId,
                        PlatformID:     platformIds,
                        Uid:            row[0],
                        Did:            row[1],
                        Ctime:          now,
                        CheckType:      1,
                })
                if len(deptusers) &gt;= 100 </span><span class="cov0" title="0">{
                        if _, err := uc.repo.BatchSaveDeptUsers(ctx, deptusers); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">deptusers = deptusers[:0]</span> // 清空切片（保留底层数组，避免重新分配）
                }
        }
        <span class="cov0" title="0">if len(deptusers) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := uc.repo.BatchSaveDeptUsers(ctx, deptusers); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := rows.Error(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// func (uc *AccounterUsecase) CreateCacheTask(ctx context.Context, taskName, status string) error {

//         cacheKey := prefix + taskName
//         task := &amp;models.Task{
//                 Title:         taskName,
//                 Description:   taskName,
//                 CreatedAt:     time.Now(),
//                 Status:        models.TaskStatusInProgress,
//                 Progress:      0,
//                 StartDate:     time.Now(),
//                 DueDate:       time.Now().Add(time.Minute * 30),
//                 CompletedAt:   time.Now(),
//                 CreatorID:     99,
//                 EstimatedTime: 10,
//                 ActualTime:    0,
//         }
//         return uc.localCache.Set(ctx, cacheKey, task, 300*time.Minute)
// }
// func (uc *AccounterUsecase) UpdateCacheTask(ctx context.Context, taskName, status string) error {

//         cacheKey := prefix + taskName
//         oldTask, ok, err := uc.localCache.Get(ctx, cacheKey)
//         if err != nil {
//                 return err
//         }
//         var task *models.Task
//         var startDate time.Time
//         now := time.Now()
//         if ok {
//                 task, ok1 := oldTask.(*models.Task)
//                 if ok1 {
//                         startDate = task.StartDate
//                         task.ActualTime = int(now.Sub(startDate).Seconds()) + 20
//                         task.Status = status
//                         task.Progress = 100
//                         task.CompletedAt = now
//                         task.UpdatedAt = now
//                 }
//         }

//         if task == nil {
//                 task = &amp;models.Task{
//                         Title:         taskName,
//                         Description:   taskName,
//                         Status:        status,
//                         Progress:      100,
//                         StartDate:     time.Now(),
//                         DueDate:       time.Now().Add(time.Minute * 30),
//                         CompletedAt:   time.Now(),
//                         CreatorID:     99,
//                         EstimatedTime: 10,
//                         ActualTime:    0,
//                 }
//         }
//         return uc.localCache.Set(ctx, cacheKey, task, 300*time.Minute)
// }

// func (uc *AccounterUsecase) GetCacheTask(ctx context.Context, taskName string) (*models.Task, error) {

//         cacheKey := prefix + taskName
//         var task *models.Task
//         taskInfo, ok, err := uc.localCache.Get(ctx, cacheKey)
//         if err != nil {
//                 return nil, err
//         }
//         if !ok {
//                 return nil, errors.New("notfound")
//         }
//         task, ok1 := taskInfo.(*models.Task)
//         if !ok1 {
//                 return nil, errors.New("type error")
//         }
//         return task, nil

// }

func (uc *FullSyncUsecase) CleanSyncAccount(ctx context.Context, taskName string, tags []string) error <span class="cov0" title="0">{

        appAccessToken, err := uc.appAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if taskName == "phone" </span><span class="cov0" title="0">{
                users, err := uc.wps.GetCompAllUsers(ctx, appAccessToken.AccessToken, wps.GetCompAllUsersRequest{
                        Recursive: true,
                        PageSize:  50,
                        WithTotal: true,
                        Status:    []string{"active", "notactive", "disabled"},
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var deleteUsers []*dingtalk.DingtalkDeptUser
                for _, user := range users.Data.Items </span><span class="cov0" title="0">{
                        log.Infof("user: %+v", user)

                        for _, phone := range tags </span><span class="cov0" title="0">{
                                if user.Phone == phone || user.LoginName == phone </span><span class="cov0" title="0">{
                                        deleteUser := &amp;dingtalk.DingtalkDeptUser{
                                                Userid: user.ExUserID,
                                                Mobile: user.Phone,
                                                Name:   user.UserName,
                                                Email:  user.Email,
                                        }

                                        for _, dep := range user.Depts </span><span class="cov0" title="0">{
                                                depId, _ := strconv.ParseInt(dep.DeptID, 10, 64)
                                                deleteUser.DeptIDList = append(deleteUser.DeptIDList, depId)
                                        }</span>
                                        <span class="cov0" title="0">deleteUsers = append(deleteUsers, deleteUser)</span>

                                }
                        }

                }
                <span class="cov0" title="0">uc.log.Infof("deleteUsers: %v", deleteUsers)
                for i, user := range deleteUsers </span><span class="cov0" title="0">{
                        uc.log.Infof("deleteUsers i:%d, user: %+v", i, user)
                }</span>

                <span class="cov0" title="0">err = uc.repo.SaveIncrementUsers(ctx, nil, deleteUsers, nil)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("OrgDeptCreate.SaveIncrementDepartments err: %v", err)
                        return err
                }</span>

                <span class="cov0" title="0">res, err := uc.wps.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
                        ThirdCompanyId: conf.Get().GetApp().GetThirdCompanyId(),
                })

                log.Infof("UserLeaveOrg.CallEcisaccountsyncIncrement res: %v, err: %v", res, err)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if res.Code != "200" </span><span class="cov0" title="0">{
                        log.Errorf("code %v, not '200'", res.Code)
                        return fmt.Errorf("code %s not 200", res.Code)
                }</span>
        }

        <span class="cov0" title="0">if taskName == "dept" </span><span class="cov0" title="0">{
                //查询根部门
                rootDept, err := uc.wps.GetDepartmentRoot(ctx, appAccessToken.AccessToken, wps.GetDepartmentRootRequest{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">log.Infof("rootDept: %v", rootDept)

                // 2. 查询部门下的子部门(要递归)
                allDepts, err := uc.wps.GetDeptChildren(ctx, appAccessToken.AccessToken, wps.GetDeptChildrenRequest{
                        DeptID:    rootDept.Data.ID,
                        Recursive: true,
                        PageSize:  50,
                        WithTotal: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">log.Infof("children: %v", allDepts)

                var deleteDepts []*dingtalk.DingtalkDept
                //删除部门除了根部门
                for _, dept := range allDepts.Data.Items </span><span class="cov0" title="0">{
                        if dept.ID == rootDept.Data.ID </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">deptId, _ := strconv.ParseInt(dept.ExDeptID, 10, 64)

                        deptDetail, err := uc.wps.BatchPostDepartments(ctx, appAccessToken.AccessToken, wps.BatchPostDepartmentsRequest{
                                DeptIDs: []string{dept.ParentID},
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">parentId, _ := strconv.ParseInt(deptDetail.Data.Items[0].ExDeptID, 10, 64)

                        for _, tag := range tags </span><span class="cov0" title="0">{

                                if tag == dept.Name </span><span class="cov0" title="0">{
                                        // 这里要找父级节点的extid
                                        detp := &amp;dingtalk.DingtalkDept{
                                                DeptID:   deptId,
                                                ParentID: parentId,
                                                Order:    int64(dept.Order),
                                                Name:     dept.Name,
                                        }
                                        deleteDepts = append(deleteDepts, detp)

                                }</span>
                        }

                }

                <span class="cov0" title="0">uc.log.Infof("deleteDepts: %v", deleteDepts)
                for i, dept := range deleteDepts </span><span class="cov0" title="0">{
                        uc.log.Infof("deleteDepts i:%d, dept: %+v", i, dept)
                }</span>

                <span class="cov0" title="0">err = uc.repo.SaveIncrementDepartments(ctx, nil, deleteDepts, nil)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("OrgDeptCreate.SaveIncrementDepartments err: %v", err)
                        return err
                }</span>

                <span class="cov0" title="0">res, err := uc.wps.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
                        ThirdCompanyId: conf.Get().GetApp().GetThirdCompanyId(),
                })

                log.Infof("UserLeaveOrg.CallEcisaccountsyncIncrement res: %v, err: %v", res, err)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if res.Code != "200" </span><span class="cov0" title="0">{
                        log.Errorf("code %v, not '200'", res.Code)
                        return fmt.Errorf("code %s not 200", res.Code)
                }</span>

        }

        <span class="cov0" title="0">return nil</span>

}
</pre>
		
		<pre class="file" id="file13" style="display: none">package biz

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "nancalacc/internal/auth"
        "nancalacc/internal/conf"
        "nancalacc/internal/dingtalk"
        "nancalacc/internal/pkg/utils"
        "nancalacc/internal/wps"
        "strconv"

        //"github.com/go-kratos/kratos/v2/errors"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/open-dingtalk/dingtalk-stream-sdk-go/clientV2"
)

// GreeterUsecase is a Greeter usecase.
type IncrementalSyncUsecase struct {
        repo         AccounterRepo
        dingTalkRepo dingtalk.Dingtalk
        // unifiedAuth  *auth.UnifiedAuthService
        wpsAppAuth auth.Authenticator
        wps        wps.Wps
        log        *log.Helper
}

// NewGreeterUsecase new a Greeter usecase.
func NewIncrementalSyncUsecase(repo AccounterRepo, dingTalkRepo dingtalk.Dingtalk, wps wps.Wps, logger log.Logger) *IncrementalSyncUsecase <span class="cov0" title="0">{
        wpsAppAuth := auth.NewWpsAppAuthenticator()
        return &amp;IncrementalSyncUsecase{
                repo: repo, dingTalkRepo: dingTalkRepo,
                wpsAppAuth: wpsAppAuth,
                wps:        wps,
                log:        log.NewHelper(logger)}
}</span>

// OrgDeptAdd 部门新增
func (uc *IncrementalSyncUsecase) OrgDeptCreate(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) error <span class="cov0" title="0">{

        thirdCompanyId := conf.Get().GetApp().GetThirdCompanyId()
        log := uc.log.WithContext(ctx)
        log.Infof("OrgDeptCreate data: %v", event.Data)

        if event.Data == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">depIds, err := uc.getDeptidsFromDingTalkEvent(event)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(depIds) == 0 </span><span class="cov0" title="0">{
                log.Info("OrgDeptCreate len(depIds) eq 0")
                return nil
        }</span>

        <span class="cov0" title="0">dingTalkAccessToken, err := uc.dingTalkRepo.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">accessToken := dingTalkAccessToken.AccessToken

        uc.log.WithContext(ctx).Infof("OrgDeptCreate.FetchDeptDetails accessToken: %v, depIds: %v", accessToken, depIds)
        depts, err := uc.dingTalkRepo.FetchDeptDetails(ctx, accessToken, depIds)
        log.Infof("OrgDeptCreate.FetchDeptDetails accessToken: %v, depIds: %v, err:%v", accessToken, depIds, err)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = uc.repo.SaveIncrementDepartments(ctx, depts, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("OrgDeptCreate.SaveIncrementDepartments err: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">appAccessToken, err := uc.wpsAppAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">res, err := uc.wps.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
                ThirdCompanyId: thirdCompanyId,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if res.Code != "200" </span><span class="cov0" title="0">{
                log.Errorf("code %v, not '200'", res.Code)
                return fmt.Errorf("code %s not 200", res.Code)
        }</span>
        <span class="cov0" title="0">return nil</span>

}

// OrgDeptRemove 部门删除
func (uc *IncrementalSyncUsecase) OrgDeptRemove(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) error <span class="cov0" title="0">{
        log := uc.log.WithContext(ctx)
        log.Infof("OrgDeptRemove data: %v", event.Data)

        thirdCompanyId := conf.Get().GetApp().GetThirdCompanyId()
        if event.Data == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 1. 已删除的部门ID列表
        <span class="cov0" title="0">depIds, err := uc.getDeptidsFromDingTalkEvent(event)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(depIds) == 0 </span><span class="cov0" title="0">{
                uc.log.Info("OrgDeptCreate len(depIds) eq 0")
                return nil
        }</span>

        <span class="cov0" title="0">var depIdstr []string
        for _, depId := range depIds </span><span class="cov0" title="0">{
                depIdstr = append(depIdstr, strconv.FormatInt(depId, 10))

        }</span>

        <span class="cov0" title="0">if len(depIdstr) == 0 </span><span class="cov0" title="0">{
                log.Info("OrgDeptRemove len(depIdstr) eq 0")
                return errors.New("OrgDeptRemove len(depIdstr) eq 0")
        }</span>

        <span class="cov0" title="0">appAccessToken, err := uc.wpsAppAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">token := appAccessToken.AccessToken

        // 2. 查询部门ID
        depInfos, err := uc.wps.PostBatchDepartmentsByExDepIds(ctx, token, wps.PostBatchDepartmentsByExDepIdsRequest{
                ExDeptIDs: depIdstr,
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("OrgDeptRemove.PostBatchDepartmentsByExDepIds err: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">var deptIDs []string
        tempDeptIDs := make(map[string]int64)
        for _, depInfo := range depInfos.Data.Items </span><span class="cov0" title="0">{
                deptIDs = append(deptIDs, depInfo.ParentID)
        }</span>

        <span class="cov0" title="0">log.Infof("OrgDeptRemove deptIDs: %v", deptIDs)

        if len(deptIDs) == 0 </span><span class="cov0" title="0">{
                log.Info("OrgDeptRemove len(deptIDs) eq 0")
                return errors.New("OrgDeptRemove len(deptIDs) eq 0")
        }</span>
        <span class="cov0" title="0">parentDeptInfos, err := uc.wps.BatchPostDepartments(ctx, token, wps.BatchPostDepartmentsRequest{
                DeptIDs: deptIDs,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("OrgDeptRemove.BatchPostDepartments err: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">for _, pdis := range parentDeptInfos.Data.Items </span><span class="cov0" title="0">{
                extpareId, err := strconv.ParseInt(pdis.ExDeptID, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("OrgDeptRemove.ParseInt pdis.ExDeptID:%s, err: %v", pdis.ExDeptID, err)
                }</span>
                <span class="cov0" title="0">tempDeptIDs[pdis.ID] = extpareId</span>
        }

        <span class="cov0" title="0">var depts []*dingtalk.DingtalkDept

        for _, depInfo := range depInfos.Data.Items </span><span class="cov0" title="0">{

                dingtalkID, err := strconv.ParseInt(depInfo.ExDeptID, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">parentID, ok := tempDeptIDs[depInfo.ParentID]
                if !ok </span><span class="cov0" title="0">{
                        uc.log.Errorf("OrgDeptRemove not found parentID for DeptID: %s", dingtalkID)
                        continue</span>
                }
                <span class="cov0" title="0">detp := &amp;dingtalk.DingtalkDept{
                        DeptID:   dingtalkID,
                        ParentID: parentID,
                        Order:    int64(depInfo.Order),
                        Name:     depInfo.Name,
                }

                depts = append(depts, detp)</span>

        }

        <span class="cov0" title="0">err = uc.repo.SaveIncrementDepartments(ctx, nil, depts, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("OrgDeptCreate.SaveIncrementDepartments err: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">res, err := uc.wps.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
                ThirdCompanyId: thirdCompanyId,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if res.Code != "200" </span><span class="cov0" title="0">{
                log.Errorf("code %v, not '200'", res.Code)
                return fmt.Errorf("code %s not 200", res.Code)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// OrgDeptModify 部门修改
func (uc *IncrementalSyncUsecase) OrgDeptModify(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) error <span class="cov0" title="0">{

        log := uc.log.WithContext(ctx)
        log.Infof("OrgDeptModify data: %v", event.Data)

        thirdCompanyId := conf.Get().GetApp().GetThirdCompanyId()
        if event.Data == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("event.Data is nil")
        }</span>

        <span class="cov0" title="0">depIds, err := uc.getDeptidsFromDingTalkEvent(event)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dingTalkAccessToken, err := uc.dingTalkRepo.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">accessToken := dingTalkAccessToken.AccessToken

        uc.log.WithContext(ctx).Infof("OrgDeptCreate.FetchDeptDetails accessToken: %v, depIds: %v", accessToken, depIds)
        depts, err := uc.dingTalkRepo.FetchDeptDetails(ctx, accessToken, depIds)
        log.Infof("OrgDeptCreate.FetchDeptDetails accessToken: %v, depIds: %v, err:%v", accessToken, depIds, err)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = uc.repo.SaveIncrementDepartments(ctx, nil, nil, depts)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("OrgDeptCreate.SaveIncrementDepartments err: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">appAccessToken, err := uc.wpsAppAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">res, err := uc.wps.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
                ThirdCompanyId: thirdCompanyId,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if res.Code != "200" </span><span class="cov0" title="0">{
                log.Errorf("code %v, not '200'", res.Code)
                return fmt.Errorf("code %s not 200", res.Code)
        }</span>
        <span class="cov0" title="0">return nil</span>

}

// UserAddOrg 用户加入部门
// 1. 加用户
// 2. 加关系
func (uc *IncrementalSyncUsecase) UserAddOrg(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) error <span class="cov0" title="0">{

        log := uc.log.WithContext(ctx)
        log.Infof("UserAddOrg data: %v", event.Data)

        thirdCompanyId := conf.Get().GetApp().GetThirdCompanyId()
        if event.Data == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">userIds, err := uc.getUseridsFromDingTalkEvent(event)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dingTalkAccessToken, err := uc.dingTalkRepo.GetAccessToken(ctx)
        log.Infof("UserAddOrg.GetAccessToken dingTalkAccessToken: %v,userIds:%v err: %v", dingTalkAccessToken, userIds, err)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">accessToken := dingTalkAccessToken.AccessToken

        uc.log.WithContext(ctx).Infof("UserAddOrg.GetUserDetail userIds: %v", userIds)
        users, err := uc.dingTalkRepo.FetchUserDetail(ctx, accessToken, userIds)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = uc.repo.SaveIncrementUsers(ctx, users, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">relations := generateUserDeptRelations(users)

        err = uc.repo.SaveIncrementDepartmentUserRelations(ctx, relations, nil, nil)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">appAccessToken, err := uc.wpsAppAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">res, err := uc.wps.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
                ThirdCompanyId: thirdCompanyId,
        })

        log.Infof("UserAddOrg.CallEcisaccountsyncIncrement res: %v, err: %v", res, err)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if res.Code != "200" </span><span class="cov0" title="0">{
                log.Errorf("code %v, not '200'", res.Code)
                return fmt.Errorf("code %s not 200", res.Code)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UserLeaveOrg 用户退出部门
// 1. 减用户
// 2. 减关系 //未自测
func (uc *IncrementalSyncUsecase) UserLeaveOrg(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) error <span class="cov0" title="0">{

        thirdCompanyId := conf.Get().GetApp().GetThirdCompanyId()
        log := uc.log.WithContext(ctx)
        log.Infof("UserLeaveOrg data: %v", event.Data)
        if event.Data == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">userIds, err := uc.getUseridsFromDingTalkEvent(event)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">appAccessToken, err := uc.wpsAppAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">wpsUsers, err := uc.FindWpsUser(ctx, userIds)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(wpsUsers) == 0 </span><span class="cov0" title="0">{
                log.Warnf("wpsUsers is empty, userIds: %v", userIds)
                return fmt.Errorf("wpsUsers is empty")
        }</span>
        <span class="cov0" title="0">err = uc.repo.SaveIncrementUsers(ctx, nil, wpsUsers, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">relations := generateUserDeptRelations(wpsUsers)

        err = uc.repo.SaveIncrementDepartmentUserRelations(ctx, nil, relations, nil)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">res, err := uc.wps.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
                ThirdCompanyId: thirdCompanyId,
        })

        log.Infof("UserLeaveOrg.CallEcisaccountsyncIncrement res: %v, err: %v", res, err)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if res.Code != "200" </span><span class="cov0" title="0">{
                log.Errorf("code %v, not '200'", res.Code)
                return fmt.Errorf("code %s not 200", res.Code)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (uc *IncrementalSyncUsecase) FindWpsUser(ctx context.Context, userids []string) ([]*dingtalk.DingtalkDeptUser, error) <span class="cov0" title="0">{
        uc.log.WithContext(ctx).Infof("FindWpsUser req userids: %v", userids)
        var users []*dingtalk.DingtalkDeptUser
        appAccessToken, err := uc.wpsAppAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, userId := range userids </span><span class="cov0" title="0">{
                wpsUserInfo, err := uc.wps.PostBatchUsersByExDepIds(ctx, appAccessToken.AccessToken, wps.PostBatchUsersByExDepIdsRequest{
                        ExUserIDs: []string{userId},
                        Status:    []string{wps.UserStatusActive, wps.UserStatusNoActive, wps.UserStatusDisabled},
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if len(wpsUserInfo.Data.Items) == 0 </span><span class="cov0" title="0">{
                        uc.log.Warnf("wpsUserInfo.Data.Items is empty, userId: %v", userId)
                        continue</span>
                }

                <span class="cov0" title="0">wpsUser := wpsUserInfo.Data.Items[0]
                wpsUserid := wpsUser.ID

                wpsDeptInfo, err := uc.wps.GetUserDeptsByUserId(ctx, appAccessToken.AccessToken, wps.GetUserDeptsByUserIdRequest{
                        UserID: wpsUserid,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if len(wpsDeptInfo.Data.Items) == 0 </span><span class="cov0" title="0">{
                        uc.log.Warnf("wpsDeptInfo.Data.Items is empty, userId: %v", userId)
                        continue</span>
                }
                <span class="cov0" title="0">user := &amp;dingtalk.DingtalkDeptUser{
                        Userid: wpsUser.ExUserId,
                        Name:   wpsUser.UserName,
                        Email:  wpsUser.Email,
                        Mobile: wpsUser.Phone,
                }
                for _, item := range wpsDeptInfo.Data.Items </span><span class="cov0" title="0">{
                        deptId, err := strconv.ParseInt(item.ExDeptID, 10, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">user.DeptIDList = append(user.DeptIDList, deptId)</span>
                }
                <span class="cov0" title="0">users = append(users, user)</span>
        }
        <span class="cov0" title="0">uc.log.WithContext(ctx).Infof("FindWpsUser res users: %v", users)
        if len(users) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wpsUsers is empty")
        }</span>
        <span class="cov0" title="0">for _, user := range users </span><span class="cov0" title="0">{
                uc.log.WithContext(ctx).Infof("FindWpsUser res user: %+v", user)
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}
func (uc *IncrementalSyncUsecase) FindDingTalkUser(ctx context.Context, userids []string) ([]*dingtalk.DingtalkDeptUser, error) <span class="cov0" title="0">{
        uc.log.WithContext(ctx).Infof("FindDingTalkUser req: %v", userids)

        dingTalkAccessToken, err := uc.dingTalkRepo.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">accessToken := dingTalkAccessToken.AccessToken

        users, err := uc.dingTalkRepo.FetchUserDetail(ctx, accessToken, userids)
        uc.log.WithContext(ctx).Infof("FindDingTalkUser res: %+v, err:%v", users, err)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

// UserModifyOrg 用户信息变更（有部门变正在实现）
func (uc *IncrementalSyncUsecase) UserModifyOrg(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) error <span class="cov0" title="0">{

        thirdCompanyId := conf.Get().GetApp().GetThirdCompanyId()
        log := uc.log.WithContext(ctx)
        log.Infof("UserModifyOrg data: %v", event.Data)
        diffUserInfo, _ := uc.getUseInfoFromDingTalkEvent(event)
        diffUserMap := make(map[string]*dingtalk.DingtalkDeptUser, len(diffUserInfo))
        if len(diffUserInfo) &gt; 0 </span><span class="cov0" title="0">{
                for _, diffUser := range diffUserInfo </span><span class="cov0" title="0">{
                        diffUserMap[diffUser.Userid] = diffUser
                        //uc.log.Infof("UserModifyOrg[基础信息变更] user: %v", user)
                }</span>
                //uc.log.Info("UserModifyOrg[基础信息变更] modfiyUserBaseInfo:")
                //modfiyUserBaseInfo = append(modfiyUserBaseInfo, diffUserInfo...)
        }

        <span class="cov0" title="0">userIds, err := uc.getUseridsFromDingTalkEvent(event)

        userIds = utils.RemoveDuplicates(userIds)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">wpsUsersMap := make(map[string]*dingtalk.DingtalkDeptUser)
        wpsUsers, err := uc.FindWpsUser(ctx, userIds)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(wpsUsers) &gt; 0 </span><span class="cov0" title="0">{
                for _, user := range wpsUsers </span><span class="cov0" title="0">{
                        wpsUsersMap[user.Userid] = user
                }</span>
        }

        <span class="cov0" title="0">for _, u := range wpsUsers </span><span class="cov0" title="0">{
                log.Infof("UserModifyOrg wpsuser: %+v", u)

                for _, deptId := range u.DeptIDList </span><span class="cov0" title="0">{
                        log.Infof("UserModifyOrg wpsuser deptId: %+v", deptId)
                }</span>
        }

        <span class="cov0" title="0">dingtalkUsers, err := uc.FindDingTalkUser(ctx, userIds)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">log.Infof("UserModifyOrg userIds.size: %v", len(userIds))
        log.Infof("UserModifyOrg wpsUsers.size: %v", len(wpsUsers))
        log.Infof("UserModifyOrg dingtalkUsers.size: %v", len(dingtalkUsers))
        var modfiyUserBaseInfo []*dingtalk.DingtalkDeptUser
        var delRelation []*dingtalk.DingtalkDeptUserRelation
        var addRelation []*dingtalk.DingtalkDeptUserRelation
        var updRelation []*dingtalk.DingtalkDeptUserRelation

        for _, dingtalkUser := range dingtalkUsers </span><span class="cov0" title="0">{ //4个
                var delDepts []int64
                var addDepts []int64
                var updDepts []int64
                finalUser := dingtalkUser
                dingtalkUseridDeptidMap := make(map[string]int64)
                for _, deptId := range dingtalkUser.DeptIDList </span><span class="cov0" title="0">{
                        key := dingtalkUser.Userid + "#" + strconv.FormatInt(deptId, 10)
                        dingtalkUseridDeptidMap[key] = deptId
                }</span>
                <span class="cov0" title="0">if wpsUser, ok := wpsUsersMap[dingtalkUser.Userid]; ok </span><span class="cov0" title="0">{ //先找到用户

                        for _, deptId := range wpsUser.DeptIDList </span><span class="cov0" title="0">{
                                key1 := wpsUser.Userid + "#" + strconv.FormatInt(deptId, 10)

                                if _, ok := dingtalkUseridDeptidMap[key1]; ok </span><span class="cov0" title="0">{
                                        //部门修改
                                        updDepts = append(updDepts, deptId)
                                        uc.log.Infof("UserModifyOrg[部门关系修改] user.Userid#deptId: %v", key1)
                                        delete(dingtalkUseridDeptidMap, key1)
                                }</span> else<span class="cov0" title="0"> {
                                        //部门删除
                                        uc.log.Infof("UserModifyOrg[部门关系删除] user.Userid#deptId: %v", key1)
                                        delDepts = append(delDepts, deptId)

                                }</span>
                        }

                }
                <span class="cov0" title="0">if len(dingtalkUseridDeptidMap) &gt; 0 </span><span class="cov0" title="0">{
                        for k, deptId := range dingtalkUseridDeptidMap </span><span class="cov0" title="0">{
                                uc.log.Infof("UserModifyOrg[部门关系增加] user.Userid#deptId: %v", k)
                                addDepts = append(addDepts, deptId)
                        }</span>

                }

                <span class="cov0" title="0">if len(addDepts) &gt; 0 </span><span class="cov0" title="0">{
                        adduser := finalUser
                        adduser.DeptIDList = addDepts
                        addRelation = append(addRelation, generateUserDeptRelations([]*dingtalk.DingtalkDeptUser{adduser})...)

                }</span>
                <span class="cov0" title="0">if len(delDepts) &gt; 0 </span><span class="cov0" title="0">{
                        deluser := finalUser
                        deluser.DeptIDList = delDepts
                        delRelation = append(delRelation, generateUserDeptRelations([]*dingtalk.DingtalkDeptUser{deluser})...)
                }</span>
                <span class="cov0" title="0">if len(updDepts) &gt; 0 </span><span class="cov0" title="0">{
                        upduser := finalUser
                        upduser.DeptIDList = updDepts
                        updRelation = append(updRelation, generateUserDeptRelations([]*dingtalk.DingtalkDeptUser{upduser})...)
                }</span>

                <span class="cov0" title="0">if _, ok := diffUserMap[finalUser.Userid]; ok </span><span class="cov0" title="0">{
                        modfiyUserBaseInfo = append(modfiyUserBaseInfo, finalUser)
                }</span>
        }
        <span class="cov0" title="0">uc.log.Info("UserModifyOrg[部门关系新增] addRelation:")
        for i, item := range addRelation </span><span class="cov0" title="0">{
                uc.log.Infof("UserModifyOrg[部门关系新增] i: %d, item: %+v", i, item)
        }</span>
        <span class="cov0" title="0">uc.log.Info("UserModifyOrg[部门关系删除] delRelation:")
        for i, item := range delRelation </span><span class="cov0" title="0">{
                uc.log.Infof("UserModifyOrg[部门关系删除] i: %d, item: %+v", i, item)
        }</span>

        <span class="cov0" title="0">uc.log.Info("UserModifyOrg[部门关系修改] updRelation:")
        for i, item := range updRelation </span><span class="cov0" title="0">{
                uc.log.Infof("UserModifyOrg[部门关系修改] i: %d, iitem: %+v", i, item)
        }</span>

        <span class="cov0" title="0">uc.log.Info("UserModifyOrg[基础信息变更] modfiyUserBaseInfo:")
        for i, item := range modfiyUserBaseInfo </span><span class="cov0" title="0">{
                uc.log.Infof("UserModifyOrg[基础信息变更] i: %d, item: %+v", i, item)
        }</span>
        <span class="cov0" title="0">if len(modfiyUserBaseInfo) &gt; 0 </span><span class="cov0" title="0">{
                err = uc.repo.SaveIncrementUsers(ctx, nil, nil, modfiyUserBaseInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if len(addRelation)+len(delRelation)+len(updRelation) &gt; 0 </span><span class="cov0" title="0">{
                err = uc.repo.SaveIncrementDepartmentUserRelations(ctx, addRelation, delRelation, updRelation)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">log.Infof("UserModifyOrg.CallEcisaccountsyncIncrement test %s", event.Data)
        //return nil
        appAccessToken, err := uc.wpsAppAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">res, err := uc.wps.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
                ThirdCompanyId: thirdCompanyId,
        })

        log.Infof("UserModifyOrg.CallEcisaccountsyncIncrement res: %v, err: %v", res, err)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if res.Code != "200" </span><span class="cov0" title="0">{
                log.Errorf("code %v, not '200'", res.Code)
                return fmt.Errorf("code %s not 200", res.Code)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func generateUserDeptRelations(deptUsers []*dingtalk.DingtalkDeptUser) []*dingtalk.DingtalkDeptUserRelation <span class="cov0" title="0">{
        var deptUserRelations []*dingtalk.DingtalkDeptUserRelation
        for _, deptUser := range deptUsers </span><span class="cov0" title="0">{

                order := make(map[int64]int64, 0)
                if len(deptUser.DeptOrderList) &gt; 0 </span><span class="cov0" title="0">{
                        for _, depIdOrder := range deptUser.DeptOrderList </span><span class="cov0" title="0">{
                                order[depIdOrder.DeptID] = depIdOrder.DeptID
                        }</span>
                }

                <span class="cov0" title="0">for _, depId := range deptUser.DeptIDList </span><span class="cov0" title="0">{
                        relation := &amp;dingtalk.DingtalkDeptUserRelation{
                                Uid: deptUser.Userid,
                                Did: strconv.FormatInt(depId, 10),
                                // Order: order,
                        }
                        if order, ok := order[depId]; ok </span><span class="cov0" title="0">{
                                relation.Order = order
                        }</span>
                        <span class="cov0" title="0">deptUserRelations = append(deptUserRelations, relation)</span>
                }

        }

        <span class="cov0" title="0">return deptUserRelations</span>
}

func (uc *IncrementalSyncUsecase) getDeptidsFromDingTalkEvent(event *clientV2.GenericOpenDingTalkEvent) ([]int64, error) <span class="cov0" title="0">{
        uc.log.Infof("getDeptidsFromDingTalkEvent: %v", event.Data)

        if event.Data == nil </span><span class="cov0" title="0">{
                return nil, errors.New("getDeptidsFromDingTalkEvent event.Data is nil")
        }</span>
        <span class="cov0" title="0">datamap := event.Data
        var depIds []int64

        deptId, exists := datamap["deptId"]

        if !exists </span><span class="cov0" title="0">{
                uc.log.Errorf("getDeptidsFromDingTalkEvent not deptId: %v, exists: %v", deptId, exists)
                return nil, errors.New("getDeptidsFromDingTalkEvent not deptId")
        }</span>

        <span class="cov0" title="0">deptIdSlice, ok := deptId.([]interface{})

        if !ok </span><span class="cov0" title="0">{
                uc.log.Errorf("deptId not []interface{}: %v, ok: %v", deptId, ok)
                return nil, errors.New("deptId not []interface{}")
        }</span>

        <span class="cov0" title="0">for _, item := range deptIdSlice </span><span class="cov0" title="0">{
                if f, ok := item.(float64); ok </span><span class="cov0" title="0">{
                        depIds = append(depIds, int64(f))
                }</span> else<span class="cov0" title="0"> {
                        uc.log.Errorf("deptId not float64: %T", item)
                        return nil, errors.New("deptId not float64")
                }</span>
        }
        <span class="cov0" title="0">return depIds, nil</span>
}

func (uc *IncrementalSyncUsecase) getUseridsFromDingTalkEvent(event *clientV2.GenericOpenDingTalkEvent) ([]string, error) <span class="cov0" title="0">{
        uc.log.Infof("getUseridsFromDingTalkEvent: %v", event.Data)
        if event.Data == nil </span><span class="cov0" title="0">{
                return nil, errors.New("getUseridsFromDingTalkEvent event.Data is nil")
        }</span>
        <span class="cov0" title="0">datamap := event.Data
        var userIds []string

        userId, exists := datamap["userId"]

        if !exists </span><span class="cov0" title="0">{
                uc.log.Errorf("getUseridsFromDingTalkEvent not userId: %v, exists: %v", userId, exists)
                return nil, errors.New("getUseridsFromDingTalkEvent not userId")
        }</span>

        <span class="cov0" title="0">userIdSlice, ok := userId.([]interface{})

        if !ok </span><span class="cov0" title="0">{
                uc.log.Errorf("userId not []interface{}: %v, ok: %v", userId, ok)
                return nil, errors.New("userId not []interface{}")
        }</span>

        <span class="cov0" title="0">for _, item := range userIdSlice </span><span class="cov0" title="0">{
                if f, ok := item.(string); ok </span><span class="cov0" title="0">{
                        userIds = append(userIds, f)
                }</span> else<span class="cov0" title="0"> {
                        uc.log.Errorf("userId not string: %T", item)
                        return nil, errors.New("userId not string")
                }</span>
        }
        <span class="cov0" title="0">return userIds, nil</span>
}

// map[
//
//        diffInfo:[
//                map[
//                        curr:map[email:ian@googla.om hiredDate:2025-08-07 jobNumber:20 name:Ianmodity remark:me telephone: workPlace:北京]
//                        prev:map[email:ian@googla.om hiredDate:2025-08-07 jobNumber:20 name:Ian remark:me telephone: workPlace:北京]
//                        userid:03301410433273270
//                ]
//        ]
//        eventId:ebb4c3f1284e45f680ac50ec55b5c5d8
//        optStaffId:manager331
//        timeStamp:1754553836642
//        userId:[03301410433273270]
//
// ]
func (uc *IncrementalSyncUsecase) getUseInfoFromDingTalkEvent(event *clientV2.GenericOpenDingTalkEvent) ([]*dingtalk.DingtalkDeptUser, error) <span class="cov0" title="0">{
        uc.log.Infof("getUseInfoFromDingTalkEvent: %v", event.Data)
        data := event.Data

        var userInfos []*dingtalk.DingtalkDeptUser
        jsonData, err := json.Marshal(data)
        uc.log.Infof("getUseInfoFromDingTalkEvent Marshal: %v, err:%v", jsonData, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshal error: %v", err)
        }</span>

        <span class="cov0" title="0">var modifyInfo dingtalk.UserModifyOrgEventData
        err = json.Unmarshal(jsonData, &amp;modifyInfo)
        uc.log.Infof("getUseInfoFromDingTalkEvent Unmarshal err: %v, modifyInfo: %v", err, modifyInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unmarshal error: %v", err)
        }</span>
        <span class="cov0" title="0">for _, modifyInfo := range modifyInfo.DiffInfo </span><span class="cov0" title="0">{
                userInfo := &amp;dingtalk.DingtalkDeptUser{
                        Userid:    modifyInfo.Userid,
                        Name:      modifyInfo.Curr.Name,
                        Email:     modifyInfo.Curr.Email,
                        WorkPlace: modifyInfo.Curr.WorkPlace,
                        JobNumber: modifyInfo.Curr.JobNumber,
                        Mobile:    modifyInfo.Curr.Telephone,
                        Remark:    modifyInfo.Curr.Remark,
                }
                userInfos = append(userInfos, userInfo)
        }</span>

        <span class="cov0" title="0">return userInfos, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package biz

import (
        "context"
        "errors"
        v1 "nancalacc/api/account/v1"
        "nancalacc/internal/dingtalk"

        "github.com/go-kratos/kratos/v2/log"
)

// GreeterUsecase is a Greeter usecase.
type Oauth2Usecase struct {
        dingTalkRepo dingtalk.Dingtalk
        log          *log.Helper
}

// NewGreeterUsecase new a Greeter usecase.
func NewOauth2Usecase(dingTalkRepo dingtalk.Dingtalk, logger log.Logger) *Oauth2Usecase <span class="cov0" title="0">{
        return &amp;Oauth2Usecase{dingTalkRepo: dingTalkRepo, log: log.NewHelper(logger)}
}</span>

func (uc *Oauth2Usecase) GetUserInfo(ctx context.Context, req *v1.GetUserInfoRequest) (*v1.GetUserInfoResponse, error) <span class="cov0" title="0">{

        log := uc.log.WithContext(ctx)
        log.Infof("GetUserInfo req: %v", req)

        accessToken := req.GetAccessToken()
        if accessToken == "" </span><span class="cov0" title="0">{
                return nil, errors.New("access_token is empty")
        }</span>
        <span class="cov0" title="0">var userId string
        userInfo, err := uc.dingTalkRepo.GetUserInfo(ctx, accessToken, "me")
        log.Infof("GetUserInfo.dingTalkRepo.GetUserInfo: %v, err:%v", userInfo, err)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("GetUserInfo.dingTalkRepo.GetUserInfo: %v, err:%v", userInfo, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">token, err := uc.dingTalkRepo.GetAccessToken(ctx)
        log.Infof("GetUserInfo.dingTalkRepo.GetAccessToken: token: %v, err: %v", token, err)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.WithContext(ctx).Error("GetUserInfo.dingTalkRepo.GetAccessToken: token: %v, err: %v", token, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">userId, err = uc.dingTalkRepo.GetUseridByUnionid(ctx, token.AccessToken, userInfo.UnionId)
        log.Infof("GetUserInfo.GetUseridByUnionid: userId: %v, err: %v", userId, err)

        if err != nil </span><span class="cov0" title="0">{
                log.Error("GetUserInfo.GetUseridByUnionid: userId: %v, err: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;v1.GetUserInfoResponse{
                UnionId: userInfo.UnionId,
                UserId:  userId,
                Name:    userInfo.Nick,
                Email:   userInfo.Email,
                Avatar:  userInfo.AvatarUrl,
        }, nil</span>
}
func (uc *Oauth2Usecase) GetAccessToken(ctx context.Context, req *v1.GetAccessTokenRequest) (*v1.GetAccessTokenResponse, error) <span class="cov0" title="0">{

        log := uc.log.WithContext(ctx)
        log.Infof("GetAccessToken req: %v", req)

        code := req.GetCode()
        if code == "" </span><span class="cov0" title="0">{
                return nil, errors.New("code is empty")
        }</span>
        <span class="cov0" title="0">tokenRes, err := uc.dingTalkRepo.GetUserAccessToken(ctx, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;v1.GetAccessTokenResponse{
                AccessToken:  tokenRes.AccessToken,
                RefreshToken: tokenRes.RefreshToken,
                ExpiresIn:    int64(tokenRes.ExpireIn),
                //RefreshToken: tokenRes.RefreshToken,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v5.29.3
// source: conf/conf.proto

package conf

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        durationpb "google.golang.org/protobuf/types/known/durationpb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Bootstrap struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Server        *Server                `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
        Data          *Data                  `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
        App           *App                   `protobuf:"bytes,3,opt,name=app,proto3" json:"app,omitempty"`
        Auth          *Auth                  `protobuf:"bytes,4,opt,name=auth,proto3" json:"auth,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Bootstrap) Reset() <span class="cov0" title="0">{
        *x = Bootstrap{}
        mi := &amp;file_conf_conf_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Bootstrap) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Bootstrap) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Bootstrap) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Bootstrap.ProtoReflect.Descriptor instead.
func (*Bootstrap) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Bootstrap) GetServer() *Server <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Server
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Bootstrap) GetData() *Data <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Data
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Bootstrap) GetApp() *App <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.App
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Bootstrap) GetAuth() *Auth <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Auth
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Server struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Http          *Server_HTTP           `protobuf:"bytes,1,opt,name=http,proto3" json:"http,omitempty"`
        Grpc          *Server_GRPC           `protobuf:"bytes,2,opt,name=grpc,proto3" json:"grpc,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Server) Reset() <span class="cov0" title="0">{
        *x = Server{}
        mi := &amp;file_conf_conf_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Server) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Server) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Server) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Server.ProtoReflect.Descriptor instead.
func (*Server) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{1}
}</span>

func (x *Server) GetHttp() *Server_HTTP <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Http
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Server) GetGrpc() *Server_GRPC <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Grpc
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Data struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Database      *Data_Database         `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
        DatabaseSync  *Data_DatabaseSync     `protobuf:"bytes,2,opt,name=database_sync,json=databaseSync,proto3" json:"database_sync,omitempty"`
        Redis         *Data_Redis            `protobuf:"bytes,3,opt,name=redis,proto3" json:"redis,omitempty"`
        Etcd          *Data_Etcd             `protobuf:"bytes,4,opt,name=etcd,proto3" json:"etcd,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Data) Reset() <span class="cov0" title="0">{
        *x = Data{}
        mi := &amp;file_conf_conf_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Data) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Data) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Data) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Data.ProtoReflect.Descriptor instead.
func (*Data) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{2}
}</span>

func (x *Data) GetDatabase() *Data_Database <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Database
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Data) GetDatabaseSync() *Data_DatabaseSync <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DatabaseSync
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Data) GetRedis() *Data_Redis <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Redis
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Data) GetEtcd() *Data_Etcd <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Etcd
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type App struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        Id             string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name           string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Version        string                 `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
        Env            string                 `protobuf:"bytes,4,opt,name=env,proto3" json:"env,omitempty"`
        LogLevel       string                 `protobuf:"bytes,5,opt,name=log_level,json=logLevel,proto3" json:"log_level,omitempty"`
        LogOut         string                 `protobuf:"bytes,6,opt,name=log_out,json=logOut,proto3" json:"log_out,omitempty"`
        AppPackage     string                 `protobuf:"bytes,7,opt,name=app_package,json=appPackage,proto3" json:"app_package,omitempty"`
        AppId          string                 `protobuf:"bytes,8,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
        AppSecret      string                 `protobuf:"bytes,9,opt,name=app_secret,json=appSecret,proto3" json:"app_secret,omitempty"`
        ThirdCompanyId string                 `protobuf:"bytes,10,opt,name=third_company_id,json=thirdCompanyId,proto3" json:"third_company_id,omitempty"`
        PlatformIds    string                 `protobuf:"bytes,11,opt,name=platform_ids,json=platformIds,proto3" json:"platform_ids,omitempty"`
        CompanyId      string                 `protobuf:"bytes,12,opt,name=company_id,json=companyId,proto3" json:"company_id,omitempty"`
        AccessKey      string                 `protobuf:"bytes,13,opt,name=access_key,json=accessKey,proto3" json:"access_key,omitempty"`
        SecretKey      string                 `protobuf:"bytes,14,opt,name=secret_key,json=secretKey,proto3" json:"secret_key,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *App) Reset() <span class="cov0" title="0">{
        *x = App{}
        mi := &amp;file_conf_conf_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *App) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*App) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *App) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use App.ProtoReflect.Descriptor instead.
func (*App) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{3}
}</span>

func (x *App) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Version
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetEnv() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Env
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetLogLevel() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LogLevel
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetLogOut() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LogOut
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetAppPackage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AppPackage
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetAppId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AppId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetAppSecret() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AppSecret
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetThirdCompanyId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ThirdCompanyId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetPlatformIds() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PlatformIds
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetCompanyId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CompanyId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetAccessKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetSecretKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SecretKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Auth struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Wpsapp        *Auth_Wpsapp           `protobuf:"bytes,1,opt,name=wpsapp,proto3" json:"wpsapp,omitempty"`
        Dingtalk      *Auth_Dingtalk         `protobuf:"bytes,2,opt,name=dingtalk,proto3" json:"dingtalk,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Auth) Reset() <span class="cov0" title="0">{
        *x = Auth{}
        mi := &amp;file_conf_conf_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Auth) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Auth) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Auth) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Auth.ProtoReflect.Descriptor instead.
func (*Auth) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{4}
}</span>

func (x *Auth) GetWpsapp() *Auth_Wpsapp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Wpsapp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Auth) GetDingtalk() *Auth_Dingtalk <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Dingtalk
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Server_HTTP struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Network       string                 `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
        Addr          string                 `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
        Timeout       *durationpb.Duration   `protobuf:"bytes,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Server_HTTP) Reset() <span class="cov0" title="0">{
        *x = Server_HTTP{}
        mi := &amp;file_conf_conf_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Server_HTTP) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Server_HTTP) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Server_HTTP) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Server_HTTP.ProtoReflect.Descriptor instead.
func (*Server_HTTP) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{1, 0}
}</span>

func (x *Server_HTTP) GetNetwork() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Network
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Server_HTTP) GetAddr() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Addr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Server_HTTP) GetTimeout() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timeout
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Server_GRPC struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Network       string                 `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
        Addr          string                 `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
        Timeout       *durationpb.Duration   `protobuf:"bytes,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Server_GRPC) Reset() <span class="cov0" title="0">{
        *x = Server_GRPC{}
        mi := &amp;file_conf_conf_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Server_GRPC) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Server_GRPC) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Server_GRPC) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Server_GRPC.ProtoReflect.Descriptor instead.
func (*Server_GRPC) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{1, 1}
}</span>

func (x *Server_GRPC) GetNetwork() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Network
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Server_GRPC) GetAddr() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Addr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Server_GRPC) GetTimeout() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timeout
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Data_Database struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        Driver          string                 `protobuf:"bytes,1,opt,name=driver,proto3" json:"driver,omitempty"`
        Source          string                 `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
        MaxOpenConns    int32                  `protobuf:"varint,3,opt,name=max_open_conns,json=maxOpenConns,proto3" json:"max_open_conns,omitempty"`
        MaxIdleConns    int32                  `protobuf:"varint,4,opt,name=max_idle_conns,json=maxIdleConns,proto3" json:"max_idle_conns,omitempty"`
        ConnMaxLifetime string                 `protobuf:"bytes,5,opt,name=conn_max_lifetime,json=connMaxLifetime,proto3" json:"conn_max_lifetime,omitempty"`
        Tag             string                 `protobuf:"bytes,6,opt,name=tag,proto3" json:"tag,omitempty"`
        SourceKey       string                 `protobuf:"bytes,7,opt,name=source_key,json=sourceKey,proto3" json:"source_key,omitempty"`
        Env             string                 `protobuf:"bytes,8,opt,name=env,proto3" json:"env,omitempty"`
        Enable          bool                   `protobuf:"varint,9,opt,name=enable,proto3" json:"enable,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *Data_Database) Reset() <span class="cov0" title="0">{
        *x = Data_Database{}
        mi := &amp;file_conf_conf_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Data_Database) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Data_Database) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Data_Database) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Data_Database.ProtoReflect.Descriptor instead.
func (*Data_Database) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{2, 0}
}</span>

func (x *Data_Database) GetDriver() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Driver
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetSource() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Source
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetMaxOpenConns() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxOpenConns
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_Database) GetMaxIdleConns() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxIdleConns
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_Database) GetConnMaxLifetime() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConnMaxLifetime
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetTag() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetSourceKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SourceKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetEnv() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Env
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetEnable() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enable
        }</span>
        <span class="cov0" title="0">return false</span>
}

type Data_DatabaseSync struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        Driver          string                 `protobuf:"bytes,1,opt,name=driver,proto3" json:"driver,omitempty"`
        Source          string                 `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
        MaxOpenConns    int32                  `protobuf:"varint,3,opt,name=max_open_conns,json=maxOpenConns,proto3" json:"max_open_conns,omitempty"`
        MaxIdleConns    int32                  `protobuf:"varint,4,opt,name=max_idle_conns,json=maxIdleConns,proto3" json:"max_idle_conns,omitempty"`
        ConnMaxLifetime string                 `protobuf:"bytes,5,opt,name=conn_max_lifetime,json=connMaxLifetime,proto3" json:"conn_max_lifetime,omitempty"`
        Tag             string                 `protobuf:"bytes,6,opt,name=tag,proto3" json:"tag,omitempty"`
        SourceKey       string                 `protobuf:"bytes,7,opt,name=source_key,json=sourceKey,proto3" json:"source_key,omitempty"`
        Env             string                 `protobuf:"bytes,8,opt,name=env,proto3" json:"env,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *Data_DatabaseSync) Reset() <span class="cov0" title="0">{
        *x = Data_DatabaseSync{}
        mi := &amp;file_conf_conf_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Data_DatabaseSync) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Data_DatabaseSync) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Data_DatabaseSync) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Data_DatabaseSync.ProtoReflect.Descriptor instead.
func (*Data_DatabaseSync) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{2, 1}
}</span>

func (x *Data_DatabaseSync) GetDriver() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Driver
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_DatabaseSync) GetSource() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Source
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_DatabaseSync) GetMaxOpenConns() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxOpenConns
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_DatabaseSync) GetMaxIdleConns() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxIdleConns
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_DatabaseSync) GetConnMaxLifetime() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConnMaxLifetime
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_DatabaseSync) GetTag() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_DatabaseSync) GetSourceKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SourceKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_DatabaseSync) GetEnv() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Env
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Data_Redis struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Network       string                 `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
        Addr          string                 `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
        Password      string                 `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
        Db            int32                  `protobuf:"varint,4,opt,name=db,proto3" json:"db,omitempty"`
        Enable        bool                   `protobuf:"varint,5,opt,name=enable,proto3" json:"enable,omitempty"`
        ReadTimeout   *durationpb.Duration   `protobuf:"bytes,6,opt,name=read_timeout,json=readTimeout,proto3" json:"read_timeout,omitempty"`
        WriteTimeout  *durationpb.Duration   `protobuf:"bytes,7,opt,name=write_timeout,json=writeTimeout,proto3" json:"write_timeout,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Data_Redis) Reset() <span class="cov0" title="0">{
        *x = Data_Redis{}
        mi := &amp;file_conf_conf_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Data_Redis) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Data_Redis) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Data_Redis) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Data_Redis.ProtoReflect.Descriptor instead.
func (*Data_Redis) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{2, 2}
}</span>

func (x *Data_Redis) GetNetwork() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Network
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Redis) GetAddr() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Addr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Redis) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Redis) GetDb() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Db
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_Redis) GetEnable() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enable
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Data_Redis) GetReadTimeout() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReadTimeout
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Data_Redis) GetWriteTimeout() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.WriteTimeout
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Data_Etcd struct {
        state             protoimpl.MessageState `protogen:"open.v1"`
        Endpoints         []string               `protobuf:"bytes,1,rep,name=endpoints,proto3" json:"endpoints,omitempty"`
        DialTimeout       string                 `protobuf:"bytes,2,opt,name=dial_timeout,json=dialTimeout,proto3" json:"dial_timeout,omitempty"`
        ConfigPrefix      string                 `protobuf:"bytes,3,opt,name=config_prefix,json=configPrefix,proto3" json:"config_prefix,omitempty"`
        EnableConfigWatch bool                   `protobuf:"varint,4,opt,name=enable_config_watch,json=enableConfigWatch,proto3" json:"enable_config_watch,omitempty"`
        Enable            bool                   `protobuf:"varint,5,opt,name=enable,proto3" json:"enable,omitempty"`
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *Data_Etcd) Reset() <span class="cov0" title="0">{
        *x = Data_Etcd{}
        mi := &amp;file_conf_conf_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Data_Etcd) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Data_Etcd) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Data_Etcd) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Data_Etcd.ProtoReflect.Descriptor instead.
func (*Data_Etcd) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{2, 3}
}</span>

func (x *Data_Etcd) GetEndpoints() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Endpoints
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Data_Etcd) GetDialTimeout() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DialTimeout
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Etcd) GetConfigPrefix() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConfigPrefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Etcd) GetEnableConfigWatch() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EnableConfigWatch
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Data_Etcd) GetEnable() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enable
        }</span>
        <span class="cov0" title="0">return false</span>
}

type Auth_Wpsapp struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ClientId      string                 `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
        ClientSecret  string                 `protobuf:"bytes,2,opt,name=client_secret,json=clientSecret,proto3" json:"client_secret,omitempty"`
        AuthUrl       string                 `protobuf:"bytes,3,opt,name=auth_url,json=authUrl,proto3" json:"auth_url,omitempty"`
        AuthPath      string                 `protobuf:"bytes,4,opt,name=auth_path,json=authPath,proto3" json:"auth_path,omitempty"`
        GrantType     string                 `protobuf:"bytes,5,opt,name=grant_type,json=grantType,proto3" json:"grant_type,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Auth_Wpsapp) Reset() <span class="cov0" title="0">{
        *x = Auth_Wpsapp{}
        mi := &amp;file_conf_conf_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Auth_Wpsapp) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Auth_Wpsapp) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Auth_Wpsapp) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Auth_Wpsapp.ProtoReflect.Descriptor instead.
func (*Auth_Wpsapp) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{4, 0}
}</span>

func (x *Auth_Wpsapp) GetClientId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ClientId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth_Wpsapp) GetClientSecret() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ClientSecret
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth_Wpsapp) GetAuthUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth_Wpsapp) GetAuthPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthPath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth_Wpsapp) GetGrantType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GrantType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Auth_Dingtalk struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Endpoint      string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
        AppKey        string                 `protobuf:"bytes,2,opt,name=app_key,json=appKey,proto3" json:"app_key,omitempty"`
        AppSecret     string                 `protobuf:"bytes,3,opt,name=app_secret,json=appSecret,proto3" json:"app_secret,omitempty"`
        Timeout       string                 `protobuf:"bytes,4,opt,name=timeout,proto3" json:"timeout,omitempty"`
        MaxConcurrent int64                  `protobuf:"varint,5,opt,name=maxConcurrent,proto3" json:"maxConcurrent,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Auth_Dingtalk) Reset() <span class="cov0" title="0">{
        *x = Auth_Dingtalk{}
        mi := &amp;file_conf_conf_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Auth_Dingtalk) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Auth_Dingtalk) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Auth_Dingtalk) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Auth_Dingtalk.ProtoReflect.Descriptor instead.
func (*Auth_Dingtalk) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{4, 1}
}</span>

func (x *Auth_Dingtalk) GetEndpoint() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Endpoint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth_Dingtalk) GetAppKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AppKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth_Dingtalk) GetAppSecret() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AppSecret
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth_Dingtalk) GetTimeout() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timeout
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth_Dingtalk) GetMaxConcurrent() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxConcurrent
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_conf_conf_proto protoreflect.FileDescriptor

const file_conf_conf_proto_rawDesc = "" +
        "\n" +
        "\x0fconf/conf.proto\x12\n" +
        "kratos.api\x1a\x1egoogle/protobuf/duration.proto\"\xa6\x01\n" +
        "\tBootstrap\x12*\n" +
        "\x06server\x18\x01 \x01(\v2\x12.kratos.api.ServerR\x06server\x12$\n" +
        "\x04data\x18\x02 \x01(\v2\x10.kratos.api.DataR\x04data\x12!\n" +
        "\x03app\x18\x03 \x01(\v2\x0f.kratos.api.AppR\x03app\x12$\n" +
        "\x04auth\x18\x04 \x01(\v2\x10.kratos.api.AuthR\x04auth\"\xb8\x02\n" +
        "\x06Server\x12+\n" +
        "\x04http\x18\x01 \x01(\v2\x17.kratos.api.Server.HTTPR\x04http\x12+\n" +
        "\x04grpc\x18\x02 \x01(\v2\x17.kratos.api.Server.GRPCR\x04grpc\x1ai\n" +
        "\x04HTTP\x12\x18\n" +
        "\anetwork\x18\x01 \x01(\tR\anetwork\x12\x12\n" +
        "\x04addr\x18\x02 \x01(\tR\x04addr\x123\n" +
        "\atimeout\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\atimeout\x1ai\n" +
        "\x04GRPC\x12\x18\n" +
        "\anetwork\x18\x01 \x01(\tR\anetwork\x12\x12\n" +
        "\x04addr\x18\x02 \x01(\tR\x04addr\x123\n" +
        "\atimeout\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\atimeout\"\x97\t\n" +
        "\x04Data\x125\n" +
        "\bdatabase\x18\x01 \x01(\v2\x19.kratos.api.Data.DatabaseR\bdatabase\x12B\n" +
        "\rdatabase_sync\x18\x02 \x01(\v2\x1d.kratos.api.Data.DatabaseSyncR\fdatabaseSync\x12,\n" +
        "\x05redis\x18\x03 \x01(\v2\x16.kratos.api.Data.RedisR\x05redis\x12)\n" +
        "\x04etcd\x18\x04 \x01(\v2\x15.kratos.api.Data.EtcdR\x04etcd\x1a\x8d\x02\n" +
        "\bDatabase\x12\x16\n" +
        "\x06driver\x18\x01 \x01(\tR\x06driver\x12\x16\n" +
        "\x06source\x18\x02 \x01(\tR\x06source\x12$\n" +
        "\x0emax_open_conns\x18\x03 \x01(\x05R\fmaxOpenConns\x12$\n" +
        "\x0emax_idle_conns\x18\x04 \x01(\x05R\fmaxIdleConns\x12*\n" +
        "\x11conn_max_lifetime\x18\x05 \x01(\tR\x0fconnMaxLifetime\x12\x10\n" +
        "\x03tag\x18\x06 \x01(\tR\x03tag\x12\x1d\n" +
        "\n" +
        "source_key\x18\a \x01(\tR\tsourceKey\x12\x10\n" +
        "\x03env\x18\b \x01(\tR\x03env\x12\x16\n" +
        "\x06enable\x18\t \x01(\bR\x06enable\x1a\xf9\x01\n" +
        "\fDatabaseSync\x12\x16\n" +
        "\x06driver\x18\x01 \x01(\tR\x06driver\x12\x16\n" +
        "\x06source\x18\x02 \x01(\tR\x06source\x12$\n" +
        "\x0emax_open_conns\x18\x03 \x01(\x05R\fmaxOpenConns\x12$\n" +
        "\x0emax_idle_conns\x18\x04 \x01(\x05R\fmaxIdleConns\x12*\n" +
        "\x11conn_max_lifetime\x18\x05 \x01(\tR\x0fconnMaxLifetime\x12\x10\n" +
        "\x03tag\x18\x06 \x01(\tR\x03tag\x12\x1d\n" +
        "\n" +
        "source_key\x18\a \x01(\tR\tsourceKey\x12\x10\n" +
        "\x03env\x18\b \x01(\tR\x03env\x1a\xf7\x01\n" +
        "\x05Redis\x12\x18\n" +
        "\anetwork\x18\x01 \x01(\tR\anetwork\x12\x12\n" +
        "\x04addr\x18\x02 \x01(\tR\x04addr\x12\x1a\n" +
        "\bpassword\x18\x03 \x01(\tR\bpassword\x12\x0e\n" +
        "\x02db\x18\x04 \x01(\x05R\x02db\x12\x16\n" +
        "\x06enable\x18\x05 \x01(\bR\x06enable\x12&lt;\n" +
        "\fread_timeout\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\vreadTimeout\x12&gt;\n" +
        "\rwrite_timeout\x18\a \x01(\v2\x19.google.protobuf.DurationR\fwriteTimeout\x1a\xb4\x01\n" +
        "\x04Etcd\x12\x1c\n" +
        "\tendpoints\x18\x01 \x03(\tR\tendpoints\x12!\n" +
        "\fdial_timeout\x18\x02 \x01(\tR\vdialTimeout\x12#\n" +
        "\rconfig_prefix\x18\x03 \x01(\tR\fconfigPrefix\x12.\n" +
        "\x13enable_config_watch\x18\x04 \x01(\bR\x11enableConfigWatch\x12\x16\n" +
        "\x06enable\x18\x05 \x01(\bR\x06enable\"\x8c\x03\n" +
        "\x03App\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
        "\x04name\x18\x02 \x01(\tR\x04name\x12\x18\n" +
        "\aversion\x18\x03 \x01(\tR\aversion\x12\x10\n" +
        "\x03env\x18\x04 \x01(\tR\x03env\x12\x1b\n" +
        "\tlog_level\x18\x05 \x01(\tR\blogLevel\x12\x17\n" +
        "\alog_out\x18\x06 \x01(\tR\x06logOut\x12\x1f\n" +
        "\vapp_package\x18\a \x01(\tR\n" +
        "appPackage\x12\x15\n" +
        "\x06app_id\x18\b \x01(\tR\x05appId\x12\x1d\n" +
        "\n" +
        "app_secret\x18\t \x01(\tR\tappSecret\x12(\n" +
        "\x10third_company_id\x18\n" +
        " \x01(\tR\x0ethirdCompanyId\x12!\n" +
        "\fplatform_ids\x18\v \x01(\tR\vplatformIds\x12\x1d\n" +
        "\n" +
        "company_id\x18\f \x01(\tR\tcompanyId\x12\x1d\n" +
        "\n" +
        "access_key\x18\r \x01(\tR\taccessKey\x12\x1d\n" +
        "\n" +
        "secret_key\x18\x0e \x01(\tR\tsecretKey\"\xb3\x03\n" +
        "\x04Auth\x12/\n" +
        "\x06wpsapp\x18\x01 \x01(\v2\x17.kratos.api.Auth.WpsappR\x06wpsapp\x125\n" +
        "\bdingtalk\x18\x02 \x01(\v2\x19.kratos.api.Auth.DingtalkR\bdingtalk\x1a\xa1\x01\n" +
        "\x06Wpsapp\x12\x1b\n" +
        "\tclient_id\x18\x01 \x01(\tR\bclientId\x12#\n" +
        "\rclient_secret\x18\x02 \x01(\tR\fclientSecret\x12\x19\n" +
        "\bauth_url\x18\x03 \x01(\tR\aauthUrl\x12\x1b\n" +
        "\tauth_path\x18\x04 \x01(\tR\bauthPath\x12\x1d\n" +
        "\n" +
        "grant_type\x18\x05 \x01(\tR\tgrantType\x1a\x9e\x01\n" +
        "\bDingtalk\x12\x1a\n" +
        "\bendpoint\x18\x01 \x01(\tR\bendpoint\x12\x17\n" +
        "\aapp_key\x18\x02 \x01(\tR\x06appKey\x12\x1d\n" +
        "\n" +
        "app_secret\x18\x03 \x01(\tR\tappSecret\x12\x18\n" +
        "\atimeout\x18\x04 \x01(\tR\atimeout\x12$\n" +
        "\rmaxConcurrent\x18\x05 \x01(\x03R\rmaxConcurrentB\x1eZ\x1cnancalacc/internal/conf;confb\x06proto3"

var (
        file_conf_conf_proto_rawDescOnce sync.Once
        file_conf_conf_proto_rawDescData []byte
)

func file_conf_conf_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_conf_conf_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_conf_conf_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_conf_conf_proto_rawDesc), len(file_conf_conf_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_conf_conf_proto_rawDescData</span>
}

var file_conf_conf_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_conf_conf_proto_goTypes = []any{
        (*Bootstrap)(nil),           // 0: kratos.api.Bootstrap
        (*Server)(nil),              // 1: kratos.api.Server
        (*Data)(nil),                // 2: kratos.api.Data
        (*App)(nil),                 // 3: kratos.api.App
        (*Auth)(nil),                // 4: kratos.api.Auth
        (*Server_HTTP)(nil),         // 5: kratos.api.Server.HTTP
        (*Server_GRPC)(nil),         // 6: kratos.api.Server.GRPC
        (*Data_Database)(nil),       // 7: kratos.api.Data.Database
        (*Data_DatabaseSync)(nil),   // 8: kratos.api.Data.DatabaseSync
        (*Data_Redis)(nil),          // 9: kratos.api.Data.Redis
        (*Data_Etcd)(nil),           // 10: kratos.api.Data.Etcd
        (*Auth_Wpsapp)(nil),         // 11: kratos.api.Auth.Wpsapp
        (*Auth_Dingtalk)(nil),       // 12: kratos.api.Auth.Dingtalk
        (*durationpb.Duration)(nil), // 13: google.protobuf.Duration
}
var file_conf_conf_proto_depIdxs = []int32{
        1,  // 0: kratos.api.Bootstrap.server:type_name -&gt; kratos.api.Server
        2,  // 1: kratos.api.Bootstrap.data:type_name -&gt; kratos.api.Data
        3,  // 2: kratos.api.Bootstrap.app:type_name -&gt; kratos.api.App
        4,  // 3: kratos.api.Bootstrap.auth:type_name -&gt; kratos.api.Auth
        5,  // 4: kratos.api.Server.http:type_name -&gt; kratos.api.Server.HTTP
        6,  // 5: kratos.api.Server.grpc:type_name -&gt; kratos.api.Server.GRPC
        7,  // 6: kratos.api.Data.database:type_name -&gt; kratos.api.Data.Database
        8,  // 7: kratos.api.Data.database_sync:type_name -&gt; kratos.api.Data.DatabaseSync
        9,  // 8: kratos.api.Data.redis:type_name -&gt; kratos.api.Data.Redis
        10, // 9: kratos.api.Data.etcd:type_name -&gt; kratos.api.Data.Etcd
        11, // 10: kratos.api.Auth.wpsapp:type_name -&gt; kratos.api.Auth.Wpsapp
        12, // 11: kratos.api.Auth.dingtalk:type_name -&gt; kratos.api.Auth.Dingtalk
        13, // 12: kratos.api.Server.HTTP.timeout:type_name -&gt; google.protobuf.Duration
        13, // 13: kratos.api.Server.GRPC.timeout:type_name -&gt; google.protobuf.Duration
        13, // 14: kratos.api.Data.Redis.read_timeout:type_name -&gt; google.protobuf.Duration
        13, // 15: kratos.api.Data.Redis.write_timeout:type_name -&gt; google.protobuf.Duration
        16, // [16:16] is the sub-list for method output_type
        16, // [16:16] is the sub-list for method input_type
        16, // [16:16] is the sub-list for extension type_name
        16, // [16:16] is the sub-list for extension extendee
        0,  // [0:16] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_conf_conf_proto_init() }</span>
func file_conf_conf_proto_init() <span class="cov0" title="0">{
        if File_conf_conf_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_conf_conf_proto_rawDesc), len(file_conf_conf_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   13,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_conf_conf_proto_goTypes,
                DependencyIndexes: file_conf_conf_proto_depIdxs,
                MessageInfos:      file_conf_conf_proto_msgTypes,
        }.Build()
        File_conf_conf_proto = out.File
        file_conf_conf_proto_goTypes = nil
        file_conf_conf_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package conf

import (
        "fmt"
        "os"
        "sync"

        "github.com/go-kratos/kratos/v2/config"
        "github.com/go-kratos/kratos/v2/config/env"
        "github.com/go-kratos/kratos/v2/log"
)

var (
        envConfig config.Config
        onceEnv   sync.Once
        logger    log.Logger
)

// InitEnvConfig 初始化环境变量配置
func InitEnvConfig(l log.Logger) <span class="cov0" title="0">{
        logger = l
}</span>

// GetEnv 获取环境变量值，支持默认值
func GetEnv(key string) (string, error) <span class="cov0" title="0">{
        // 首先尝试从系统环境变量获取
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value, nil
        }</span>

        // 如果系统环境变量不存在，尝试从配置的环境变量源获取
        <span class="cov0" title="0">onceEnv.Do(func() </span><span class="cov0" title="0">{
                envSource := env.NewSource()
                envConfig = config.New(
                        config.WithSource(envSource),
                )
                if err := envConfig.Load(); err != nil </span><span class="cov0" title="0">{
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(log.LevelError, "failed to load env config", "error", err)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        })

        <span class="cov0" title="0">if envConfig == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("environment variable %s not found", key)
        }</span>

        <span class="cov0" title="0">value := envConfig.Value(key)
        if value == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("environment variable %s not found", key)
        }</span>

        <span class="cov0" title="0">str, err := value.String()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get string value for %s: %w", key, err)
        }</span>
        <span class="cov0" title="0">return str, nil</span>
}

// GetEnvWithDefault 获取环境变量值，如果不存在则返回默认值
func GetEnvWithDefault(key, defaultValue string) string <span class="cov0" title="0">{
        value, err := GetEnv(key)
        if err != nil </span><span class="cov0" title="0">{
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(log.LevelWarn, "environment variable not found, using default",
                                "key", key, "default", defaultValue, "error", err)
                }</span>
                <span class="cov0" title="0">return defaultValue</span>
        }
        <span class="cov0" title="0">return value</span>
}

// MustGetEnv 获取环境变量值，如果不存在则panic
func MustGetEnv(key string) string <span class="cov0" title="0">{
        value, err := GetEnv(key)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("required environment variable %s not found: %v", key, err))</span>
        }
        <span class="cov0" title="0">return value</span>
}

// ValidateRequiredEnvVars 验证必需的环境变量是否存在
func ValidateRequiredEnvVars(requiredKeys []string) error <span class="cov0" title="0">{
        var missingKeys []string

        for _, key := range requiredKeys </span><span class="cov0" title="0">{
                if _, err := GetEnv(key); err != nil </span><span class="cov0" title="0">{
                        missingKeys = append(missingKeys, key)
                }</span>
        }

        <span class="cov0" title="0">if len(missingKeys) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing required environment variables: %v", missingKeys)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package conf

import (
        "fmt"
        "log"
)

// ExampleUsage 展示如何正确使用配置系统
func ExampleUsage() <span class="cov0" title="0">{
        // 1. 加载应用配置（使用conf.Load()）
        // 这会加载配置文件和环境变量（KRATOS_前缀）
        bootstrap, err := Load("configs/config.yaml")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>

        // 2. 获取应用配置
        <span class="cov0" title="0">fmt.Printf("Server HTTP Address: %s\n", bootstrap.Server.Http.Addr)
        fmt.Printf("Database Source: %s\n", bootstrap.Data.Database.Source)

        // 3. 获取运行时环境变量（使用envvars.go）
        // 这些变量不需要映射到配置结构，只需要在运行时获取

        // 获取加密盐值
        salt, err := GetEnv("ENCRYPTION_SALT")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: ENCRYPTION_SALT not found: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Encryption Salt: %s\n", salt)
        }</span>

        // 获取带默认值的环境变量
        <span class="cov0" title="0">appUID := GetEnvWithDefault("APP_UID", "nancalacc-default")
        fmt.Printf("App UID: %s\n", appUID)

        // 获取普通环境变量
        dbSource, err := GetEnv("DATABASE_SOURCE")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: DATABASE_SOURCE not found: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Database Source: %s\n", dbSource)
        }</span>

        // 4. 验证必需的环境变量
        <span class="cov0" title="0">requiredVars := []string{"ENCRYPTION_SALT", "APP_SECRET"}
        if err := ValidateRequiredEnvVars(requiredVars); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Missing required environment variables: %v", err)
        }</span>
}

// 环境变量使用指南：
//
// 1. 应用配置（使用conf.Load()）：
//    - 服务器配置、数据库配置等
//    - 只从配置文件加载，不支持环境变量覆盖
//    - 例如：configs/config.yaml
//
// 2. 运行时环境变量（使用envvars.go）：
//    - 加密密钥、API密钥等敏感信息
//    - 不需要映射到配置结构
//    - 例如：ENCRYPTION_SALT=my-secret-salt
//
// 3. 环境变量优先级：
//    - 系统环境变量 &gt; 配置文件
//
// 4. 最佳实践：
//    - 敏感信息使用环境变量
//    - 应用配置使用配置文件
//    - 开发环境使用默认值
//    - 生产环境使用必需变量验证
</pre>
		
		<pre class="file" id="file18" style="display: none">package conf

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "path/filepath"
        "strings"
        "sync"
        "time"

        etcdConfig "github.com/go-kratos/kratos/contrib/config/etcd/v2"
        "gopkg.in/yaml.v3"

        "github.com/go-kratos/kratos/v2/config"
        "github.com/go-kratos/kratos/v2/config/env"
        "github.com/go-kratos/kratos/v2/config/file"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/google/go-cmp/cmp"
        clientv3 "go.etcd.io/etcd/client/v3"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/testing/protocmp"
)

var (
        globalConf  *Bootstrap
        confLock    sync.RWMutex
        once        sync.Once
        etcdClient  *clientv3.Client // 全局ETCD客户端
        etcdSource  config.Source    // 全局ETCD配置源
        cancelWatch context.CancelFunc
)

// Load loads the configuration from file and etcd.
func Load(configPath string) (*Bootstrap, error) <span class="cov0" title="0">{
        var loadErr error
        once.Do(func() </span><span class="cov0" title="0">{
                // 1. 首先加载文件配置
                fileConf, err := loadFileConfig(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        loadErr = err
                        return
                }</span>

                // 2. 如果配置了ETCD，尝试加载ETCD配置
                <span class="cov0" title="0">if fileConf.Data != nil &amp;&amp; fileConf.Data.Etcd != nil &amp;&amp; fileConf.Data.Etcd.Enable &amp;&amp; len(fileConf.Data.Etcd.Endpoints) &gt; 0 </span><span class="cov0" title="0">{
                        etcdConf, cli, src, err := loadEtcdConfig(fileConf)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Warnf("Failed to load etcd config: %v, using file config only", err)
                                setGlobalConfig(fileConf)
                                return
                        }</span>

                        // 保存ETCD客户端和source
                        <span class="cov0" title="0">etcdClient = cli
                        etcdSource = src

                        // 3. 合并配置(ETCD配置优先)
                        merged := mergeConfigs(fileConf, etcdConf)
                        setGlobalConfig(merged)

                        // 4. 如果启用配置监听，启动监听协程
                        if fileConf.Data.Etcd.EnableConfigWatch </span><span class="cov0" title="0">{
                                ctx, cancel := context.WithCancel(context.Background())
                                cancelWatch = cancel
                                go watchEtcdConfigChanges(ctx, src, merged)
                        }</span>
                } else<span class="cov0" title="0"> {
                        setGlobalConfig(fileConf)
                }</span>
        })

        <span class="cov0" title="0">if loadErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load configuration: %w", loadErr)
        }</span>

        <span class="cov0" title="0">return Get(), nil</span>
}

// Close 释放资源
func Close() <span class="cov0" title="0">{
        if cancelWatch != nil </span><span class="cov0" title="0">{
                cancelWatch()
        }</span>
        <span class="cov0" title="0">if etcdClient != nil </span><span class="cov0" title="0">{
                etcdClient.Close()
        }</span>
}

// loadFileConfig 从文件加载配置
func loadFileConfig(configPath string) (*Bootstrap, error) <span class="cov0" title="0">{
        fmt.Printf("load file config: %s\n", configPath)
        fileSource := file.NewSource(configPath)
        fileConf := config.New(
                config.WithSource(
                        fileSource,
                        env.NewSource("KRATOS_"), // 支持环境变量覆盖
                ),
        )

        if err := fileConf.Load(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load file config: %w", err)
        }</span>

        <span class="cov0" title="0">var bc Bootstrap
        if err := fileConf.Scan(&amp;bc); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to scan file config: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;bc, nil</span>
}

// loadEtcdConfig 从ETCD加载配置，返回配置、客户端和source
func loadEtcdConfig(baseConf *Bootstrap) (*Bootstrap, *clientv3.Client, config.Source, error) <span class="cov0" title="0">{
        fmt.Printf("load etcd config: %+vv\n", baseConf.Data.Etcd)
        // 1. 创建ETCD客户端
        cli, err := clientv3.New(clientv3.Config{
                Endpoints:   baseConf.Data.Etcd.Endpoints,
                DialTimeout: parseDurationToTime(baseConf.Data.Etcd.DialTimeout),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("create etcd client failed: %w", err)
        }</span>
        // 2. 创建ETCD配置源
        <span class="cov0" title="0">source, err := etcdConfig.New(cli,
                etcdConfig.WithPath(baseConf.Data.Etcd.ConfigPrefix),
                etcdConfig.WithPrefix(true),
        )
        if err != nil </span><span class="cov0" title="0">{
                cli.Close() // 创建失败时关闭客户端
                return nil, nil, nil, fmt.Errorf("create etcd config source failed: %w", err)
        }</span>

        // 3. 加载配置
        <span class="cov0" title="0">conf := config.New(config.WithSource(source))
        if err := conf.Load(); err != nil </span><span class="cov0" title="0">{
                cli.Close() // 加载失败时关闭客户端
                return nil, nil, nil, fmt.Errorf("load etcd config failed: %w", err)
        }</span>

        <span class="cov0" title="0">var etcdBc Bootstrap
        if err := conf.Scan(&amp;etcdBc); err != nil </span><span class="cov0" title="0">{
                cli.Close() // 解析失败时关闭客户端
                return nil, nil, nil, fmt.Errorf("scan etcd config failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;etcdBc, cli, source, nil</span>
}

// watchEtcdConfigChanges 监听ETCD配置变更
func watchEtcdConfigChanges(ctx context.Context, source config.Source, baseConf *Bootstrap) <span class="cov0" title="0">{
        log.Info("watchEtcdConfigChanges watcher start")

        defer log.Info("[TEST] ETCD watcher exit")
        watcher, err := source.Watch()
        log.Infof("watcher: %+v, err: %+v", watcher, err)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to create config watcher: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer watcher.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Info("Config watcher stopped by context")
                        return</span>
                default:<span class="cov0" title="0">
                        log.Debug("Waiting for next config change...")
                        values, err := watcher.Next()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("watchEtcdConfigChanges watcher err: %+v", err)
                                if errors.Is(err, context.Canceled) </span><span class="cov0" title="0">{
                                        log.Info("Config watcher stopped normally")
                                        return
                                }</span>
                                <span class="cov0" title="0">log.Errorf("Failed to watch next config: %v", err)
                                // select {
                                // case &lt;-time.After(5 * time.Second): // 带退避的重试
                                // case &lt;-ctx.Done():
                                //         return
                                // }
                                continue</span>
                        }
                        <span class="cov0" title="0">log.Debugf("[TEST] 收到变更事件:\nKey: %s\nValue: %s\nVersion: %d",
                                string(values[0].Key),
                                string(values[0].Value), 100)
                        var etcdBc Bootstrap
                        if err := unmarshalKeyValues(values, &amp;etcdBc); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("Failed to scan changed config: %v", err)
                                continue</span>
                        }

                        // 合并配置并原子更新
                        <span class="cov0" title="0">merged := mergeConfigs(baseConf, &amp;etcdBc)
                        setGlobalConfig(merged)
                        log.Info("Configuration updated from etcd")
                        log.Infof("Global config updated changes: %s", diffConfigs(baseConf, &amp;etcdBc))</span> // 变更差异日志
                }
        }
}

func diffConfigs(old, new *Bootstrap) string <span class="cov0" title="0">{
        return cmp.Diff(old, new, protocmp.Transform())
}</span>

// etcdctl put /configs/app.json '{"server":{"port":8080}}'
func unmarshalKeyValues(kvs []*config.KeyValue, target interface{}) error <span class="cov0" title="0">{
        if len(kvs) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("empty config values")
        }</span>
        <span class="cov0" title="0">ext := filepath.Ext(kvs[0].Key)        // 获取后缀如 ".json"
        format := strings.TrimPrefix(ext, ".") // 去掉点

        if len(format) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported format: %s", format)
        }</span>
        // format := strings.ToLower(kvs[0].Format)
        <span class="cov0" title="0">data := kvs[0].Value
        switch format </span>{
        case "json":<span class="cov0" title="0">
                if err := json.Unmarshal(data, target); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("json unmarshal failed: %w", err)
                }</span>
        case "yaml":<span class="cov0" title="0">
                if err := yaml.Unmarshal(data, target); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("yaml unmarshal failed: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported format: %s", format)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// setGlobalConfig 线程安全地设置全局配置
func setGlobalConfig(conf *Bootstrap) <span class="cov0" title="0">{
        confLock.Lock()
        defer confLock.Unlock()
        globalConf = conf
}</span>

// Get 线程安全地获取全局配置
func Get() *Bootstrap <span class="cov0" title="0">{
        confLock.RLock()
        defer confLock.RUnlock()
        return globalConf
}</span>

// parseDurationToTime 将字符串持续时间转换为time.Duration
func parseDurationToTime(durStr string) time.Duration <span class="cov0" title="0">{
        if durStr == "" </span><span class="cov0" title="0">{
                return 5 * time.Second // 默认超时时间
        }</span>
        <span class="cov0" title="0">d, err := time.ParseDuration(durStr)
        if err != nil </span><span class="cov0" title="0">{
                return 5 * time.Second // 默认超时时间
        }</span>
        <span class="cov0" title="0">return d</span>
}

// mergeConfigs merges two configurations with etcdConfig taking precedence
func mergeConfigs(fileConfig, etcdConfig *Bootstrap) *Bootstrap <span class="cov0" title="0">{
        // Create a deep copy of the file config
        merged := proto.Clone(fileConfig).(*Bootstrap)

        // Merge logic for each section
        if etcdConfig.Server != nil </span><span class="cov0" title="0">{
                if merged.Server == nil </span><span class="cov0" title="0">{
                        merged.Server = &amp;Server{}
                }</span>
                <span class="cov0" title="0">mergeServer(merged.Server, etcdConfig.Server)</span>
        }

        <span class="cov0" title="0">if etcdConfig.Data != nil </span><span class="cov0" title="0">{
                if merged.Data == nil </span><span class="cov0" title="0">{
                        merged.Data = &amp;Data{}
                }</span>
                <span class="cov0" title="0">mergeData(merged.Data, etcdConfig.Data)</span>
        }

        <span class="cov0" title="0">if etcdConfig.App != nil </span><span class="cov0" title="0">{
                if merged.App == nil </span><span class="cov0" title="0">{
                        merged.App = &amp;App{}
                }</span>
                <span class="cov0" title="0">mergeApp(merged.App, etcdConfig.App)</span>
        }

        <span class="cov0" title="0">return merged</span>
}

// Helper functions to merge each configuration section
func mergeServer(dst, src *Server) <span class="cov0" title="0">{
        if src.Http != nil </span><span class="cov0" title="0">{
                if dst.Http == nil </span><span class="cov0" title="0">{
                        dst.Http = &amp;Server_HTTP{}
                }</span>
                <span class="cov0" title="0">if src.Http.Network != "" </span><span class="cov0" title="0">{
                        dst.Http.Network = src.Http.Network
                }</span>
                <span class="cov0" title="0">if src.Http.Addr != "" </span><span class="cov0" title="0">{
                        dst.Http.Addr = src.Http.Addr
                }</span>
                <span class="cov0" title="0">if src.Http.Timeout != nil </span><span class="cov0" title="0">{
                        dst.Http.Timeout = src.Http.Timeout
                }</span>
        }
        <span class="cov0" title="0">if src.Grpc != nil </span><span class="cov0" title="0">{
                if dst.Grpc == nil </span><span class="cov0" title="0">{
                        dst.Grpc = &amp;Server_GRPC{}
                }</span>
                <span class="cov0" title="0">if src.Grpc.Network != "" </span><span class="cov0" title="0">{
                        dst.Grpc.Network = src.Grpc.Network
                }</span>
                <span class="cov0" title="0">if src.Grpc.Addr != "" </span><span class="cov0" title="0">{
                        dst.Grpc.Addr = src.Grpc.Addr
                }</span>
                <span class="cov0" title="0">if src.Grpc.Timeout != nil </span><span class="cov0" title="0">{
                        dst.Grpc.Timeout = src.Grpc.Timeout
                }</span>
        }
}

func mergeData(dst, src *Data) <span class="cov0" title="0">{
        if src.Database != nil </span><span class="cov0" title="0">{
                if dst.Database == nil </span><span class="cov0" title="0">{
                        dst.Database = &amp;Data_Database{}
                }</span>
                <span class="cov0" title="0">if src.Database.Driver != "" </span><span class="cov0" title="0">{
                        dst.Database.Driver = src.Database.Driver
                }</span>
                <span class="cov0" title="0">if src.Database.Source != "" </span><span class="cov0" title="0">{
                        dst.Database.Source = src.Database.Source
                }</span>
                <span class="cov0" title="0">if src.Database.Tag != "" </span><span class="cov0" title="0">{
                        dst.Database.Tag = src.Database.Tag
                }</span>
        }
        <span class="cov0" title="0">if src.DatabaseSync != nil </span><span class="cov0" title="0">{
                if dst.DatabaseSync == nil </span><span class="cov0" title="0">{
                        dst.DatabaseSync = &amp;Data_DatabaseSync{}
                }</span>
                <span class="cov0" title="0">if src.DatabaseSync.Driver != "" </span><span class="cov0" title="0">{
                        dst.DatabaseSync.Driver = src.DatabaseSync.Driver
                }</span>
                <span class="cov0" title="0">if src.DatabaseSync.Source != "" </span><span class="cov0" title="0">{
                        dst.DatabaseSync.Source = src.DatabaseSync.Source
                }</span>
                <span class="cov0" title="0">if src.DatabaseSync.Tag != "" </span><span class="cov0" title="0">{
                        dst.DatabaseSync.Tag = src.DatabaseSync.Tag
                }</span>
                <span class="cov0" title="0">if src.DatabaseSync.MaxOpenConns != 0 </span><span class="cov0" title="0">{
                        dst.DatabaseSync.MaxOpenConns = src.DatabaseSync.MaxOpenConns
                }</span>
                <span class="cov0" title="0">if src.DatabaseSync.MaxIdleConns != 0 </span><span class="cov0" title="0">{
                        dst.DatabaseSync.MaxIdleConns = src.DatabaseSync.MaxIdleConns
                }</span>
                <span class="cov0" title="0">if src.DatabaseSync.SourceKey != "" </span><span class="cov0" title="0">{
                        dst.DatabaseSync.SourceKey = src.DatabaseSync.SourceKey
                }</span>
        }
        <span class="cov0" title="0">if src.Redis != nil </span><span class="cov0" title="0">{
                if dst.Redis == nil </span><span class="cov0" title="0">{
                        dst.Redis = &amp;Data_Redis{}
                }</span>
                <span class="cov0" title="0">if src.Redis.Network != "" </span><span class="cov0" title="0">{
                        dst.Redis.Network = src.Redis.Network
                }</span>
                <span class="cov0" title="0">if src.Redis.Addr != "" </span><span class="cov0" title="0">{
                        dst.Redis.Addr = src.Redis.Addr
                }</span>
                <span class="cov0" title="0">if src.Redis.Password != "" </span><span class="cov0" title="0">{
                        dst.Redis.Password = src.Redis.Password
                }</span>
                <span class="cov0" title="0">if src.Redis.Db != 0 </span><span class="cov0" title="0">{
                        dst.Redis.Db = src.Redis.Db
                }</span>
                <span class="cov0" title="0">if src.Redis.ReadTimeout != nil </span><span class="cov0" title="0">{
                        dst.Redis.ReadTimeout = src.Redis.ReadTimeout
                }</span>
                <span class="cov0" title="0">if src.Redis.WriteTimeout != nil </span><span class="cov0" title="0">{
                        dst.Redis.WriteTimeout = src.Redis.WriteTimeout
                }</span>
        }
        <span class="cov0" title="0">if src.Etcd != nil </span><span class="cov0" title="0">{
                if dst.Etcd == nil </span><span class="cov0" title="0">{
                        dst.Etcd = &amp;Data_Etcd{}
                }</span>
                <span class="cov0" title="0">if len(src.Etcd.Endpoints) &gt; 0 </span><span class="cov0" title="0">{
                        dst.Etcd.Endpoints = src.Etcd.Endpoints
                }</span>
                <span class="cov0" title="0">if src.Etcd.DialTimeout != "" </span><span class="cov0" title="0">{
                        dst.Etcd.DialTimeout = src.Etcd.DialTimeout
                }</span>
                <span class="cov0" title="0">if src.Etcd.ConfigPrefix != "" </span><span class="cov0" title="0">{
                        dst.Etcd.ConfigPrefix = src.Etcd.ConfigPrefix
                }</span>
                <span class="cov0" title="0">dst.Etcd.EnableConfigWatch = src.Etcd.EnableConfigWatch</span>
        }
}

func mergeApp(dst, src *App) <span class="cov0" title="0">{
        if src.Id != "" </span><span class="cov0" title="0">{
                dst.Id = src.Id
        }</span>
        <span class="cov0" title="0">if src.Name != "" </span><span class="cov0" title="0">{
                dst.Name = src.Name
        }</span>
        <span class="cov0" title="0">if src.Version != "" </span><span class="cov0" title="0">{
                dst.Version = src.Version
        }</span>
        <span class="cov0" title="0">if src.Env != "" </span><span class="cov0" title="0">{
                dst.Env = src.Env
        }</span>
        <span class="cov0" title="0">if src.LogLevel != "" </span><span class="cov0" title="0">{
                dst.LogLevel = src.LogLevel
        }</span>
        <span class="cov0" title="0">if src.LogOut != "" </span><span class="cov0" title="0">{
                dst.LogOut = src.LogOut
        }</span>
        <span class="cov0" title="0">if src.AppPackage != "" </span><span class="cov0" title="0">{
                dst.AppPackage = src.AppPackage
        }</span>
        <span class="cov0" title="0">if src.AppId != "" </span><span class="cov0" title="0">{
                dst.AppId = src.AppId
        }</span>
        <span class="cov0" title="0">if src.AppSecret != "" </span><span class="cov0" title="0">{
                dst.AppSecret = src.AppSecret
        }</span>
        <span class="cov0" title="0">if src.ThirdCompanyId != "" </span><span class="cov0" title="0">{
                dst.ThirdCompanyId = src.ThirdCompanyId
        }</span>
        <span class="cov0" title="0">if src.PlatformIds != "" </span><span class="cov0" title="0">{
                dst.PlatformIds = src.PlatformIds
        }</span>
        <span class="cov0" title="0">if src.CompanyId != "" </span><span class="cov0" title="0">{
                dst.CompanyId = src.CompanyId
        }</span>
        <span class="cov0" title="0">if src.AccessKey != "" </span><span class="cov0" title="0">{
                dst.AccessKey = src.AccessKey
        }</span>
        <span class="cov0" title="0">if src.SecretKey != "" </span><span class="cov0" title="0">{
                dst.SecretKey = src.SecretKey
        }</span>
}

func mergeAuth(dst, src *Auth) <span class="cov0" title="0">{
        if src.Wpsapp != nil </span><span class="cov0" title="0">{
                if dst.Wpsapp == nil </span><span class="cov0" title="0">{
                        dst.Wpsapp = &amp;Auth_Wpsapp{}
                }</span>
                <span class="cov0" title="0">if src.Wpsapp.ClientId != "" </span><span class="cov0" title="0">{
                        dst.Wpsapp.ClientId = src.Wpsapp.ClientId
                }</span>
                <span class="cov0" title="0">if src.Wpsapp.ClientSecret != "" </span><span class="cov0" title="0">{
                        dst.Wpsapp.ClientSecret = src.Wpsapp.ClientSecret
                }</span>
                <span class="cov0" title="0">if src.Wpsapp.AuthUrl != "" </span><span class="cov0" title="0">{
                        dst.Wpsapp.AuthUrl = src.Wpsapp.AuthUrl
                }</span>
                <span class="cov0" title="0">if src.Wpsapp.AuthPath != "" </span><span class="cov0" title="0">{
                        dst.Wpsapp.AuthPath = src.Wpsapp.AuthPath
                }</span>
        }
        <span class="cov0" title="0">if src.Dingtalk != nil </span><span class="cov0" title="0">{
                if dst.Dingtalk == nil </span><span class="cov0" title="0">{
                        dst.Dingtalk = &amp;Auth_Dingtalk{}
                }</span>
                <span class="cov0" title="0">if src.Dingtalk.Endpoint != "" </span><span class="cov0" title="0">{
                        dst.Dingtalk.Endpoint = src.Dingtalk.Endpoint
                }</span>
                <span class="cov0" title="0">if src.Dingtalk.AppKey != "" </span><span class="cov0" title="0">{
                        dst.Dingtalk.AppKey = src.Dingtalk.AppKey
                }</span>
                <span class="cov0" title="0">if src.Dingtalk.AppSecret != "" </span><span class="cov0" title="0">{
                        dst.Dingtalk.AppSecret = src.Dingtalk.AppSecret
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package conf

import (
        "fmt"
        "net"
        "net/url"
        "time"

        "github.com/go-kratos/kratos/v2/log"
)

// ConfigValidator 配置验证器
type ConfigValidator struct {
        logger log.Logger
}

// NewConfigValidator 创建新的配置验证器
func NewConfigValidator(l log.Logger) *ConfigValidator <span class="cov0" title="0">{
        return &amp;ConfigValidator{
                logger: l,
        }
}</span>

// ValidateBootstrap 验证Bootstrap配置
func (v *ConfigValidator) ValidateBootstrap(b *Bootstrap) error <span class="cov0" title="0">{
        if err := v.validateServer(b.Server); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("server config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if err := v.validateData(b.Data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("data config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if err := v.validateApp(b.App); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("app config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if err := v.validateAuth(b.Auth); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("auth config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateServer 验证服务器配置
func (v *ConfigValidator) validateServer(s *Server) error <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("server config is nil")
        }</span>

        // 验证HTTP配置
        <span class="cov0" title="0">if s.Http != nil </span><span class="cov0" title="0">{
                if err := v.validateHTTP(s.Http); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("http config validation failed: %w", err)
                }</span>
        }

        // 验证GRPC配置
        <span class="cov0" title="0">if s.Grpc != nil </span><span class="cov0" title="0">{
                if err := v.validateGRPC(s.Grpc); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("grpc config validation failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateHTTP 验证HTTP配置
func (v *ConfigValidator) validateHTTP(h *Server_HTTP) error <span class="cov0" title="0">{
        if h.Addr == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("http addr is empty")
        }</span>

        <span class="cov0" title="0">if _, err := net.ResolveTCPAddr("tcp", h.Addr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid http addr %s: %w", h.Addr, err)
        }</span>

        <span class="cov0" title="0">if h.Timeout != nil </span><span class="cov0" title="0">{
                if h.Timeout.AsDuration() &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("http timeout must be positive")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateGRPC 验证GRPC配置
func (v *ConfigValidator) validateGRPC(g *Server_GRPC) error <span class="cov0" title="0">{
        if g.Addr == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("grpc addr is empty")
        }</span>

        <span class="cov0" title="0">if _, err := net.ResolveTCPAddr("tcp", g.Addr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid grpc addr %s: %w", g.Addr, err)
        }</span>

        <span class="cov0" title="0">if g.Timeout != nil </span><span class="cov0" title="0">{
                if g.Timeout.AsDuration() &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("grpc timeout must be positive")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateData 验证数据配置
func (v *ConfigValidator) validateData(d *Data) error <span class="cov0" title="0">{
        if d == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("data config is nil")
        }</span>

        // 验证数据库配置
        <span class="cov0" title="0">if d.Database != nil </span><span class="cov0" title="0">{
                if err := v.validateDatabase(d.Database); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("database config validation failed: %w", err)
                }</span>
        }

        // 验证同步数据库配置
        <span class="cov0" title="0">if d.DatabaseSync != nil </span><span class="cov0" title="0">{
                if err := v.validateDatabaseSync(d.DatabaseSync); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("database sync config validation failed: %w", err)
                }</span>
        }

        // 验证Redis配置
        <span class="cov0" title="0">if d.Redis != nil </span><span class="cov0" title="0">{
                if err := v.validateRedis(d.Redis); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("redis config validation failed: %w", err)
                }</span>
        }

        // 验证Etcd配置
        <span class="cov0" title="0">if d.Etcd != nil </span><span class="cov0" title="0">{
                if err := v.validateEtcd(d.Etcd); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("etcd config validation failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateDatabase 验证数据库配置
func (v *ConfigValidator) validateDatabase(db *Data_Database) error <span class="cov0" title="0">{
        if db.Driver == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database driver is empty")
        }</span>

        <span class="cov0" title="0">if db.Source == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database source is empty")
        }</span>

        <span class="cov0" title="0">if db.MaxOpenConns &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("database max_open_conns must be positive")
        }</span>

        <span class="cov0" title="0">if db.MaxIdleConns &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("database max_idle_conns must be positive")
        }</span>

        <span class="cov0" title="0">if db.ConnMaxLifetime != "" </span><span class="cov0" title="0">{
                if _, err := time.ParseDuration(db.ConnMaxLifetime); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid database conn_max_lifetime %s: %w", db.ConnMaxLifetime, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateDatabaseSync 验证同步数据库配置
func (v *ConfigValidator) validateDatabaseSync(db *Data_DatabaseSync) error <span class="cov0" title="0">{
        if db.Driver == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database sync driver is empty")
        }</span>

        <span class="cov0" title="0">if db.Source == "" &amp;&amp; db.SourceKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database sync source or source_key must be provided")
        }</span>

        <span class="cov0" title="0">if db.MaxOpenConns &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("database sync max_open_conns must be positive")
        }</span>

        <span class="cov0" title="0">if db.MaxIdleConns &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("database sync max_idle_conns must be positive")
        }</span>

        <span class="cov0" title="0">if db.ConnMaxLifetime != "" </span><span class="cov0" title="0">{
                if _, err := time.ParseDuration(db.ConnMaxLifetime); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid database sync conn_max_lifetime %s: %w", db.ConnMaxLifetime, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateRedis 验证Redis配置
func (v *ConfigValidator) validateRedis(r *Data_Redis) error <span class="cov0" title="0">{
        if r.Addr == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("redis addr is empty")
        }</span>

        <span class="cov0" title="0">if _, err := net.ResolveTCPAddr("tcp", r.Addr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid redis addr %s: %w", r.Addr, err)
        }</span>

        <span class="cov0" title="0">if r.Db &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("redis db must be non-negative")
        }</span>

        <span class="cov0" title="0">if r.ReadTimeout != nil </span><span class="cov0" title="0">{
                if r.ReadTimeout.AsDuration() &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("redis read_timeout must be positive")
                }</span>
        }

        <span class="cov0" title="0">if r.WriteTimeout != nil </span><span class="cov0" title="0">{
                if r.WriteTimeout.AsDuration() &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("redis write_timeout must be positive")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateEtcd 验证Etcd配置
func (v *ConfigValidator) validateEtcd(e *Data_Etcd) error <span class="cov0" title="0">{
        if len(e.Endpoints) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("etcd endpoints is empty")
        }</span>

        <span class="cov0" title="0">for i, endpoint := range e.Endpoints </span><span class="cov0" title="0">{
                if endpoint == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("etcd endpoint[%d] is empty", i)
                }</span>

                <span class="cov0" title="0">if _, err := url.Parse(endpoint); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid etcd endpoint[%d] %s: %w", i, endpoint, err)
                }</span>
        }

        <span class="cov0" title="0">if e.DialTimeout != "" </span><span class="cov0" title="0">{
                if _, err := time.ParseDuration(e.DialTimeout); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid etcd dial_timeout %s: %w", e.DialTimeout, err)
                }</span>
        }

        <span class="cov0" title="0">if e.ConfigPrefix == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("etcd config_prefix is empty")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateApp 验证应用配置
func (v *ConfigValidator) validateApp(a *App) error <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("app config is nil")
        }</span>

        <span class="cov0" title="0">if a.Id == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app id is empty")
        }</span>

        <span class="cov0" title="0">if a.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app name is empty")
        }</span>

        <span class="cov0" title="0">if a.Version == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app version is empty")
        }</span>

        <span class="cov0" title="0">if a.Env == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app env is empty")
        }</span>

        <span class="cov0" title="0">if a.LogLevel == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app log_level is empty")
        }</span>

        <span class="cov0" title="0">if a.LogOut == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app log_out is empty")
        }</span>

        <span class="cov0" title="0">if a.AppPackage == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app app_package is empty")
        }</span>

        <span class="cov0" title="0">if a.AppId == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app app_id is empty")
        }</span>

        <span class="cov0" title="0">if a.AppSecret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app app_secret is empty")
        }</span>

        <span class="cov0" title="0">if a.ThirdCompanyId == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app third_company_id is empty")
        }</span>

        <span class="cov0" title="0">if a.PlatformIds == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app platform_ids is empty")
        }</span>

        <span class="cov0" title="0">if a.CompanyId == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app company_id is empty")
        }</span>

        <span class="cov0" title="0">if a.AccessKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app access_key is empty")
        }</span>

        <span class="cov0" title="0">if a.SecretKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app secret_key is empty")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateAuth 验证认证配置
func (v *ConfigValidator) validateAuth(a *Auth) error <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("auth config is nil")
        }</span>

        // 验证WPS应用配置
        <span class="cov0" title="0">if a.Wpsapp != nil </span><span class="cov0" title="0">{
                if err := v.validateWpsapp(a.Wpsapp); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("wpsapp config validation failed: %w", err)
                }</span>
        }

        // 验证钉钉配置
        <span class="cov0" title="0">if a.Dingtalk != nil </span><span class="cov0" title="0">{
                if err := v.validateDingtalk(a.Dingtalk); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("dingtalk config validation failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateWpsapp 验证WPS应用配置
func (v *ConfigValidator) validateWpsapp(w *Auth_Wpsapp) error <span class="cov0" title="0">{
        if w.ClientId == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("wpsapp client_id is empty")
        }</span>

        <span class="cov0" title="0">if w.ClientSecret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("wpsapp client_secret is empty")
        }</span>

        <span class="cov0" title="0">if w.AuthUrl == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("wpsapp auth_url is empty")
        }</span>

        <span class="cov0" title="0">if _, err := url.Parse(w.AuthUrl); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid wpsapp auth_url %s: %w", w.AuthUrl, err)
        }</span>

        <span class="cov0" title="0">if w.AuthPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("wpsapp auth_path is empty")
        }</span>

        <span class="cov0" title="0">if w.GrantType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("wpsapp grant_type is empty")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateDingtalk 验证钉钉配置
func (v *ConfigValidator) validateDingtalk(d *Auth_Dingtalk) error <span class="cov0" title="0">{
        if d.Endpoint == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("dingtalk endpoint is empty")
        }</span>

        <span class="cov0" title="0">if _, err := url.Parse(d.Endpoint); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid dingtalk endpoint %s: %w", d.Endpoint, err)
        }</span>

        <span class="cov0" title="0">if d.AppKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("dingtalk app_key is empty")
        }</span>

        <span class="cov0" title="0">if d.AppSecret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("dingtalk app_secret is empty")
        }</span>

        <span class="cov0" title="0">if d.Timeout != "" </span><span class="cov0" title="0">{
                if _, err := time.ParseDuration(d.Timeout); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid dingtalk timeout %s: %w", d.Timeout, err)
                }</span>
        }

        <span class="cov0" title="0">if d.MaxConcurrent &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("dingtalk maxConcurrent must be positive")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateEnvironment 验证环境变量配置
func (v *ConfigValidator) ValidateEnvironment() error <span class="cov0" title="0">{
        requiredEnvVars := []string{
                "ENCRYPTION_SALT",
        }

        optionalEnvVars := []string{
                "APP_UID",
                "ECIS_ECISACCOUNTSYNC_DB",
        }

        // 验证必需的环境变量
        for _, key := range requiredEnvVars </span><span class="cov0" title="0">{
                if _, err := GetEnv(key); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("required environment variable %s not found: %w", key, err)
                }</span>
        }

        // 记录可选的环境变量状态
        <span class="cov0" title="0">for _, key := range optionalEnvVars </span><span class="cov0" title="0">{
                if value, err := GetEnv(key); err != nil </span><span class="cov0" title="0">{
                        v.logger.Log(log.LevelWarn, "optional environment variable not found", "key", key)
                }</span> else<span class="cov0" title="0"> {
                        v.logger.Log(log.LevelInfo, "environment variable found", "key", key, "has_value", value != "")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package data

import (
        "context"
        "errors"
        "time"

        "nancalacc/internal/biz"
        "nancalacc/internal/conf"
        "nancalacc/internal/data/models"
        "nancalacc/internal/dingtalk"

        "github.com/go-kratos/kratos/v2/log"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

type accounterRepo struct {
        bizConf *conf.App
        data    *Data
        log     *log.Helper
}

var (
        Source  = "sync"
        timeout = 5 * time.Second
)

// NewAccounterRepo .
func NewAccounterRepo(data *Data, logger log.Logger) biz.AccounterRepo <span class="cov0" title="0">{
        return &amp;accounterRepo{
                bizConf: conf.Get().GetApp(),
                data:    data,
                log:     log.NewHelper(logger),
        }
}</span>

func (r *accounterRepo) SaveUsers(ctx context.Context, users []*dingtalk.DingtalkDeptUser, taskId string) (int, error) <span class="cov0" title="0">{

        r.log.WithContext(ctx).Infof("SaveUsers users: %v, taskId :%s", users, taskId)
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        r.log.Infof("SaveUsers: %v", users)
        if len(users) == 0 </span><span class="cov0" title="0">{
                r.log.Warn("users is empty")
                return 0, nil
        }</span>
        <span class="cov0" title="0">thirdCompanyID := r.bizConf.ThirdCompanyId
        platformID := r.bizConf.PlatformIds
        entities := make([]*models.TbLasUser, 0, len(users))
        for _, user := range users </span><span class="cov0" title="0">{
                err := dingtalk.ValidateDingTalkUser(ctx, user)
                if err != nil </span><span class="cov0" title="0">{
                        r.log.Errorf("ValidateDingTalkUser error: %v", err)
                        continue</span>
                }
                <span class="cov0" title="0">entity := models.MakeLasUser(user, thirdCompanyID, platformID, Source, taskId)
                entities = append(entities, entity)</span>
        }
        // result := r.data.db.WithContext(ctx).Clauses(clause.OnConflict{
        //                 Columns: []clause.Column{
        //                         {Name: "uid"},
        //                         {Name: "task_id"},
        //                         {Name: "platform_id"},
        //                 },
        //                 DoNothing: true,
        //         }).Clauses(clause.OnConflict{
        //                 Columns: []clause.Column{
        //                         {Name: "account"},
        //                         {Name: "task_id"},
        //                         {Name: "third_company_id"},
        //                 },
        //                 DoNothing: true,
        //         }).Create(&amp;entities)
        <span class="cov0" title="0">result := r.data.db.WithContext(ctx).Create(&amp;entities)

        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        r.log.Error("user already exists")
                }</span> else<span class="cov0" title="0"> {
                        return 0, result.Error
                }</span>

        }

        <span class="cov0" title="0">return int(result.RowsAffected), nil</span>
}

func (r *accounterRepo) SaveDepartments(ctx context.Context, depts []*dingtalk.DingtalkDept, taskId string) (int, error) <span class="cov0" title="0">{

        r.log.WithContext(ctx).Infof("SaveDepartments depts: %v, taskId :%s", depts, taskId)
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        entities := make([]*models.TbLasDepartment, 0, len(depts))

        thirdCompanyID := r.bizConf.ThirdCompanyId
        platformID := r.bizConf.PlatformIds
        companyID := r.bizConf.CompanyId
        rootDep := models.MakeTbLasRootDepartment(thirdCompanyID, platformID, companyID, Source, taskId)
        for _, dep := range depts </span><span class="cov0" title="0">{
                entity := models.MakeTbLasDepartment(dep, thirdCompanyID, platformID, companyID, Source, taskId)
                entities = append(entities, entity)
        }</span>
        <span class="cov0" title="0">entities = append(entities, rootDep)
        result := r.data.db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "did"}, {Name: "task_id"}, {Name: "third_company_id"}, {Name: "platform_id"}},
                DoNothing: true,
        }).Create(&amp;entities)

        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        r.log.Error("department already exists")
                }</span> else<span class="cov0" title="0"> {
                        return 0, result.Error
                }</span>

        }

        <span class="cov0" title="0">return int(result.RowsAffected), nil</span>
}

func (r *accounterRepo) SaveDepartmentUserRelations(ctx context.Context, relations []*dingtalk.DingtalkDeptUserRelation, taskId string) (int, error) <span class="cov0" title="0">{
        r.log.WithContext(ctx).Infof("SaveDepartmentUserRelations relations: %v, taskId :%s", relations, taskId)
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        entities := make([]*models.TbLasDepartmentUser, 0, len(relations))

        thirdCompanyID := r.bizConf.ThirdCompanyId
        platformID := r.bizConf.PlatformIds

        for _, relation := range relations </span><span class="cov0" title="0">{
                entity := models.MakeTbLasDepartmentUser(relation, thirdCompanyID, platformID, "", Source, taskId)
                entities = append(entities, entity)
        }</span>

        <span class="cov0" title="0">result := r.data.db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "did"}, {Name: "uid"}, {Name: "task_id"}, {Name: "third_company_id"}, {Name: "platform_id"}},
                DoNothing: true,
        }).Create(&amp;entities)

        if result.Error != nil </span><span class="cov0" title="0">{
                return 0, result.Error
        }</span>

        <span class="cov0" title="0">return int(result.RowsAffected), nil</span>
}

func (r *accounterRepo) SaveCompanyCfg(ctx context.Context, cfg *dingtalk.DingtalkCompanyCfg) error <span class="cov0" title="0">{
        r.log.Infof("SaveCompanyCfg: %v", cfg)

        thirdCompanyID := r.bizConf.ThirdCompanyId
        platformID := r.bizConf.PlatformIds
        companyID := r.bizConf.CompanyId
        entity := &amp;models.TbCompanyCfg{
                ThirdCompanyId: thirdCompanyID,
                PlatformIds:    platformID,
                CompanyId:      companyID,
                Status:         1,
                Ctime:          time.Now(),
                Mtime:          time.Now(),
        }

        err := r.data.db.WithContext(ctx).Where(models.TbCompanyCfg{
                ThirdCompanyId: thirdCompanyID,
                CompanyId:      companyID,
        }).FirstOrCreate(entity).Error

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        r.log.Error("company config already exists")
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>

        }

        <span class="cov0" title="0">return nil</span>
}

// func (r *accounterRepo) CallEcisaccountsyncAll(ctx context.Context, taskId string) (biz.EcisaccountsyncAllResponse, error) {
//         r.log.Infof("CallEcisaccountsyncAll: %v", taskId)

//         path := r.serviceConf.Business.EcisaccountsyncUrl

//         // path := "http://encs-pri-proxy-gateway/ecisaccountsync/api/sync/all"
//         var resp biz.EcisaccountsyncAllResponse

//         thirdCompanyID := r.serviceConf.Business.ThirdCompanyId

//         collectCost := "1100000"
//         uri := fmt.Sprintf("%s?taskId=%s&amp;thirdCompanyId=%s&amp;collectCost=%s", path, taskId, thirdCompanyID, collectCost)

//         r.log.Infof("CallEcisaccountsyncAll uri: %s", uri)
//         bs, err := httputil.PostJSON(uri, nil, time.Second*10)
//         r.log.Infof("CallEcisaccountsyncAll.Post output: bs:%s, err:%w", string(bs), err)

//         if err != nil {
//                 return resp, err
//         }
//         err = json.Unmarshal(bs, &amp;resp)
//         if err != nil {
//                 return resp, fmt.Errorf("Unmarshal err: %w", err)
//         }
//         if resp.Code != "200" {
//                 return resp, fmt.Errorf("code not 200: %s", resp.Code)
//         }

//         return resp, nil

// }

func (r *accounterRepo) ClearAll(ctx context.Context) error <span class="cov0" title="0">{
        err := r.data.db.WithContext(ctx).Exec("truncate table tb_company_cfg").Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = r.data.db.WithContext(ctx).Exec("truncate table tb_las_department").Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = r.data.db.WithContext(ctx).Exec("truncate table tb_las_department_user").Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = r.data.db.WithContext(ctx).Exec("truncate table tb_las_account").Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// user_del/user_update/user_add(update_type). . auto/manual(sync_type)
func (r *accounterRepo) SaveIncrementUsers(ctx context.Context, usersAdd, usersDel, usersUpd []*dingtalk.DingtalkDeptUser) error <span class="cov0" title="0">{
        log := r.log.WithContext(ctx)
        log.Info("SaveIncrementUsers")
        inputlen := len(usersAdd) + len(usersDel) + len(usersUpd)
        if inputlen == 0 </span><span class="cov0" title="0">{
                return errors.New("empty input")
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        entities := make([]*models.TbLasUserIncrement, 0, inputlen)

        thirdCompanyID := r.bizConf.ThirdCompanyId
        platformID := r.bizConf.PlatformIds
        companyID := r.bizConf.CompanyId

        // user_del/user_update/user_add
        for _, add := range usersAdd </span><span class="cov0" title="0">{
                err := dingtalk.ValidateDingTalkUser(ctx, add)
                if err != nil </span><span class="cov0" title="0">{
                        r.log.Errorf("ValidateDingTalkUser error: %v", err)
                        continue</span>
                }
                <span class="cov0" title="0">entity := models.MakeLasUserIncrement(add, thirdCompanyID, platformID, companyID, Source, "user_add")
                entities = append(entities, entity)</span>
        }
        <span class="cov0" title="0">for _, del := range usersDel </span><span class="cov0" title="0">{
                err := dingtalk.ValidateDingTalkUser(ctx, del)
                if err != nil </span><span class="cov0" title="0">{
                        r.log.Errorf("ValidateDingTalkUser error: %v", err)
                        continue</span>
                }
                <span class="cov0" title="0">entity := models.MakeLasUserIncrement(del, thirdCompanyID, platformID, companyID, Source, "user_del")
                // entity := r.makeLasUserIncrement(user, "user_del")
                entities = append(entities, entity)</span>
        }
        <span class="cov0" title="0">for _, upd := range usersUpd </span><span class="cov0" title="0">{
                err := dingtalk.ValidateDingTalkUser(ctx, upd)
                if err != nil </span><span class="cov0" title="0">{
                        r.log.Errorf("ValidateDingTalkUser error: %v", err)
                        continue</span>
                }
                // entity := r.makeLasUserIncrement(user, "user_update")
                <span class="cov0" title="0">entity := models.MakeLasUserIncrement(upd, thirdCompanyID, platformID, companyID, Source, "user_update")
                entities = append(entities, entity)</span>
        }

        <span class="cov0" title="0">log.Info("SaveIncrementUsers entities:")

        for i, item := range entities </span><span class="cov0" title="0">{
                log.Info("entities i: %d, item: %v", i, item)
        }</span>

        <span class="cov0" title="0">result := r.data.db.WithContext(ctx).Create(&amp;entities)

        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        r.log.Error("user already exists")
                }</span> else<span class="cov0" title="0"> {
                        return result.Error
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// dept_del/dept_update/dept_add/dept_move(update_type)
func (r *accounterRepo) SaveIncrementDepartments(ctx context.Context, deptsAdd, deptsDel, deptsUpd []*dingtalk.DingtalkDept) error <span class="cov0" title="0">{
        log := r.log.WithContext(ctx)
        log.Info("SaveIncrementDepartments")
        inputlen := len(deptsAdd) + len(deptsDel) + len(deptsUpd)
        if inputlen == 0 </span><span class="cov0" title="0">{
                return errors.New("empty input")
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        // dept_del/dept_update/dept_add
        entities := make([]*models.TbLasDepartmentIncrement, 0, inputlen)
        thirdCompanyID := r.bizConf.ThirdCompanyId
        platformID := r.bizConf.PlatformIds

        for _, add := range deptsAdd </span><span class="cov0" title="0">{
                entity := models.MakeDepartmentIncrement(add, thirdCompanyID, platformID, "", Source, "dept_add")
                entities = append(entities, entity)
        }</span>
        <span class="cov0" title="0">for _, del := range deptsDel </span><span class="cov0" title="0">{
                // entity := r.makeDepartmentIncrement(dep, "dept_del")
                entity := models.MakeDepartmentIncrement(del, thirdCompanyID, platformID, "", Source, "dept_del")
                entities = append(entities, entity)
        }</span>

        <span class="cov0" title="0">for _, upd := range deptsUpd </span><span class="cov0" title="0">{
                // entity := r.makeDepartmentIncrement(dep, "dept_update")
                entity := models.MakeDepartmentIncrement(upd, thirdCompanyID, platformID, "", Source, "dept_update")
                entities = append(entities, entity)
        }</span>

        <span class="cov0" title="0">log.Info("SaveIncrementDepartments entities:")

        for i, item := range entities </span><span class="cov0" title="0">{
                log.Info("entities i: %d, item: %v", i, item)
        }</span>

        <span class="cov0" title="0">result := r.data.db.WithContext(ctx).Create(&amp;entities)

        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        r.log.Error("user already exists")
                }</span> else<span class="cov0" title="0"> {
                        return result.Error
                }</span>

        }

        <span class="cov0" title="0">return nil</span>
}

func (r *accounterRepo) SaveIncrementDepartmentUserRelations(ctx context.Context, relationsAdd, relationsDel, relationsUpd []*dingtalk.DingtalkDeptUserRelation) error <span class="cov0" title="0">{
        log := r.log.WithContext(ctx)
        log.Info("SaveIncrementDepartmentUserRelations")

        inputlen := len(relationsAdd) + len(relationsDel) + len(relationsUpd)
        if inputlen == 0 </span><span class="cov0" title="0">{
                return errors.New("empty input")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        log.Info("SaveIncrementDepartmentUserRelations input:")

        for i, item := range relationsAdd </span><span class="cov0" title="0">{
                log.Info("relationsAdd input i: %d, item: %v", i, item)
        }</span>
        <span class="cov0" title="0">for i, item := range relationsDel </span><span class="cov0" title="0">{
                log.Info("relationsDel input i: %d, item: %v", i, item)
        }</span>
        <span class="cov0" title="0">for i, item := range relationsUpd </span><span class="cov0" title="0">{
                log.Info("relationsUpd input i: %d, item: %v", i, item)
        }</span>

        <span class="cov0" title="0">entities := make([]*models.TbLasDepartmentUserIncrement, 0, inputlen)

        thirdCompanyID := r.bizConf.ThirdCompanyId
        platformID := r.bizConf.PlatformIds
        // user_dept_add/user_dept_del/user_dept_update/user_dept_move
        for _, add := range relationsAdd </span><span class="cov0" title="0">{
                entity := models.MmakeTbLasDepartmentUserIncrement(add, thirdCompanyID, platformID, "", Source, "user_dept_add")
                entities = append(entities, entity)
        }</span>

        <span class="cov0" title="0">for _, del := range relationsDel </span><span class="cov0" title="0">{
                // entity := r.makeDeptUserRelatins(relation, "user_dept_del")
                entity := models.MmakeTbLasDepartmentUserIncrement(del, thirdCompanyID, platformID, "", Source, "user_dept_del")
                entities = append(entities, entity)
        }</span>
        <span class="cov0" title="0">for _, upd := range relationsUpd </span><span class="cov0" title="0">{
                // entity := r.makeDeptUserRelatins(relation, "user_dept_update")
                entity := models.MmakeTbLasDepartmentUserIncrement(upd, thirdCompanyID, platformID, "", Source, "user_dept_update")
                entities = append(entities, entity)
        }</span>

        <span class="cov0" title="0">log.Info("SaveIncrementDepartmentUserRelations entities:")

        for i, item := range entities </span><span class="cov0" title="0">{
                log.Info("entities i: %d, item: %v", i, item)
        }</span>

        <span class="cov0" title="0">result := r.data.db.WithContext(ctx).Create(&amp;entities)

        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        r.log.Infof("relation already exists: %v")
                }</span> else<span class="cov0" title="0"> {
                        return result.Error
                }</span>

        }

        <span class="cov0" title="0">return nil</span>
}
func (r *accounterRepo) BatchSaveUsers(ctx context.Context, users []*models.TbLasUser) (int, error) <span class="cov0" title="0">{

        r.log.WithContext(ctx).Infof("BatchSaveUsers users: %v", users)
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        if len(users) == 0 </span><span class="cov0" title="0">{
                r.log.Infof("users is empty")
                return 0, nil
        }</span>

        // for _, user := range users {
        //         r.log.Warn(user)
        // }

        <span class="cov0" title="0">result := r.data.db.WithContext(ctx).Create(users)

        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        r.log.Error("user already exists")
                }</span> else<span class="cov0" title="0"> {
                        return 0, result.Error
                }</span>
        }

        <span class="cov0" title="0">return int(result.RowsAffected), nil</span>
}
func (r *accounterRepo) BatchSaveDepts(ctx context.Context, depts []*models.TbLasDepartment) (int, error) <span class="cov0" title="0">{

        r.log.WithContext(ctx).Infof("BatchSaveDepts depts: %v", depts)
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        if len(depts) == 0 </span><span class="cov0" title="0">{
                r.log.Warn("users is empty")
                return 0, nil
        }</span>
        // for _, dept := range depts {
        //         r.log.Info(dept)
        // }

        <span class="cov0" title="0">result := r.data.db.WithContext(ctx).Create(depts)

        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        r.log.Error("dept already exists")
                }</span> else<span class="cov0" title="0"> {
                        return 0, result.Error
                }</span>

        }
        <span class="cov0" title="0">return int(result.RowsAffected), nil</span>
}
func (r *accounterRepo) BatchSaveDeptUsers(ctx context.Context, usersdepts []*models.TbLasDepartmentUser) (int, error) <span class="cov0" title="0">{

        r.log.WithContext(ctx).Infof("BatchSaveDeptUsers usersdepts: %v", usersdepts)
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        if len(usersdepts) == 0 </span><span class="cov0" title="0">{
                r.log.Warn("users is empty")
                return 0, nil
        }</span>
        // for _, userdept := range usersdepts {
        //         r.log.Info(userdept)
        // }
        <span class="cov0" title="0">result := r.data.db.WithContext(ctx).Create(usersdepts)
        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        r.log.Error("deptuser already exists")
                }</span> else<span class="cov0" title="0"> {
                        return 0, result.Error
                }</span>

        }
        <span class="cov0" title="0">return int(result.RowsAffected), nil</span>
}

func (r *accounterRepo) CreateTask(ctx context.Context, taskName string) (int, error) <span class="cov0" title="0">{
        log := r.log.WithContext(ctx)
        log.Infof("CreateTask name: %s", taskName)

        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        task := &amp;models.Task{
                Title:         taskName,
                Description:   taskName,
                CreatedAt:     time.Now(),
                Status:        models.TaskStatusPending,
                Progress:      0,
                StartDate:     time.Now(),
                DueDate:       time.Now().Add(time.Minute * 30),
                CompletedAt:   time.Now(),
                CreatorID:     99,
                EstimatedTime: 10,
                ActualTime:    0,
        }

        result := r.data.nancalDB.WithContext(ctx).Where("title=?", taskName).FirstOrCreate(task)

        if result.Error != nil </span><span class="cov0" title="0">{
                // 处理其他错误
                return 0, result.Error
        }</span>

        <span class="cov0" title="0">if result.RowsAffected &gt; 0 </span><span class="cov0" title="0">{
                return 1, nil
        }</span> else<span class="cov0" title="0"> {
                return 0, nil
        }</span>
}

func (r *accounterRepo) UpdateTask(ctx context.Context, taskName, status string) error <span class="cov0" title="0">{

        log := r.log.WithContext(ctx)
        log.Infof("UpdateTask taskName: %s, status: %s", taskName, status)
        // pending/in_progress/completed/cancelled

        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        var task models.Task
        if err := r.data.nancalDB.Model(&amp;models.Task{}).WithContext(ctx).Where("title=?", taskName).Find(&amp;task).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        log.Error("查询超时")
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">now := time.Now()
        task.ActualTime = int(now.Sub(task.StartDate).Seconds())
        task.UpdatedAt = now
        task.Status = status
        if status == models.TaskStatusCompleted || status == models.TaskStatusCancelled </span><span class="cov0" title="0">{
                task.CompletedAt = now
        }</span>

        <span class="cov0" title="0">result := r.data.db.WithContext(ctx).Updates(task)

        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        log.Infof("task already exists")
                }</span> else<span class="cov0" title="0"> {
                        return result.Error
                }</span>

        }

        <span class="cov0" title="0">return nil</span>
}

func (r *accounterRepo) GetTask(ctx context.Context, taskName string) (*models.Task, error) <span class="cov0" title="0">{

        r.log.WithContext(ctx).Infof("CreateTask name: %s", taskName)
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        task := &amp;models.Task{}
        result := r.data.nancalDB.WithContext(ctx).Where("title=?", taskName).Find(task)

        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("notfound")
        }</span>
        <span class="cov0" title="0">return task, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package data

import (
        "github.com/go-kratos/kratos/v2/log"
        "github.com/go-redis/redis/v8"
        "github.com/google/wire"
        "gorm.io/gorm"
)

// ProviderSet is data providers.
// var ProviderSet = wire.NewSet(NewData, NewMysqlDB, NewMysqlSyncDB, NewRedisClient, NewAccounterRepo)
// var ProviderSet = wire.NewSet(NewData, NewMysqlDB, NewMysqlSyncDB, NewRedisClient, NewAccounterRepo)
var ProviderSet = wire.NewSet(
        NewMysqlDB,     // 会绑定到 MainDB
        NewMysqlSyncDB, // 会绑定到 SyncDB
        NewRedisClient,
        NewAccounterRepo,
        // cache.NewRedisRepo,
        NewLocalCacheService,
        NewData,
)

type (
        MainDB struct{ *gorm.DB } // 包装结构体
        SyncDB struct{ *gorm.DB }
)

type Data struct {
        db       *gorm.DB // 主数据库
        nancalDB *gorm.DB // 同步数据库
        redis    *redis.Client
}

func NewData(
        // mainDB *gorm.DB,
        // syncDB *gorm.DB,

        syncDB *SyncDB, // ← 使用类型别名
        mainDB *MainDB, // ← 使用类型别名
        redis *redis.Client, logger log.Logger) (*Data, func(), error) <span class="cov0" title="0">{
        return &amp;Data{
                        // db:       syncDB,
                        // nancalDB: mainDB,
                        db:       syncDB.DB, // 类型转换
                        nancalDB: mainDB.DB, // 类型转换
                        redis:    redis,
                }, func() </span><span class="cov0" title="0">{
                        // 清理函数保持原有逻辑
                        // if redis != nil {
                        //         _ = redis.Close()
                        // }
                        // if sqlDB, err := mainDB.DB(); err == nil {
                        //         _ = sqlDB.Close()
                        // }
                        // if sqlDB, err := nancalDB.DB(); err == nil {
                        //         _ = sqlDB.Close()
                        // }
                        cleanup(mainDB.DB, syncDB.DB, redis, logger)
                }</span>, nil
}
func cleanup(mainDB *gorm.DB, syncDB *gorm.DB, redis *redis.Client, logger log.Logger) <span class="cov0" title="0">{
        if redis != nil </span><span class="cov0" title="0">{
                if err := redis.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Log(log.LevelError, "msg", "failed to close redis", "error", err)
                }</span>
        }

        <span class="cov0" title="0">if mainDB != nil </span><span class="cov0" title="0">{
                gormDB := (*gorm.DB)(mainDB)
                if sqlDB, err := gormDB.DB(); err == nil </span><span class="cov0" title="0">{
                        if err := sqlDB.Close(); err != nil </span><span class="cov0" title="0">{
                                logger.Log(log.LevelError, "msg", "failed to close main DB", "error", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">if syncDB != nil </span><span class="cov0" title="0">{
                gormDB := (*gorm.DB)(syncDB)
                if sqlDB, err := gormDB.DB(); err == nil </span><span class="cov0" title="0">{
                        if err := sqlDB.Close(); err != nil </span><span class="cov0" title="0">{
                                logger.Log(log.LevelError, "msg", "failed to close sync DB", "error", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">logger.Log(log.LevelInfo, "msg", "all database connections closed")</span>
}

// func NewData1(c *conf.Data, logger log.Logger) (*Data, func(), error) {
//         log.NewHelper(logger).Info("=====newData.c: %v\n", c)

//         var db *gorm.DB
//         var err error

//         db, err = NewMysqlDB(c)
//         if err != nil {
//                 log.NewHelper(logger).Error("NewData: init db env failed")
//                 return nil, nil, nil
//         }
//         rdb, err := NewRedisClient(c)
//         if err != nil {
//                 log.NewHelper(logger).Error("NewRedisClient: init db env failed")
//                 return nil, nil, nil
//         }
//         cleanup := func() {
//                 log.NewHelper(logger).Info("closing the data resources")
//                 if rdb != nil {
//                         _ = rdb.Close()
//                 }
//                 sqlDB, _ := db.DB()
//                 err = sqlDB.Close()
//                 if err != nil {
//                         log.NewHelper(logger).Error(err)
//                 }
//         }

//         return &amp;Data{
//                 db:    db,
//                 redis: rdb,
//         }, cleanup, nil
//         // tags := strings.Split(c.Database.Tag, ",")

//         // if len(tags) &gt; 0 {
//         //         for _, tag := range tags {
//         //                 if tag == "migrate" {
//         //                         if err := Migrate(db); err != nil {
//         //                                 return nil, cleanup, err
//         //                         }
//         //                 }
//         //         }
//         // }

// }

// func initDbEnv(c *conf.Data, logger log.Logger) (*gorm.DB, error) {
//         encryptedDsn, err := conf.GetEnv("ECIS_ECISACCOUNTSYNC_DB")

//         log.NewHelper(logger).Info("initDbEnv: %s", encryptedDsn)
//         if err != nil {
//                 log.NewHelper(logger).Error("initDbEnv: %w", err)
//                 return nil, err
//         }
//         appSecret := c.Auth.AppSecret
//         dsn, err := cipherutil.DecryptByAes(encryptedDsn, appSecret)
//         if err != nil {
//                 log.NewHelper(logger).Error("initDbEnvDecryptByAes: %w", err)
//                 return nil, err
//         }
//         if len(dsn) == 0 {
//                 log.NewHelper(logger).Error("initDbEnvDecryptByAes: dsn is empty")
//                 return nil, err
//         }

//         if !strings.Contains(dsn, "parseTime=True") {
//                 dsn = dsn + "&amp;parseTime=True"
//         }
//         return gorm.Open(mysql.Open(dsn), &amp;gorm.Config{
//                 Logger: gormlogger.Default.LogMode(gormlogger.Info),
//         })

// }

// 保持现有MySQL初始化逻辑
// func NewMysqlDB(c *conf.Data) (*gorm.DB, error) {
//         db, err := gorm.Open(mysql.Open(c.Database.Source), &amp;gorm.Config{})
//         if err != nil {
//                 return nil, err
//         }

//         sqlDB, err := db.DB()
//         if err != nil {
//                 return nil, err
//         }
//         sqlDB.SetMaxOpenConns(10)
//         sqlDB.SetMaxIdleConns(10)
//         sqlDB.SetConnMaxLifetime(time.Hour)

//         return db, nil
// }

// func NewRedisClient(c *conf.Data) (*redis.Client, error) {
//         rdb := redis.NewClient(&amp;redis.Options{
//                 Addr:     c.Redis.Addr,
//                 Password: c.Redis.Password,
//                 DB:       int(c.Redis.Db),
//                 // PoolSize: int(c.Redis.Pool_size),
//         })

//         if _, err := rdb.Ping(context.Background()).Result(); err != nil {
//                 return nil, err
//         }
//         return rdb, nil
// }
</pre>
		
		<pre class="file" id="file22" style="display: none">package data

import (
        "context"
        "fmt"
        "nancalacc/internal/data/models"

        "gorm.io/gorm"
)

const (
        pageSize   = 1000  // 每页数据量
        maxResults = 10000 // 最大结果数限制
)

func (r *accounterRepo) BatchGetDeptUsers(ctx context.Context, taskName string) ([]*models.TbLasDepartmentUser, error) <span class="cov0" title="0">{
        r.log.WithContext(ctx).Infof("BatchGetDeptUsers taskName: %s", taskName)

        var (
                allUsers   = make([]*models.TbLasDepartmentUser, 0, pageSize)
                lastID     uint64
                totalCount int
        )

        for </span><span class="cov0" title="0">{
                var pageUsers []*models.TbLasDepartmentUser

                query := r.data.db.WithContext(ctx).
                        Where("task_id = ?", taskName).
                        Order("id ASC") // 必须按ID排序

                if lastID &gt; 0 </span><span class="cov0" title="0">{
                        query = query.Where("id &gt; ?", lastID)
                }</span>

                <span class="cov0" title="0">result := query.Limit(pageSize).Find(&amp;pageUsers)
                if result.Error != nil </span><span class="cov0" title="0">{
                        r.log.WithContext(ctx).Errorf("Query failed at lastID=%d: %v", lastID, result.Error)
                        return nil, fmt.Errorf("database error: %w", result.Error)
                }</span>

                <span class="cov0" title="0">if len(pageUsers) == 0 </span><span class="cov0" title="0">{
                        break</span> // 没有更多数据
                }

                // 更新lastID为当前页最后一条记录的ID
                <span class="cov0" title="0">lastID = uint64(pageUsers[len(pageUsers)-1].ID)
                allUsers = append(allUsers, pageUsers...)
                totalCount += len(pageUsers)

                // 如果获取数量小于pageSize，说明是最后一页
                if len(pageUsers) &lt; pageSize </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if len(allUsers) == 0 </span><span class="cov0" title="0">{
                return nil, gorm.ErrRecordNotFound
        }</span>

        <span class="cov0" title="0">r.log.WithContext(ctx).Debugf("Fetched %d records", totalCount)
        return allUsers, nil</span>
}

func (r *accounterRepo) BatchGetUsers(ctx context.Context, taskName string) ([]*models.TbLasUser, error) <span class="cov0" title="0">{
        r.log.WithContext(ctx).Infof("BatchGetUsers taskName: %s", taskName)

        var (
                allUsers   = make([]*models.TbLasUser, 0, pageSize)
                lastID     uint64
                totalCount int
        )

        selectedFields := []string{"id", "name", "dept_id"} // 只选择必要字段

        for </span><span class="cov0" title="0">{
                var pageUsers []*models.TbLasUser

                query := r.data.db.WithContext(ctx).
                        Select(selectedFields).
                        Where("task_id = ?", taskName).
                        Order("id ASC")

                if lastID &gt; 0 </span><span class="cov0" title="0">{
                        query = query.Where("id &gt; ?", lastID)
                }</span>

                <span class="cov0" title="0">result := query.Limit(pageSize).Find(&amp;pageUsers)
                if result.Error != nil </span><span class="cov0" title="0">{
                        r.log.WithContext(ctx).Errorf("Query failed at lastID=%d: %v", lastID, result.Error)
                        return nil, fmt.Errorf("database error: %w", result.Error)
                }</span>

                <span class="cov0" title="0">if len(pageUsers) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">lastID = uint64(pageUsers[len(pageUsers)-1].ID)
                allUsers = append(allUsers, pageUsers...)
                totalCount += len(pageUsers)

                if len(pageUsers) &lt; pageSize </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if len(allUsers) == 0 </span><span class="cov0" title="0">{
                return nil, gorm.ErrRecordNotFound
        }</span>

        <span class="cov0" title="0">r.log.WithContext(ctx).Debugf("Fetched %d users", totalCount)
        return allUsers, nil</span>
}

func (r *accounterRepo) BatchGetDepts(ctx context.Context, taskName string) ([]*models.TbLasDepartment, error) <span class="cov0" title="0">{
        r.log.WithContext(ctx).Infof("BatchGetDepts taskName: %s", taskName)

        var (
                allDepts   = make([]*models.TbLasDepartment, 0, pageSize)
                lastID     uint64
                totalCount int
        )

        for </span><span class="cov0" title="0">{
                var pageDepts []*models.TbLasDepartment

                query := r.data.db.WithContext(ctx).
                        Where("task_id = ?", taskName).
                        Order("id ASC")

                if lastID &gt; 0 </span><span class="cov0" title="0">{
                        query = query.Where("id &gt; ?", lastID)
                }</span>

                <span class="cov0" title="0">result := query.Limit(pageSize).Find(&amp;pageDepts)
                if result.Error != nil </span><span class="cov0" title="0">{
                        r.log.WithContext(ctx).Errorf("Query failed at lastID=%d: %v", lastID, result.Error)
                        return nil, fmt.Errorf("database error: %w", result.Error)
                }</span>

                <span class="cov0" title="0">if len(pageDepts) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">lastID = uint64(pageDepts[len(pageDepts)-1].ID)
                allDepts = append(allDepts, pageDepts...)
                totalCount += len(pageDepts)

                if len(pageDepts) &lt; pageSize </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if len(allDepts) == 0 </span><span class="cov0" title="0">{
                return nil, gorm.ErrRecordNotFound
        }</span>

        <span class="cov0" title="0">r.log.WithContext(ctx).Debugf("Fetched %d departments", totalCount)
        return allDepts, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// internal/data/etcd/client.go
package etcd

import (
        "nancalacc/internal/conf"
        "time"

        clientv3 "go.etcd.io/etcd/client/v3"
)

type Client struct {
        cli    *clientv3.Client
        prefix string
}

func New(cfg *conf.Data_Etcd) (*Client, error) <span class="cov0" title="0">{
        cli, err := clientv3.New(clientv3.Config{
                Endpoints:   cfg.Endpoints,
                DialTimeout: 5 * time.Second,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{cli: cli, prefix: cfg.ConfigPrefix}, nil</span>
}

func (c *Client) Close() error <span class="cov0" title="0">{
        return c.cli.Close()
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// internal/data/etcd/config.go
package etcd

import (
        "context"
        "encoding/json"
        "errors"

        clientv3 "go.etcd.io/etcd/client/v3"
)

// 获取完整配置key
func (c *Client) fullKey(key string) string <span class="cov0" title="0">{
        return c.prefix + "/" + key
}</span>

// 获取配置（JSON格式）
func (c *Client) GetConfig(ctx context.Context, key string, out interface{}) error <span class="cov0" title="0">{
        resp, err := c.cli.Get(ctx, c.fullKey(key))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(resp.Kvs) == 0 </span><span class="cov0" title="0">{
                return errors.New("config not found")
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(resp.Kvs[0].Value, out)</span>
}

// 监听配置变更
func (c *Client) WatchConfig(ctx context.Context, key string, callback func([]byte)) error <span class="cov0" title="0">{
        watchChan := c.cli.Watch(ctx, c.fullKey(key))
        for resp := range watchChan </span><span class="cov0" title="0">{
                for _, ev := range resp.Events </span><span class="cov0" title="0">{
                        if ev.Type == clientv3.EventTypePut </span><span class="cov0" title="0">{
                                callback(ev.Kv.Value)
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package data

import (
        "context"
        "errors"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        "gorm.io/gorm"
        gormlogger "gorm.io/gorm/logger"
)

// gormLogger 适配器实现gorm.Logger接口
type gormLogger struct {
        logger        *log.Helper
        SlowThreshold time.Duration
        LogLevel      gormlogger.LogLevel
}

// NewGormLogger 创建适配Kratos的GORM日志器
func NewGormLogger(logger log.Logger, slowThreshold time.Duration) gormlogger.Interface <span class="cov0" title="0">{
        return &amp;gormLogger{
                logger:        log.NewHelper(logger),
                SlowThreshold: slowThreshold,
                LogLevel:      gormlogger.Warn, // 默认级别
        }
}</span>

// LogMode 设置日志级别
func (l *gormLogger) LogMode(level gormlogger.LogLevel) gormlogger.Interface <span class="cov0" title="0">{
        newLogger := *l
        newLogger.LogLevel = level
        return &amp;newLogger
}</span>

// Info 打印信息
func (l *gormLogger) Info(ctx context.Context, msg string, data ...interface{}) <span class="cov0" title="0">{
        if l.LogLevel &gt;= gormlogger.Info </span><span class="cov0" title="0">{
                l.logger.WithContext(ctx).Info(msg, data)
        }</span>
}

// Warn 打印警告
func (l *gormLogger) Warn(ctx context.Context, msg string, data ...interface{}) <span class="cov0" title="0">{
        if l.LogLevel &gt;= gormlogger.Warn </span><span class="cov0" title="0">{
                l.logger.WithContext(ctx).Warn(msg, data)
        }</span>
}

// Error 打印错误
func (l *gormLogger) Error(ctx context.Context, msg string, data ...interface{}) <span class="cov0" title="0">{
        if l.LogLevel &gt;= gormlogger.Error </span><span class="cov0" title="0">{
                l.logger.WithContext(ctx).Error(msg, data)
        }</span>
}

// Trace 打印SQL跟踪
func (l *gormLogger) Trace(ctx context.Context, begin time.Time, fc func() (string, int64), err error) <span class="cov0" title="0">{
        if l.LogLevel &lt;= gormlogger.Silent </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">elapsed := time.Since(begin)
        //sql, rows := fc()
        // fields := []interface{}{
        //         "sql", sql,
        //         "rows", rows,
        //         "time", elapsed,
        // }

        switch </span>{
        case err != nil &amp;&amp; !errors.Is(err, gorm.ErrRecordNotFound):<span class="cov0" title="0"></span>
                //l.logger.WithContext(ctx).Errorw("gorm error", append(fields, "err", err)...)
        case elapsed &gt; l.SlowThreshold &amp;&amp; l.SlowThreshold != 0:<span class="cov0" title="0"></span>
                //l.logger.WithContext(ctx).Warnw("slow sql", append(fields, "slow", l.SlowThreshold)...)
        case l.LogLevel &gt;= gormlogger.Info:<span class="cov0" title="0"></span>
                //l.logger.WithContext(ctx).Debugw("gorm query", fields...)
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package data

import (
        "context"
        "nancalacc/internal/biz"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/patrickmn/go-cache"
)

type localCacheService struct {
        client *cache.Cache
        logger log.Logger
}

var (
        DefaultExpiration = 5 * time.Minute
        CleanupInterval   = 10 * time.Minute
)

func NewLocalCacheService(logger log.Logger) biz.CacheService <span class="cov0" title="0">{
        return &amp;localCacheService{
                client: cache.New(DefaultExpiration, CleanupInterval),
                logger: logger,
        }
}</span>

func (s *localCacheService) Set(ctx context.Context, key string, value interface{}, d time.Duration) error <span class="cov0" title="0">{
        s.client.Set(key, value, d)
        return nil
}</span>

func (s *localCacheService) Get(ctx context.Context, key string) (interface{}, bool, error) <span class="cov0" title="0">{
        res, ok := s.client.Get(key)
        if !ok </span><span class="cov0" title="0">{
                return nil, false, nil
        }</span>
        <span class="cov0" title="0">return res, true, nil</span>
}

func (s *localCacheService) Del(ctx context.Context, key string) error <span class="cov0" title="0">{
        s.client.Delete(key)
        return nil
}</span>

// other methods...
</pre>
		
		<pre class="file" id="file27" style="display: none">package data

import (
        "nancalacc/internal/data/models"
        "time"

        "gorm.io/gorm"
)

func Migrate(db *gorm.DB) error <span class="cov0" title="0">{

        if err := db.Migrator().DropTable(&amp;models.TbLasDepartment{}, &amp;models.TbLasUser{}, &amp;models.TbLasDepartmentUser{}, &amp;models.TbCompanyCfg{}, &amp;models.Task{}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := db.AutoMigrate(&amp;models.TbLasDepartment{}, &amp;models.TbLasUser{}, &amp;models.TbLasDepartmentUser{}, &amp;models.TbCompanyCfg{}, &amp;models.Task{}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">db.Create(&amp;models.TbCompanyCfg{
                ThirdCompanyId: "1",
                PlatformIds:    "1",
                CompanyId:      "1",
                Status:         0,
                Ctime:          time.Now(),
                Mtime:          time.Now(),
        })
        return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package models

import (
        "gorm.io/gorm"
)

// 数据库实体
type Account struct {
        gorm.Model
        ID        int64  `gorm:"column:id;primaryKey"`
        Username  string `gorm:"column:username;size:255;uniqueIndex"`
        Email     string `gorm:"column:email;size:255;uniqueIndex"`
        Phone     string `gorm:"column:phone;size:20"`
        Password  string `gorm:"column:password;size:255"`
        Status    int32  `gorm:"column:status;default:1"`
        CreatedAt int64  `gorm:"column:created_at"`
        UpdatedAt int64  `gorm:"column:updated_at"`
}

func (a *Account) TableName() string <span class="cov0" title="0">{
        return "nancal_account"
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package models

import (
        "time"
)

// 租户关系配置表
type TbCompanyCfg struct {
        Id             uint      `gorm:"primaryKey;autoIncrement;column:id;type:int unsigned;comment:主键id" json:"id"`
        ThirdCompanyId string    `gorm:"column:third_company_id;type:varchar(20);comment:三方租户id;NOT NULL" json:"third_company_id"`
        PlatformIds    string    `gorm:"column:platform_ids;type:varchar(100);comment:平台id, 用来区分多种数据源,多个用逗号分隔;NOT NULL" json:"platform_ids"`
        CompanyId      string    `gorm:"column:company_id;type:varchar(20);comment:云文档租户id;NOT NULL" json:"company_id"`
        Status         int       `gorm:"column:status;type:tinyint(4);default:1;comment:状态,0-禁用,1-启用;NOT NULL" json:"status"`
        Ctime          time.Time `gorm:"column:ctime;type:timestamp;default:CURRENT_TIMESTAMP;comment:创建时间" json:"ctime"`
        Mtime          time.Time `gorm:"column:mtime;type:timestamp;default:CURRENT_TIMESTAMP;comment:更新时间;NOT NULL" json:"mtime"`
}

func (m *TbCompanyCfg) TableName() string <span class="cov0" title="0">{
        return "tb_company_cfg"
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package models

import (
        "fmt"
        "nancalacc/internal/dingtalk"
        "nancalacc/internal/pkg/cipherutil"
        "strconv"
        "time"
)

func MakeLasUser(user *dingtalk.DingtalkDeptUser, thirdCompanyID, platformID, source, taskId string) *TbLasUser <span class="cov0" title="0">{
        //var account string
        // if user.Mobile != "" {
        //         account = user.Mobile
        // } else {
        //         account = user.Userid
        // }
        account := user.Mobile
        now := time.Now()
        mobile, err := cipherutil.EncryptValueWithEnvSalt(user.Mobile)
        fmt.Printf("EncryptValueWithEnvSalt user.Mobile: %s,mobile:%s err: %v\n", user.Mobile, mobile, err)
        entity := &amp;TbLasUser{
                TaskID:         taskId,
                ThirdCompanyID: thirdCompanyID,
                PlatformID:     platformID,
                Uid:            user.Userid,
                DefDid:         "-1",
                DefDidOrder:    0,
                Account:        account,
                NickName:       user.Name,
                Email:          user.Email,
                // Phone:         user.Mobile,
                Phone:            mobile,
                Title:            user.Title,
                Source:           source,
                Ctime:            now,
                Mtime:            now,
                CheckType:        1,
                EmploymentStatus: "active",
                EmploymentType:   "permanent",
        }
        if len(user.LeaderInDept) &gt; 0 </span>{<span class="cov0" title="0">
                //entity.Leader = user.LeaderInDept[0].Leader
        }</span>
        <span class="cov0" title="0">return entity</span>
}

func MakeTbLasDepartment(dep *dingtalk.DingtalkDept, thirdCompanyID, platformID, companyID, source, taskId string) *TbLasDepartment <span class="cov0" title="0">{

        now := time.Now()
        return &amp;TbLasDepartment{
                Did:            strconv.FormatInt(dep.DeptID, 10),
                TaskID:         taskId,
                Name:           dep.Name,
                ThirdCompanyID: thirdCompanyID,
                PlatformID:     platformID,
                Pid:            strconv.FormatInt(dep.ParentID, 10),
                Order:          int(dep.Order),
                Source:         "sync",
                Ctime:          now,
                Mtime:          now,
                CheckType:      1,
        }
}</span>

func MakeTbLasRootDepartment(thirdCompanyID, platformID, companyID, source, taskId string) *TbLasDepartment <span class="cov0" title="0">{

        now := time.Now()
        return &amp;TbLasDepartment{
                Did:            "0",
                TaskID:         taskId,
                Name:           companyID,
                ThirdCompanyID: thirdCompanyID,
                PlatformID:     platformID,
                Pid:            "-1",
                Order:          0,
                Source:         source,
                Ctime:          now,
                Mtime:          now,
                CheckType:      1,
        }
}</span>

func MakeTbLasDepartmentUser(relation *dingtalk.DingtalkDeptUserRelation, thirdCompanyID, platformID, companyID, source, taskId string) *TbLasDepartmentUser <span class="cov0" title="0">{

        return &amp;TbLasDepartmentUser{
                Did:            relation.Did,
                TaskID:         taskId,
                ThirdCompanyID: thirdCompanyID,
                PlatformID:     platformID,
                Uid:            relation.Uid,
                Ctime:          time.Now(),
                Order:          int(relation.Order),
                CheckType:      1,
        }
}</span>

func MakeLasUserIncrement(user *dingtalk.DingtalkDeptUser, thirdCompanyID, platformID, companyID, source, updateType string) *TbLasUserIncrement <span class="cov0" title="0">{

        // var account string
        // if user.Mobile != "" {
        //         account = user.Mobile
        // } else {
        //         account = user.Userid
        // }
        account := user.Mobile
        now := time.Now()
        mobile, err := cipherutil.EncryptValueWithEnvSalt(user.Mobile)
        fmt.Printf("EncryptValueWithEnvSalt user.Mobile: %s,mobile:%s err: %v\n", user.Mobile, mobile, err)
        entity := &amp;TbLasUserIncrement{
                ThirdCompanyID: thirdCompanyID,
                PlatformID:     platformID,
                Uid:            user.Userid,
                DefDid:         "-1",
                DefDidOrder:    0,
                Account:        account,
                NickName:       user.Name,
                Email:          user.Email,
                // Phone:            user.Mobile,
                Phone:            mobile,
                Title:            user.Title,
                Source:           source,
                Ctime:            now,
                Mtime:            now,
                EmploymentStatus: "active",
                EmploymentType:   "permanent",
                UpdateType:       updateType,
                SyncType:         "auto",
                SyncTime:         now,
                Status:           0,
        }
        if len(user.LeaderInDept) &gt; 0 </span>{<span class="cov0" title="0">
                //entity.Leader = user.LeaderInDept[0].Leader
        }</span>
        <span class="cov0" title="0">return entity</span>
}

func MakeDepartmentIncrement(dept *dingtalk.DingtalkDept, thirdCompanyID, platformID, companyID, source, updateType string) *TbLasDepartmentIncrement <span class="cov0" title="0">{

        now := time.Now()
        entity := &amp;TbLasDepartmentIncrement{
                Did:            strconv.FormatInt(dept.DeptID, 10),
                Name:           dept.Name,
                ThirdCompanyID: thirdCompanyID,
                PlatformID:     platformID,
                //Pid:            strconv.FormatInt(dept.ParentID, 10),
                Order:      int32(dept.Order),
                Source:     "sync",
                Ctime:      now,
                Mtime:      now,
                UpdateType: updateType,
                SyncTime:   now,
                SyncType:   "auto",
                Status:     0,
        }
        if dept.ParentID != 0 </span><span class="cov0" title="0">{
                entity.Pid = strconv.FormatInt(dept.ParentID, 10)
        }</span> else<span class="cov0" title="0"> {
                entity.Pid = "-1"
        }</span>
        <span class="cov0" title="0">return entity</span>

}

func MmakeTbLasDepartmentUserIncrement(relation *dingtalk.DingtalkDeptUserRelation, thirdCompanyID, platformID, companyID, source, updateType string) *TbLasDepartmentUserIncrement <span class="cov0" title="0">{
        now := time.Now()
        entity := &amp;TbLasDepartmentUserIncrement{
                Did:            relation.Did,
                ThirdCompanyID: thirdCompanyID,
                PlatformID:     platformID,
                Uid:            relation.Uid,
                Ctime:          now,
                Order:          1,
                UpdateType:     updateType,
                SyncType:       "auto",
                SyncTime:       now,
                Status:         0,
        }

        return entity

}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package models

import (
        "time"
)

// 全量部门采集表
type TbLasDepartment struct {
        ID             uint      `gorm:"primaryKey;autoIncrement;column:id;type:int unsigned;comment:主键id" json:"id"`
        Did            string    `gorm:"not null;column:did;type:varchar(255);comment:部门id" json:"did"`
        TaskID         string    `gorm:"not null;column:task_id;type:varchar(20);comment:任务id" json:"task_id"`
        ThirdCompanyID string    `gorm:"not null;column:third_company_id;type:varchar(20);comment:租户id" json:"third_company_id"`
        PlatformID     string    `gorm:"not null;column:platform_id;type:varchar(60);comment:平台id" json:"platform_id"`
        Pid            string    `gorm:"column:pid;type:varchar(255);comment:父部门id" json:"pid"`
        Name           string    `gorm:"not null;column:name;type:varchar(255);comment:部门名称" json:"name"`
        Order          int       `gorm:"column:order;type:int;default:0;comment:排序" json:"order"`
        Source         string    `gorm:"column:source;type:varchar(20);default:sync;comment:来源" json:"source"`
        Ctime          time.Time `gorm:"column:ctime;type:timestamp;default:CURRENT_TIMESTAMP;comment:创建时间" json:"ctime"`
        Mtime          time.Time `gorm:"not null;column:mtime;type:timestamp;comment:修改时间" json:"mtime"`
        CheckType      int8      `gorm:"not null;column:check_type;type:tinyint;default:0;comment:1-勾选 0-未勾选" json:"check_type"`
        Type           string    `gorm:"column:type;type:varchar(255);comment:类型" json:"type"`
}

// TableName 设置表名
func (TbLasDepartment) TableName() string <span class="cov0" title="0">{
        return "tb_las_department"
}</span>

// 增量部门采集表
type TbLasDepartmentIncrement struct {
        ID             uint      `gorm:"primaryKey;autoIncrement;column:id;comment:主键id"`
        Did            string    `gorm:"not null;column:did;size:255;comment:部门id"`
        ThirdCompanyID string    `gorm:"not null;column:third_company_id;size:20;comment:租户id"`
        PlatformID     string    `gorm:"not null;column:platform_id;size:60;comment:平台id"`
        Pid            string    `gorm:"column:pid;size:255;comment:父部门id"`
        Name           string    `gorm:"not null;column:name;size:255;comment:部门名称"`
        Order          int32     `gorm:"column:order;comment:排序"`
        Source         string    `gorm:"column:source;size:20;default:sync;comment:来源"`
        SyncType       string    `gorm:"column:sync_type;size:20;default:auto;comment:同步方式"`
        UpdateType     string    `gorm:"not null;column:update_type;size:20;comment:修改类型"`
        Status         int       `gorm:"column:status;default:0;comment:状态"`
        Msg            string    `gorm:"column:msg;size:2000;comment:错误详情"`
        Operator       string    `gorm:"column:operator;size:100;default:系统;comment:operator"`
        SyncTime       time.Time `gorm:"column:sync_time;default:CURRENT_TIMESTAMP;comment:增量数据变动时间"`
        Ctime          time.Time `gorm:"column:ctime;default:CURRENT_TIMESTAMP;comment:创建时间"`
        Mtime          time.Time `gorm:"not null;column:mtime;comment:修改时间"`
        Type           string    `gorm:"column:type;size:255;comment:类型"`
}

func (TbLasDepartmentIncrement) TableName() string <span class="cov0" title="0">{
        return "tb_las_department_increment"
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package models

import (
        "time"
)

// 全量部门用户关系表
type TbLasDepartmentUser struct {
        ID             uint      `gorm:"primaryKey;autoIncrement;column:id;type:int unsigned;comment:主键id"`
        TaskID         string    `gorm:"not null;column:task_id;type:varchar(20);comment:任务id"`
        ThirdCompanyID string    `gorm:"not null;column:third_company_id;type:varchar(20);comment:租户id"`
        PlatformID     string    `gorm:"not null;column:platform_id;type:varchar(60);comment:平台id"`
        Uid            string    `gorm:"not null;column:uid;type:varchar(255);comment:用户id"`
        Did            string    `gorm:"not null;column:did;type:varchar(255);comment:部门id"`
        Order          int       `gorm:"column:order;type:int;comment:排序"`
        Main           int       `gorm:"column:main;type:int;default:0;comment:是否是主部门"`
        Ctime          time.Time `gorm:"not null;column:ctime;type:timestamp;default:CURRENT_TIMESTAMP;comment:创建时间"`
        CheckType      int8      `gorm:"not null;column:check_type;type:tinyint;default:0;comment:勾选状态"`
}

func (TbLasDepartmentUser) TableName() string <span class="cov0" title="0">{
        return "tb_las_department_user"
}</span>

// 增量部门用户关系表
type TbLasDepartmentUserIncrement struct {
        ID             uint      `gorm:"primaryKey;autoIncrement;column:id;type:int unsigned;comment:主键id"`
        ThirdCompanyID string    `gorm:"not null;column:third_company_id;type:varchar(20);comment:租户id"`
        PlatformID     string    `gorm:"not null;column:platform_id;type:varchar(60);comment:平台id"`
        Uid            string    `gorm:"not null;column:uid;type:varchar(255);comment:用户id"`
        Did            string    `gorm:"not null;column:did;type:varchar(255);comment:默认部门id"`
        Order          int       `gorm:"column:order;type:int;comment:排序"`
        Main           int       `gorm:"column:main;type:int;default:0;comment:是否是主部门"`
        SyncType       string    `gorm:"column:sync_type;type:varchar(20);default:auto;comment:同步方式"`
        UpdateType     string    `gorm:"not null;column:update_type;type:varchar(20);comment:修改类型"`
        Status         int       `gorm:"column:status;type:int;default:0;comment:状态"`
        Msg            string    `gorm:"column:msg;type:varchar(2000);comment:错误详情"`
        Operator       string    `gorm:"column:operator;type:varchar(100);default:系统;comment:operator"`
        SyncTime       time.Time `gorm:"column:sync_time;type:timestamp;default:CURRENT_TIMESTAMP;comment:增量数据变动时间"`
        Ctime          time.Time `gorm:"not null;column:ctime;type:timestamp;default:CURRENT_TIMESTAMP;comment:创建时间"`
        Mtime          time.Time `gorm:"not null;column:mtime;type:timestamp;comment:修改时间"`
        Dids           string    `gorm:"column:dids;type:varchar(5000);comment:dids"`
}

func (TbLasDepartmentUserIncrement) TableName() string <span class="cov0" title="0">{
        return "tb_las_department_user_increment"
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package models

import "time"

const (
        TaskStatusPending    = "pending"
        TaskStatusInProgress = "in_progress"
        TaskStatusCompleted  = "completed"
        TaskStatusCancelled  = "cancelled"
)

type Task struct {
        ID            uint      `gorm:"primaryKey;autoIncrement;column:id;comment:任务ID"`
        Title         string    `gorm:"type:varchar(255);not null;column:title;comment:任务标题"`
        Description   string    `gorm:"type:text;column:description;comment:任务描述"`
        Status        string    `gorm:"type:varchar(20);not null;default:pending;column:status;comment:任务状态(pending/in_progress/completed/cancelled)"`
        CreatedAt     time.Time `gorm:"type:timestamp;not null;default:CURRENT_TIMESTAMP;column:created_at;comment:创建时间"`
        UpdatedAt     time.Time `gorm:"type:timestamp;not null;default:CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;column:updated_at;comment:更新时间"`
        DueDate       time.Time `gorm:"type:timestamp;column:due_date;comment:截止时间"`
        StartDate     time.Time `gorm:"type:timestamp;column:start_date;comment:开始时间"`
        CompletedAt   time.Time `gorm:"type:timestamp;column:completed_at;comment:完成时间"`
        CreatorID     uint      `gorm:"type:bigint;not null;column:creator_id;comment:创建人ID"`
        Progress      int8      `gorm:"type:tinyint;default:0;column:progress;comment:进度(0-100)"`
        EstimatedTime int       `gorm:"type:int;column:estimated_time;comment:预估耗时(分钟)"`
        ActualTime    int       `gorm:"type:int;column:actual_time;comment:实际耗时(分钟)"`
}

func (Task) TableName() string <span class="cov0" title="0">{
        return "task"
}</span>

func (Task) Indexes() []string <span class="cov0" title="0">{
        return []string{"idx_status"}
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package models

import (
        "time"
)

type TbLasUser struct {
        ID               uint      `gorm:"primaryKey;autoIncrement;column:id;type:int unsigned;comment:主键id"`
        TaskID           string    `gorm:"not null;column:task_id;type:varchar(20);comment:任务id"`
        ThirdCompanyID   string    `gorm:"not null;column:third_company_id;type:varchar(20);comment:租户id"`
        PlatformID       string    `gorm:"not null;column:platform_id;type:varchar(60);comment:平台id"`
        Uid              string    `gorm:"not null;column:uid;type:varchar(255);comment:用户id"`
        DefDid           string    `gorm:"column:def_did;type:varchar(255);comment:默认部门"`
        DefDidOrder      int       `gorm:"column:def_did_order;type:int;default:0;comment:排序"`
        Account          string    `gorm:"not null;column:account;type:varchar(255);comment:登录名"`
        NickName         string    `gorm:"not null;column:nick_name;type:varchar(255);comment:用户昵称"`
        Password         string    `gorm:"column:password;type:varchar(255);comment:密码"`
        Avatar           string    `gorm:"column:avatar;type:varchar(255);comment:头像"`
        Email            string    `gorm:"column:email;type:varchar(80);comment:邮箱"`
        Gender           string    `gorm:"column:gender;type:varchar(60);comment:性别"`
        Title            string    `gorm:"column:title;type:varchar(255);comment:职称"`
        WorkPlace        string    `gorm:"column:work_place;type:varchar(255);comment:办公地点"`
        Leader           string    `gorm:"column:leader;type:varchar(255);comment:上级主管ID"`
        Employer         string    `gorm:"column:employer;type:varchar(255);comment:员工工号"`
        EmploymentStatus string    `gorm:"column:employment_status;type:varchar(60);default:notactive;comment:就职状态"`
        EmploymentType   string    `gorm:"column:employment_type;type:varchar(60);comment:就职类型"`
        Phone            string    `gorm:"column:phone;type:varchar(200);comment:手机号"`
        Telephone        string    `gorm:"column:telephone;type:varchar(200);comment:座机号"`
        Source           string    `gorm:"column:source;type:varchar(20);default:sync;comment:来源"`
        CustomFields     string    `gorm:"column:custom_fields;type:varchar(5000);comment:自定义字段"`
        Ctime            time.Time `gorm:"column:ctime;type:timestamp;default:CURRENT_TIMESTAMP;comment:创建时间"`
        Mtime            time.Time `gorm:"not null;column:mtime;type:timestamp;comment:更新时间"`
        CheckType        int8      `gorm:"not null;column:check_type;type:tinyint;default:0;comment:勾选状态"`
}

func (TbLasUser) TableName() string <span class="cov0" title="0">{
        return "tb_las_user"
}</span>

type TbLasUserIncrement struct {
        ID               uint      `gorm:"primaryKey;autoIncrement;column:id;type:int unsigned;comment:主键id"`
        ThirdCompanyID   string    `gorm:"not null;column:third_company_id;type:varchar(20);comment:租户id"`
        PlatformID       string    `gorm:"not null;column:platform_id;type:varchar(60);comment:平台id"`
        Uid              string    `gorm:"not null;column:uid;type:varchar(255);comment:用户id"`
        DefDid           string    `gorm:"column:def_did;type:varchar(255);comment:默认部门"`
        DefDidOrder      int       `gorm:"column:def_did_order;type:int;default:0;comment:排序"`
        Account          string    `gorm:"not null;column:account;type:varchar(255);comment:登录名"`
        NickName         string    `gorm:"not null;column:nick_name;type:varchar(255);comment:用户昵称"`
        Password         string    `gorm:"column:password;type:varchar(255);comment:密码"`
        Avatar           string    `gorm:"column:avatar;type:varchar(255);comment:头像"`
        Email            string    `gorm:"column:email;type:varchar(80);comment:邮箱"`
        Gender           string    `gorm:"column:gender;type:varchar(60);comment:性别"`
        Title            string    `gorm:"column:title;type:varchar(255);comment:职称"`
        WorkPlace        string    `gorm:"column:work_place;type:varchar(255);comment:办公地点"`
        Leader           string    `gorm:"column:leader;type:varchar(255);comment:上级主管ID"`
        Employer         string    `gorm:"column:employer;type:varchar(255);comment:员工工号"`
        EmploymentStatus string    `gorm:"column:employment_status;type:varchar(60);comment:就职状态"`
        EmploymentType   string    `gorm:"column:employment_type;type:varchar(60);comment:就职类型"`
        Phone            string    `gorm:"column:phone;type:varchar(200);comment:手机号"`
        Telephone        string    `gorm:"column:telephone;type:varchar(200);comment:座机号"`
        Source           string    `gorm:"column:source;type:varchar(20);default:sync;comment:来源"`
        CustomFields     string    `gorm:"column:custom_fields;type:varchar(5000);comment:自定义字段"`
        SyncType         string    `gorm:"column:sync_type;type:varchar(20);default:auto;comment:同步方式"`
        UpdateType       string    `gorm:"not null;column:update_type;type:varchar(20);comment:修改类型"`
        Status           int       `gorm:"column:status;type:int;default:0;comment:状态"`
        Msg              string    `gorm:"column:msg;type:varchar(2000);comment:错误详情"`
        Operator         string    `gorm:"column:operator;type:varchar(100);default:系统;comment:operator"`
        SyncTime         time.Time `gorm:"column:sync_time;type:timestamp;default:CURRENT_TIMESTAMP;comment:增量数据变动时间"`
        Ctime            time.Time `gorm:"column:ctime;type:timestamp;default:CURRENT_TIMESTAMP;comment:创建时间"`
        Mtime            time.Time `gorm:"not null;column:mtime;type:timestamp;comment:更新时间"`
}

func (TbLasUserIncrement) TableName() string <span class="cov0" title="0">{
        return "tb_las_user_increment"
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package data

import (
        "errors"
        "nancalacc/internal/conf"
        "nancalacc/internal/pkg/cipherutil"
        "strings"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        "gorm.io/driver/mysql"
        "gorm.io/gorm"
        gormlogger "gorm.io/gorm/logger"
)

func NewMysqlDB(c *conf.Data, logger log.Logger) (*MainDB, error) <span class="cov0" title="0">{

        if !c.Database.Enable </span><span class="cov0" title="0">{
                logger.Log(log.LevelWarn, "database Enable", c.Database.Enable)
                return &amp;MainDB{}, nil
        }</span>
        <span class="cov0" title="0">db, err := gorm.Open(mysql.Open(c.Database.Source), &amp;gorm.Config{
                Logger: gormlogger.Default.LogMode(gormlogger.Info),
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Log(log.LevelError, "open mysql failed", err)
                return nil, nil
        }</span>

        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(int(c.Database.MaxOpenConns))
        sqlDB.SetMaxIdleConns(int(c.Database.MaxIdleConns))
        duration, err := time.ParseDuration(c.GetDatabaseSync().GetConnMaxLifetime())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">sqlDB.SetConnMaxLifetime(duration)

        return &amp;MainDB{DB: db}, nil</span>
}

// deleteUser
// ECIS_ECISACCOUNTSYNC_DB=rESQpZX7v1v4YZletn9rCPJXehB9GFT/dzVFk3R99aMEjCKAG6w+vQKYdwFjEil8Lz4JLaZu8ziT1U3oHwv02MwjBfKed1/xNwhlGrt9jQ+zcQod+0W8QS5SNDr3InBlJzFYqPpAu9UkDpHsYsheVgZGouFz6qVKetVn17ZpdFZgnS2Ct8mJgYLFr3Sry9m8
func NewMysqlSyncDB(c *conf.Data, logger log.Logger) (*SyncDB, error) <span class="cov0" title="0">{
        var dsn string
        if c.GetDatabaseSync().Env == "dev" </span><span class="cov0" title="0">{
                dsn = c.Database.Source
        }</span> else<span class="cov0" title="0"> {
                envkey := c.DatabaseSync.SourceKey
                encryptedDsn, err := conf.GetEnv(envkey)

                //logger.Log(log.LevelDebug, "envkey:", envkey, "encryptedDsn:", encryptedDsn, "err", err)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log(log.LevelError, envkey, err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">appSecret := conf.Get().GetApp().GetAppSecret()
                dsn, err = cipherutil.DecryptByAes(encryptedDsn, appSecret)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log(log.LevelError, envkey, err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">if len(dsn) == 0 </span><span class="cov0" title="0">{
                        logger.Log(log.LevelError, "ECIS_ECISACCOUNTSYNC_DB len(dsn) == 0")
                        return nil, errors.New("ECIS_ECISACCOUNTSYNC_DB len(dsn) == 0")
                }</span>

                <span class="cov0" title="0">if !strings.Contains(dsn, "parseTime=True") </span><span class="cov0" title="0">{
                        dsn = dsn + "&amp;parseTime=True"
                }</span>
        }
        //logger.Log(log.LevelInfo, "sync dsn: %s", dsn)
        <span class="cov0" title="0">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{
                Logger: gormlogger.Default.LogMode(gormlogger.Info),
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Log(log.LevelError, "open mysql failed", err)
                return nil, nil
        }</span>

        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(int(c.GetDatabaseSync().GetMaxOpenConns()))
        sqlDB.SetMaxIdleConns(int(c.GetDatabaseSync().GetMaxIdleConns()))
        duration, err := time.ParseDuration(c.GetDatabaseSync().GetConnMaxLifetime())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sqlDB.SetConnMaxLifetime(duration)

        return &amp;SyncDB{DB: db}, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package data

import (
        "context"
        "nancalacc/internal/conf"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/go-redis/redis/v8"
)

func NewRedisClient(c *conf.Data, logger log.Logger) (*redis.Client, error) <span class="cov0" title="0">{

        if !c.Redis.Enable </span><span class="cov0" title="0">{
                logger.Log(log.LevelWarn, "redis Enable", c.Redis.Enable)
                return &amp;redis.Client{}, nil
        }</span>
        <span class="cov0" title="0">rdb := redis.NewClient(&amp;redis.Options{
                Addr:     c.Redis.Addr,
                Password: c.Redis.Password,
                DB:       int(c.Redis.Db),
                // PoolSize: int(c.Redis.Pool_size),
        })

        if _, err := rdb.Ping(context.Background()).Result(); err != nil </span><span class="cov0" title="0">{
                logger.Log(log.LevelError, "ping redis failed", err)
                return nil, nil
        }</span>
        <span class="cov0" title="0">return rdb, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package data

import (
        "context"
        "encoding/json"
        "nancalacc/internal/biz"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/go-redis/redis/v8"
)

type redisCacheService struct {
        client *redis.Client
        log    *log.Helper
}

// NewAccounterRepo .
func NewRedisCacheService(client *redis.Client, logger log.Logger) biz.CacheService <span class="cov0" title="0">{
        return &amp;redisCacheService{
                client: client,
                log:    log.NewHelper(logger),
        }
}</span>

func (r *redisCacheService) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov0" title="0">{
        p, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">r.log.Infof("Set key: %s, value: %s", key, string(p))
        return r.client.Set(ctx, key, p, expiration).Err()</span>
}

func (r *redisCacheService) Get(ctx context.Context, key string) (interface{}, bool, error) <span class="cov0" title="0">{
        p, err := r.client.Get(ctx, key).Bytes()
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        return nil, false, nil
                }</span>
                <span class="cov0" title="0">return nil, false, err</span>
        }
        <span class="cov0" title="0">var v interface{}
        err = json.Unmarshal(p, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>
        <span class="cov0" title="0">return v, true, nil</span>
}

func (r *redisCacheService) Del(ctx context.Context, key string) error <span class="cov0" title="0">{
        r.client.Del(ctx, key)
        return nil
}</span>

// func (r *redisRepo) GetWithCachePenetrationProtection(
//         ctx context.Context,
//         key string,
//         dest interface{},
//         fallback func() (interface{}, error),
//         ttl time.Duration,
// ) error {
//         // 1. 先查缓存
//         err := r.Get(ctx, key, dest)
//         if err == nil {
//                 return nil
//         }

//         // 2. 获取分布式锁（防击穿）
//         lockKey := "lock:" + key
//         if !r.Lock(ctx, lockKey, 10*time.Second) {
//                 return errors.New("操作过于频繁")
//         }
//         defer r.Unlock(ctx, lockKey)

//         // 3. 回源查询
//         data, err := fallback()
//         if err != nil {
//                 return err
//         }

//         // 4. 写入缓存
//         return r.Set(ctx, key, data, ttl)
// }

// func (r *redisRepo) Lock(ctx context.Context, key string, expiration time.Duration) bool {
//         return r.data.redis.SetNX(ctx, key, 1, expiration).Val()
// }

// func (r *redisRepo) Unlock(ctx context.Context, key string) {
//         r.data.redis.Del(ctx, key)
// }

// other method：HSet/HGet、LPush/LRange、Incr 等...
</pre>
		
		<pre class="file" id="file38" style="display: none">package dingtalk

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "nancalacc/internal/auth"
        "nancalacc/internal/conf"
        "nancalacc/internal/pkg/utils"
        "nancalacc/pkg/httputil"
        "sync"
        "time"

        openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
        dingtalkcontact_1_0 "github.com/alibabacloud-go/dingtalk/contact_1_0"
        dingtalkoauth2_1_0 "github.com/alibabacloud-go/dingtalk/oauth2_1_0"
        util "github.com/alibabacloud-go/tea-utils/v2/service"
        "github.com/alibabacloud-go/tea/tea"
        "github.com/go-kratos/kratos/v2/log"
)

type dingTalkRepo struct {
        data      *conf.Auth_Dingtalk
        log       *log.Helper
        tokenAuth auth.Authenticator
        // unifiedAuthService auth.UnifiedAuthService
        dingtalkCli *dingtalkoauth2_1_0.Client

        dingtalkCliContact *dingtalkcontact_1_0.Client
}

func NewDingTalkRepo(logger log.Logger) Dingtalk <span class="cov0" title="0">{

        config := &amp;openapi.Config{
                Protocol: tea.String("https"),
                RegionId: tea.String("central"),
        }
        client, err := dingtalkoauth2_1_0.NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("NewClient err: %v", err)
                //return nil, cleanup, err
                logger.Log(log.LevelError, "NewClientErr", err)
        }</span>

        <span class="cov0" title="0">clientContact, err := dingtalkcontact_1_0.NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("NewClient err: %v", err)
                //return nil, cleanup, err
                logger.Log(log.LevelError, "NewClientErr", err)
        }</span>
        <span class="cov0" title="0">tokenAuth := auth.NewDingTalkAuthenticator()

        return &amp;dingTalkRepo{
                dingtalkCli:        client,
                tokenAuth:          tokenAuth,
                dingtalkCliContact: clientContact,
                data:               conf.Get().GetAuth().GetDingtalk(),
                log:                log.NewHelper(log.With(logger, "module", "data/dingtalk")),
        }</span>
}

func (r *dingTalkRepo) GetAccessToken(ctx context.Context) (*auth.AccessTokenResp, error) <span class="cov0" title="0">{

        return r.tokenAuth.GetAccessToken(ctx)
        //         log := r.log.WithContext(ctx)
        //         log.Info("GetAccessToken")

        //         request := &amp;dingtalkoauth2_1_0.GetAccessTokenRequest{
        //                 AppKey:    tea.String(r.data.AppKey),
        //                 AppSecret: tea.String(r.data.AppSecret),
        //         }

        //         var accessToken dingtalkoauth2_1_0.GetAccessTokenResponseBody

        //         tryErr := func() error {
        //                 defer func() {
        //                         if r := tea.Recover(recover()); r != nil {
        //                                 err := r
        //                                 fmt.Printf("恢复的错误: %v\n", err)
        //                         }
        //                 }()

        //                 response, err := r.dingtalkCli.GetAccessToken(request)
        //                 if err != nil {
        //                         return err
        //                 }

        //                 accessToken = *response.Body
        //                 return nil
        //         }()

        //         if tryErr != nil {
        //                 // 处理错误
        //                 var sdkErr = &amp;tea.SDKError{}
        //                 if _t, ok := tryErr.(*tea.SDKError); ok {
        //                         sdkErr = _t
        //                 } else {
        //                         sdkErr.Message = tea.String(tryErr.Error())
        //                 }

        //                 if !tea.BoolValue(util.Empty(sdkErr.Code)) &amp;&amp; !tea.BoolValue(util.Empty(sdkErr.Message)) {
        //                         return accessToken, fmt.Errorf("获取access_token失败: [%s] %s", *sdkErr.Code, *sdkErr.Message)
        //                 }
        //                 return accessToken, fmt.Errorf("获取access_token失败: %s", *sdkErr.Message)
        //         }

        // return accessToken, nil
}</span>
func (r *dingTalkRepo) FetchDepartments(ctx context.Context, token string) ([]*DingtalkDept, error) <span class="cov0" title="0">{

        log := r.log.WithContext(ctx)
        log.Infof("FetchDepartments token:%s", token)

        var deptList []*DingtalkDept

        var deptIdlist []int64
        var baseDeptId int64 = 1
        // 1. 获取子部门ID列表（所有）
        deptIdsLevelOne, err := r.getDeptIds(ctx, token, baseDeptId)
        log.Infof("FetchDepartments deptIdsLevelOne: %v, err: %v", deptIdsLevelOne, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">deptIdlist = append(deptIdlist, baseDeptId)

        log.Infof("FetchDepartments deptIdlist: %v", deptIdlist)
        if len(deptIdsLevelOne) &gt; 0 </span><span class="cov0" title="0">{
                log.Info("len(deptIdsLevelOne) &gt; 0")
                deptIdlist = append(deptIdlist, deptIdsLevelOne...)
                deptIdsLeveltwo, err := r.getDeptIdsConcurrent(ctx, token, deptIdsLevelOne)

                log.Infof("FetchDepartments deptIdsLeveltwo: %v, err: %v", deptIdsLeveltwo, err)

                if err != nil </span><span class="cov0" title="0">{
                        log.Error("getDeptIdsConcurrent failed, err: %v", err)
                }</span>
                <span class="cov0" title="0">if len(deptIdsLeveltwo) &gt; 0 </span><span class="cov0" title="0">{
                        deptIdlist = append(deptIdlist, deptIdsLeveltwo...)
                }</span>
        }

        <span class="cov0" title="0">log.Info("FetchDepartments.deptIdlist: %v", deptIdlist)
        // 2. 获取子部门详情
        deptList, err = r.FetchDeptDetails(ctx, token, deptIdlist)
        log.Infof("FetchDepartments deptList: %v, err: %v", deptList, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return deptList, nil</span>
}
func (r *dingTalkRepo) getDeptIds(ctx context.Context, token string, deptId int64) ([]int64, error) <span class="cov0" title="0">{

        log := r.log.WithContext(ctx)
        log.Infof("getDeptIds token:%s deptId: %v", token, deptId)

        uri := fmt.Sprintf("%s/topapi/v2/department/listsubid?access_token=%s", r.data.Endpoint, token)
        input := &amp;ListDeptIDRequest{
                DeptID: deptId,
        }
        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">bs, err := httputil.PostJSON(uri, jsonData, time.Second*10)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        //r.log.Info("FetchAccounts.deptList: %v, err: %v", string(bs), err)

        <span class="cov0" title="0">var deptIDResponse *ListDeptIDResponse
        if err = json.Unmarshal(bs, &amp;deptIDResponse); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if deptIDResponse.Errcode != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("钉钉API返回错误: %s, errcode: %d", deptIDResponse.Errmsg, deptIDResponse.Errcode)
        }</span>
        <span class="cov0" title="0">if deptIDResponse.Result.DeptIDList == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("钉钉API返回错误: %s, errcode: %d", deptIDResponse.Errmsg, deptIDResponse.Errcode)
        }</span>
        <span class="cov0" title="0">deptIdlist := deptIDResponse.Result.DeptIDList
        return deptIdlist, nil</span>
}
func (r *dingTalkRepo) getDeptIdsConcurrent(ctx context.Context, token string, deptIds []int64) ([]int64, error) <span class="cov0" title="0">{

        uri := fmt.Sprintf("%s/topapi/v2/department/listsubid?access_token=%s", r.data.Endpoint, token)

        r.log.Info("getDeptIdsConcurrent deptIds: %v, uri: %v", deptIds, uri)
        sem := make(chan struct{}, r.data.MaxConcurrent)
        deptList := make([]int64, 0)
        var mu sync.Mutex

        var wg sync.WaitGroup

        for _, deptId := range deptIds </span><span class="cov0" title="0">{
                wg.Add(1)

                select </span>{
                case sem &lt;- struct{}{}:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        wg.Done()
                        continue</span>
                }

                // 启动goroutine处理任务
                <span class="cov0" title="0">go func(id int64) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                &lt;-sem     // 释放信号量
                                wg.Done() // 通知任务完成
                        }</span>()

                        <span class="cov0" title="0">input := &amp;ListDeptIDRequest{
                                DeptID: id,
                        }
                        jsonData, err := json.Marshal(input)
                        if err != nil </span><span class="cov0" title="0">{
                                r.log.Errorf("getDeptIdsConcurrent.jsonData: %s, err: %v", string(jsonData), err)
                                return
                        }</span>

                        <span class="cov0" title="0">bs, err := httputil.PostJSON(uri, jsonData, time.Second*10)
                        if err != nil </span><span class="cov0" title="0">{
                                r.log.Errorf("getDeptIdsConcurrent.PostJSON: %s, err: %v", string(jsonData), err)
                                return
                        }</span>
                        <span class="cov0" title="0">var deptIDResponse *ListDeptIDResponse
                        if err = json.Unmarshal(bs, &amp;deptIDResponse); err != nil </span><span class="cov0" title="0">{
                                r.log.Errorf("getDeptIdsConcurrent.Unmarshal: %s, err: %v", string(bs), err)
                                return
                        }</span>
                        <span class="cov0" title="0">if deptIDResponse.Errcode != 0 </span><span class="cov0" title="0">{
                                r.log.Errorf("钉钉API返回错误: %s, errcode: %d", deptIDResponse.Errmsg, deptIDResponse.Errcode)
                                return
                        }</span>
                        <span class="cov0" title="0">if deptIDResponse.Result.DeptIDList == nil </span><span class="cov0" title="0">{
                                r.log.Errorf("钉钉API返回错误: %s, errcode: %d", deptIDResponse.Errmsg, deptIDResponse.Errcode)
                                return
                        }</span>
                        <span class="cov0" title="0">deptIdlist := deptIDResponse.Result.DeptIDList

                        mu.Lock()
                        deptList = append(deptList, deptIdlist...)
                        mu.Unlock()</span>
                }(deptId) // 传递当前deptId值
        }
        <span class="cov0" title="0">wg.Wait()

        return deptList, nil</span>
}

func (r *dingTalkRepo) FetchDeptDetails(ctx context.Context, token string, deptIds []int64) ([]*DingtalkDept, error) <span class="cov0" title="0">{
        log := r.log.WithContext(ctx)
        log.Infof("FetchDeptDetails token:%s depIds: %v", token, deptIds)

        uriDetail := fmt.Sprintf("%s/topapi/v2/department/get?access_token=%s", r.data.Endpoint, token)

        sem := make(chan struct{}, r.data.MaxConcurrent)
        results := make(chan *DingtalkDept, len(deptIds))
        //errChan := make(chan error, 1)

        var wg sync.WaitGroup

        for _, deptId := range deptIds </span><span class="cov0" title="0">{
                wg.Add(1)

                select </span>{
                case sem &lt;- struct{}{}:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        wg.Done()
                        continue</span>
                }

                // 启动goroutine处理任务
                <span class="cov0" title="0">go func(id int64) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                &lt;-sem     // 释放信号量
                                wg.Done() // 通知任务完成
                        }</span>()

                        <span class="cov0" title="0">input := &amp;DingtalkDeptRequest{
                                DeptID: id,
                        }
                        jsonData, err := json.Marshal(input)
                        if err != nil </span><span class="cov0" title="0">{
                                r.log.Errorf("FetchDeptDetails.jsonData: %v, err: %v", string(jsonData), err)
                                //errChan &lt;- err
                                return
                        }</span>

                        <span class="cov0" title="0">bs, err := httputil.PostJSON(uriDetail, jsonData, time.Second*10)
                        //r.log.Infof("&gt;&gt;&gt;&gt;FetchDeptDetails.bs: %s, err: %v\n", string(bs), err)
                        if err != nil </span><span class="cov0" title="0">{
                                r.log.Errorf("FetchDeptDetails.PostJSON: %v, err: %v", string(jsonData), err)
                                //errChan &lt;- err
                                return
                        }</span>
                        <span class="cov0" title="0">var deptResponse *DingtalkDeptResponse
                        if err = json.Unmarshal(bs, &amp;deptResponse); err != nil </span><span class="cov0" title="0">{
                                r.log.Errorf("FetchDeptDetails.Unmarshal: %v, err: %v", string(bs), err)
                                //errChan &lt;- err
                                return
                        }</span>
                        <span class="cov0" title="0">if deptResponse.Errcode != 0 </span><span class="cov0" title="0">{
                                r.log.Errorf("FetchDeptDetails.Errcode: %v, err: %v", deptResponse.Errcode, deptResponse.Errmsg)
                                //errChan &lt;- err
                                return
                        }</span>
                        <span class="cov0" title="0">results &lt;- &amp;deptResponse.Result</span>
                }(deptId) // 传递当前deptId值
        }
        <span class="cov0" title="0">wg.Wait()

        close(results)
        //close(errChan)
        var deptList []*DingtalkDept
        for dept := range results </span><span class="cov0" title="0">{
                deptList = append(deptList, dept)
        }</span>

        <span class="cov0" title="0">return deptList, nil</span>

}
func (r *dingTalkRepo) FetchDepartmentUsers(ctx context.Context, token string, deptIds []int64) ([]*DingtalkDeptUser, error) <span class="cov0" title="0">{
        log := r.log.WithContext(ctx)
        log.Infof("FetchDepartmentUsers: %v, %v", token, deptIds)

        // 服务端API.通讯录管理.用户管理.获取部门用户详情
        //maxConcurrent := 10
        sem := make(chan struct{}, r.data.MaxConcurrent)
        results := make(chan *DingtalkDeptUser, len(deptIds))
        // := make(chan error, 1)

        var wg sync.WaitGroup

        for _, deptId := range deptIds </span><span class="cov0" title="0">{
                wg.Add(1)

                select </span>{
                case sem &lt;- struct{}{}:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        wg.Done()
                        continue</span>
                }

                // 启动goroutine处理任务
                <span class="cov0" title="0">go func(id int64) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                &lt;-sem     // 释放信号量
                                wg.Done() // 通知任务完成
                        }</span>()

                        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                                userList, cursor, err := r.getUserListByDepId(ctx, token, id)
                                if err != nil </span><span class="cov0" title="0">{
                                        r.log.Errorf("FetchDepartmentUsers.getUserListByDepId: %v, err: %v", id, err)
                                        //errChan &lt;- err
                                        return
                                }</span>
                                <span class="cov0" title="0">for _, user := range userList </span><span class="cov0" title="0">{
                                        results &lt;- user
                                }</span>
                                <span class="cov0" title="0">if cursor == 0 </span><span class="cov0" title="0">{
                                        break</span>
                                }

                        }
                }(deptId)
        }
        <span class="cov0" title="0">wg.Wait()

        close(results)
        //close(errChan)
        var userList []*DingtalkDeptUser
        usersMap := make(map[string]*DingtalkDeptUser)
        for user := range results </span><span class="cov0" title="0">{
                // log.Infof("FetchDepartmentUsers results user: %+v", user)
                if _, ok := usersMap[user.Userid]; ok </span><span class="cov0" title="0">{
                        usersMap[user.Userid].DeptIDList = append(usersMap[user.Userid].DeptIDList, user.DeptIDList...)
                        usersMap[user.Userid].DeptIDList = utils.RemoveDuplicates(usersMap[user.Userid].DeptIDList)

                }</span>
                <span class="cov0" title="0">usersMap[user.Userid] = user</span>

        }
        <span class="cov0" title="0">for _, u := range usersMap </span><span class="cov0" title="0">{
                // log.Infof("FetchDepartmentUsers usersMap user: %+v", u)
                userList = append(userList, u)
        }</span>
        <span class="cov0" title="0">return userList, nil</span>
}
func (r *dingTalkRepo) getUserListByDepId(ctx context.Context, token string, deptId int64) ([]*DingtalkDeptUser, int64, error) <span class="cov0" title="0">{
        log := r.log.WithContext(ctx)
        log.Infof("getUserListByDepId token: %v,deptId: %v", token, deptId)
        // 发送post请求
        var cursor int64 = 0
        uri := fmt.Sprintf("%s/topapi/v2/user/list?access_token=%s", r.data.Endpoint, token)
        input := &amp;ListDeptUserRequest{
                DeptID: deptId,
                Cursor: cursor,
                Size:   100,
        }
        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        //log.Info("getUserListByDepId.uri: %v, input: %v, jsonData: %v", uri, input, string(jsonData))

        <span class="cov0" title="0">bs, err := httputil.PostJSON(uri, jsonData, time.Second*10)
        log.Info("getUserListByDepId.body: %v, err: %v", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 打印响应体
        //fmt.Println(string(bs))

        <span class="cov0" title="0">var userResponse ListDeptUserResponse
        if err = json.Unmarshal(bs, &amp;userResponse); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">if userResponse.Errcode != 0 </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("钉钉API返回错误: %s, errcode: %v", userResponse.Errmsg, userResponse.Errcode)
        }</span>

        <span class="cov0" title="0">var userList []*DingtalkDeptUser
        if userResponse.Result.List != nil </span><span class="cov0" title="0">{
                userList = make([]*DingtalkDeptUser, 0, len(userResponse.Result.List))
                for _, user := range userResponse.Result.List </span><span class="cov0" title="0">{
                        userList = append(userList, &amp;user)
                }</span>
        }
        <span class="cov0" title="0">if userResponse.Result.HasMore </span><span class="cov0" title="0">{
                return userList, userResponse.Result.NextCursor, nil
        }</span>
        <span class="cov0" title="0">return userList, 0, nil</span>
}
func (r *dingTalkRepo) GetUserAccessToken(ctx context.Context, code string) (*AuthResponse, error) <span class="cov0" title="0">{

        log := r.log.WithContext(ctx)
        log.Infof("GetUserAccessToken code: %v", code)

        getUserTokenRequest := &amp;dingtalkoauth2_1_0.GetUserTokenRequest{

                ClientId:     tea.String(r.data.AppKey),
                ClientSecret: tea.String(r.data.AppSecret),
                Code:         tea.String(code),
                //RefreshToken: tea.String("abcd"),
                GrantType: tea.String("authorization_code"),
        }

        // var accessToken string
        var response *dingtalkoauth2_1_0.GetUserTokenResponse
        var err error
        tryErr := func() (_e error) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if er := tea.Recover(recover()); er != nil </span><span class="cov0" title="0">{
                                _e = er
                        }</span>
                }()
                <span class="cov0" title="0">response, err = r.dingtalkCli.GetUserToken(getUserTokenRequest)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        }()

        <span class="cov0" title="0">if tryErr != nil </span><span class="cov0" title="0">{
                var err = &amp;tea.SDKError{}
                if _t, ok := tryErr.(*tea.SDKError); ok </span><span class="cov0" title="0">{
                        err = _t
                }</span> else<span class="cov0" title="0"> {
                        err.Message = tea.String(tryErr.Error())
                }</span>
                <span class="cov0" title="0">if !tea.BoolValue(util.Empty(err.Code)) &amp;&amp; !tea.BoolValue(util.Empty(err.Message)) </span>{<span class="cov0" title="0">
                        // err 中含有 code 和 message 属性，可帮助开发定位问题
                }</span>

        }
        <span class="cov0" title="0">if response.StatusCode != nil &amp;&amp; *response.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if response.Body == nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tokenAuthResp := &amp;AuthResponse{}
        if response.Body.AccessToken == nil </span><span class="cov0" title="0">{
                return nil, errors.New("response.Body.AccessToken is nil")
        }</span>
        <span class="cov0" title="0">tokenAuthResp.AccessToken = *response.Body.AccessToken
        tokenAuthResp.RefreshToken = *response.Body.RefreshToken
        tokenAuthResp.ExpireIn = int(*response.Body.ExpireIn)

        return tokenAuthResp, nil</span>
}
func (r *dingTalkRepo) GetUserInfo(ctx context.Context, token, unionId string) (*DingTalkUserInfo, error) <span class="cov0" title="0">{

        log := r.log.WithContext(ctx)
        log.Infof("GetUserInfo token: %v, unionId %s", token, unionId)

        getUserHeaders := &amp;dingtalkcontact_1_0.GetUserHeaders{}
        getUserHeaders.XAcsDingtalkAccessToken = tea.String(token)
        var response *dingtalkcontact_1_0.GetUserResponse
        var err error
        tryErr := func() (_e error) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := tea.Recover(recover()); r != nil </span><span class="cov0" title="0">{
                                _e = r
                        }</span>
                }()
                <span class="cov0" title="0">response, err = r.dingtalkCliContact.GetUserWithOptions(tea.String(unionId), getUserHeaders, &amp;util.RuntimeOptions{})

                r.log.WithContext(ctx).Info("response: %v, error: %v", response, err)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if response.Body == nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        }()

        <span class="cov0" title="0">if tryErr != nil </span><span class="cov0" title="0">{
                var err = &amp;tea.SDKError{}
                if _t, ok := tryErr.(*tea.SDKError); ok </span><span class="cov0" title="0">{
                        err = _t
                }</span> else<span class="cov0" title="0"> {
                        err.Message = tea.String(tryErr.Error())
                }</span>
                <span class="cov0" title="0">if !tea.BoolValue(util.Empty(err.Code)) &amp;&amp; !tea.BoolValue(util.Empty(err.Message)) </span><span class="cov0" title="0">{
                        log.Errorf("GetUserInfo error: %v", err)
                        // err 中含有 code 和 message 属性，可帮助开发定位问题
                }</span>

        }

        <span class="cov0" title="0">log.Infof("GetUserInfo response: %v", response)

        return &amp;DingTalkUserInfo{
                UnionId: *response.Body.UnionId,
                Nick:    *response.Body.Nick,
        }, nil</span>
}

func (r *dingTalkRepo) GetUseridByUnionid(ctx context.Context, token, unionid string) (string, error) <span class="cov0" title="0">{

        log := r.log.WithContext(ctx)

        log.Info("GetUseridByUnionid token: %v,unionid %v", token, unionid)
        uri := fmt.Sprintf("%s/topapi/user/getbyunionid?access_token=%s", r.data.Endpoint, token)
        input := &amp;DingTalkUseridByUnionidRequest{
                Unionid: unionid,
        }
        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">bs, err := httputil.PostJSON(uri, jsonData, time.Second*10)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">r.log.Info("GetUseridByUnionid: %v, err: %v", string(bs), err)

        var getUseridByUnionidResponse *DingTalkUseridByUnionidResponse
        if err = json.Unmarshal(bs, &amp;getUseridByUnionidResponse); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if getUseridByUnionidResponse.Errcode != 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("钉钉API返回错误: %s, errcode: %d", getUseridByUnionidResponse.Errmsg, getUseridByUnionidResponse.Errcode)
        }</span>
        <span class="cov0" title="0">if getUseridByUnionidResponse.Result.Userid == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("钉钉API返回错误 Result: %+v, Result.Userid: %s", getUseridByUnionidResponse.Result, getUseridByUnionidResponse.Result.Userid)
        }</span>
        <span class="cov0" title="0">return getUseridByUnionidResponse.Result.Userid, nil</span>
}

func (r *dingTalkRepo) FetchUserDetail(ctx context.Context, token string, userIds []string) ([]*DingtalkDeptUser, error) <span class="cov0" title="0">{
        log := r.log.WithContext(ctx)

        log.Infof("FetchUserDetail token: %s, userIds: %v", token, userIds)
        uri := fmt.Sprintf("%s/topapi/v2/user/get?access_token=%s", r.data.Endpoint, token)

        log.Info("FetchUserDetail deptIds: %v, uri: %v", userIds, uri)
        sem := make(chan struct{}, r.data.MaxConcurrent)
        userList := make([]*DingtalkDeptUser, 0)
        var mu sync.Mutex

        var wg sync.WaitGroup

        for _, userId := range userIds </span><span class="cov0" title="0">{
                wg.Add(1)

                select </span>{
                case sem &lt;- struct{}{}:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        wg.Done()
                        continue</span>
                }

                // 启动goroutine处理任务
                <span class="cov0" title="0">go func(id string) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                &lt;-sem     // 释放信号量
                                wg.Done() // 通知任务完成
                        }</span>()

                        <span class="cov0" title="0">input := &amp;DingTalkUserDetailRequest{
                                Userid: id,
                        }
                        jsonData, err := json.Marshal(input)
                        if err != nil </span><span class="cov0" title="0">{
                                r.log.Errorf("GetUserDetail.jsonData: %v, err: %v", string(jsonData), err)
                                return
                        }</span>

                        <span class="cov0" title="0">bs, err := httputil.PostJSON(uri, jsonData, time.Second*10)
                        r.log.Infof("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;GetUserDetail.PostJSON: %v, err: %v\n", string(bs), err)
                        if err != nil </span><span class="cov0" title="0">{
                                r.log.Errorf("GetUserDetail.PostJSON: %v, err: %v", string(bs), err)
                                return
                        }</span>
                        <span class="cov0" title="0">var userDetail *DingTalkUserDetailResponse
                        if err = json.Unmarshal(bs, &amp;userDetail); err != nil </span><span class="cov0" title="0">{
                                r.log.Errorf("GetUserDetail.Unmarshal: %v, err: %v", string(bs), err)
                                return
                        }</span>
                        <span class="cov0" title="0">if userDetail.Errcode != 0 </span><span class="cov0" title="0">{
                                r.log.Errorf("钉钉API返回错误: %s, errcode: %d", userDetail.Errmsg, userDetail.Errcode)
                                return
                        }</span>
                        <span class="cov0" title="0">user := userDetail.Result
                        //r.log.Info("GetUserDetail user: %v", user)
                        mu.Lock()
                        userList = append(userList, &amp;user)
                        mu.Unlock()</span>
                }(userId)
        }
        <span class="cov0" title="0">wg.Wait()

        return userList, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package dingtalk

import (
        "context"
        "errors"
)

func ValidateDingTalkUser(ctx context.Context, user *DingtalkDeptUser) error <span class="cov0" title="0">{
        if user.Name == "" </span><span class="cov0" title="0">{
                return errors.New("DingtalkDeptUser userid is empty")
        }</span>
        <span class="cov0" title="0">if user.Mobile == "" </span><span class="cov0" title="0">{
                return errors.New("DingtalkDeptUser mobile is empty")
        }</span>
        <span class="cov0" title="0">if len(user.DeptIDList) == 0 </span><span class="cov0" title="0">{
                return errors.New("DingtalkDeptUser deptid is empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package middleware

import (
        "context"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/go-kratos/kratos/v2/middleware"
        "github.com/go-kratos/kratos/v2/transport"
)

// LogMiddleware 日志中间件
func LogMiddleware(logger log.Logger) middleware.Middleware <span class="cov0" title="0">{
        return func(handler middleware.Handler) middleware.Handler </span><span class="cov0" title="0">{
                return func(ctx context.Context, req interface{}) (reply interface{}, err error) </span><span class="cov0" title="0">{
                        var (
                                start = time.Now()
                                tr    transport.Transporter
                        )

                        if info, ok := transport.FromServerContext(ctx); ok </span><span class="cov0" title="0">{
                                tr = info
                        }</span>

                        // 记录请求开始
                        <span class="cov0" title="0">logger.Log(log.LevelInfo,
                                "msg", "request started",
                                "method", tr.Operation(),
                                "path", tr.Endpoint(),
                                "args", req,
                        )

                        // 处理请求
                        reply, err = handler(ctx, req)

                        // 记录请求结束
                        logger.Log(log.LevelInfo,
                                "msg", "request finished",
                                "method", tr.Operation(),
                                "path", tr.Endpoint(),
                                "duration", time.Since(start).String(),
                                "error", err,
                        )

                        return</span>
                }
        }
}

// ErrorHandler 统一错误处理中间件
func ErrorHandler(logger log.Logger) middleware.Middleware <span class="cov0" title="0">{
        return func(handler middleware.Handler) middleware.Handler </span><span class="cov0" title="0">{
                return func(ctx context.Context, req interface{}) (reply interface{}, err error) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        logger.Log(log.LevelError,
                                                "msg", "panic recovered",
                                                "panic", r,
                                        )
                                        err = &amp;PanicError{Panic: r}
                                }</span>
                        }()

                        <span class="cov0" title="0">return handler(ctx, req)</span>
                }
        }
}

// PanicError 自定义panic错误类型
type PanicError struct {
        Panic interface{}
}

func (e *PanicError) Error() string <span class="cov0" title="0">{
        return "panic occurred"
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package cache

import (
        "context"
        "time"

        "github.com/go-redis/redis/v8"
)

type RedisCache struct {
        client *redis.Client
}

func NewRedisCache(client *redis.Client) *RedisCache <span class="cov0" title="0">{
        return &amp;RedisCache{client: client}
}</span>

func (r *RedisCache) Get(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        return r.client.Get(ctx, key).Result()
}</span>

func (r *RedisCache) Set(ctx context.Context, key string, value string, ttl time.Duration) error <span class="cov0" title="0">{
        return r.client.Set(ctx, key, value, ttl).Err()
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package cipherutil

import (
        "bytes"
        "crypto/aes"
        "crypto/cipher"
        "crypto/md5"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "encoding/hex"
        "errors"
        "fmt"
        "nancalacc/internal/conf"
)

var (
        ErrEmptyPlaintext          = errors.New("empty plaintext")
        ErrInvalidPadding          = errors.New("invalid padding")
        ErrInvalidPaddingBlockSize = errors.New("invalid padding block size")
        ErrInvalidKey              = errors.New("invalid key")
        ErrIVGeneration            = errors.New("failed to generate initialization vector")
        ErrDecryptFailed           = errors.New("decrypt failed")
        ErrMD5WriteFailed          = errors.New("md5 write failed")
        ErrInvalidInput            = errors.New("invalid input")
        ErrAesCipher               = errors.New("aes cipher creation failed")

        ErrNonceGeneration   = errors.New("failed to generate nonce")
        ErrCipherCreation    = errors.New("failed to create AES cipher")
        ErrGCMCreation       = errors.New("failed to create GCM instance")
        ErrInvalidCiphertext = errors.New("ciphertext too short or invalid")
        ErrDecryptionFailed  = errors.New("decryption failed")
)

// GetAppUID 获取应用UID，优先从环境变量获取，否则使用默认值
func GetAppUID() string <span class="cov0" title="0">{
        uid := conf.GetEnvWithDefault("APP_UID", "nancalacc-426614174000")
        return uid
}</span>

func DecryptByAes(content string, key string) (string, error) <span class="cov0" title="0">{
        fmt.Printf("DecryptByAes.content: %s\n", content)
        fmt.Printf("DecryptByAes.key: %s\n", key)

        if len(content) &lt; 24 </span><span class="cov0" title="0">{
                return "", ErrEmptyPlaintext
        }</span>
        <span class="cov0" title="0">if len(key) == 0 </span><span class="cov0" title="0">{
                return "", ErrInvalidKey
        }</span>
        <span class="cov0" title="0">h := md5.New()
        if _, err := h.Write([]byte(key)); err != nil </span><span class="cov0" title="0">{
                return "", ErrMD5WriteFailed
        }</span>
        <span class="cov0" title="0">akey := hex.EncodeToString(h.Sum(nil))
        enDataFromBase64, err := base64.StdEncoding.DecodeString(content)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if len(enDataFromBase64) == 0 || len(enDataFromBase64)%aes.BlockSize != 0 </span><span class="cov0" title="0">{
                return "", ErrInvalidInput
        }</span>

        <span class="cov0" title="0">block, err := aes.NewCipher([]byte(akey))
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrAesCipher
        }</span>
        <span class="cov0" title="0">iv := []byte(akey)[:aes.BlockSize]
        decrypter := cipher.NewCBCDecrypter(block, iv)
        dst := make([]byte, len(enDataFromBase64))
        decrypter.CryptBlocks(dst, enDataFromBase64)
        length := len(dst)
        unpadding := int(dst[length-1])
        if length &lt; unpadding </span><span class="cov0" title="0">{
                return "", ErrInvalidPadding
        }</span>
        <span class="cov0" title="0">res := string(dst[:(length - unpadding)])
        return res, nil</span>
}

func EncryptByAes(content string, key string) (string, error) <span class="cov0" title="0">{
        fmt.Printf("EncryptByAes.content: %s\n", content)
        fmt.Printf("EncryptByAes.key: %s\n", key)

        if len(content) == 0 </span><span class="cov0" title="0">{
                return "", ErrEmptyPlaintext
        }</span>
        <span class="cov0" title="0">if len(key) == 0 </span><span class="cov0" title="0">{
                return "", ErrInvalidKey
        }</span>

        <span class="cov0" title="0">h := md5.New()
        if _, err := h.Write([]byte(key)); err != nil </span><span class="cov0" title="0">{
                return "", ErrMD5WriteFailed
        }</span>
        <span class="cov0" title="0">akey := hex.EncodeToString(h.Sum(nil))

        block, err := aes.NewCipher([]byte(akey))
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrAesCipher
        }</span>

        <span class="cov0" title="0">iv := []byte(akey)[:aes.BlockSize]

        plaintext := []byte(content)
        padding := aes.BlockSize - len(plaintext)%aes.BlockSize
        padtext := append(plaintext, bytes.Repeat([]byte{byte(padding)}, padding)...)

        ciphertext := make([]byte, len(padtext))
        encrypter := cipher.NewCBCEncrypter(block, iv)
        encrypter.CryptBlocks(ciphertext, padtext)

        return base64.StdEncoding.EncodeToString(ciphertext), nil</span>
}

func Encrypt(plaintext string, key []byte) (string, error) <span class="cov0" title="0">{
        if len(key) != 32 </span><span class="cov0" title="0">{
                return "", ErrInvalidKey
        }</span>
        <span class="cov0" title="0">if plaintext == "" </span><span class="cov0" title="0">{
                return "", ErrEmptyPlaintext
        }</span>

        <span class="cov0" title="0">nonce := make([]byte, 12)
        if _, err := rand.Read(nonce); err != nil </span><span class="cov0" title="0">{
                return "", ErrNonceGeneration
        }</span>

        <span class="cov0" title="0">block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrCipherCreation
        }</span>

        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrGCMCreation
        }</span>

        <span class="cov0" title="0">ciphertext := gcm.Seal(nil, nonce, []byte(plaintext), nil)
        encrypted := append(nonce, ciphertext...)
        return base64.StdEncoding.EncodeToString(encrypted), nil</span>
}

func Decrypt(ciphertext string, key []byte) (string, error) <span class="cov0" title="0">{
        if len(key) != 32 </span><span class="cov0" title="0">{
                return "", ErrInvalidKey
        }</span>

        <span class="cov0" title="0">encryptedData, err := base64.StdEncoding.DecodeString(ciphertext)
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrInvalidCiphertext
        }</span>

        <span class="cov0" title="0">if len(encryptedData) &lt; 12 </span><span class="cov0" title="0">{
                return "", ErrInvalidCiphertext
        }</span>

        <span class="cov0" title="0">nonce := encryptedData[:12]
        data := encryptedData[12:]

        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrCipherCreation
        }</span>

        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrGCMCreation
        }</span>

        <span class="cov0" title="0">plaintext, err := gcm.Open(nil, nonce, data, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrDecryptionFailed
        }</span>

        <span class="cov0" title="0">return string(plaintext), nil</span>
}

func GenerateKey(uid, salt string) string <span class="cov0" title="0">{
        h := sha256.New()
        h.Write([]byte(uid + salt))
        hash := hex.EncodeToString(h.Sum(nil))
        return hash[:32]
}</span>

func EncryptValueWithEnvSalt(plaintext string) (string, error) <span class="cov0" title="0">{
        if plaintext == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">salt, err := conf.GetEnv("ENCRYPTION_SALT")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get encryption salt: %w", err)
        }</span>

        <span class="cov0" title="0">uid := GetAppUID()
        envKey := GenerateKey(uid, salt)
        if len(envKey) != 32 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("generated key must be 32 bytes, got %d", len(envKey))
        }</span>

        <span class="cov0" title="0">encrypted, err := Encrypt(plaintext, []byte(envKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("encryption failed: %w", err)
        }</span>
        <span class="cov0" title="0">return encrypted, nil</span>
}

func DecryptValueWithEnvSalt(ciphertext string) (string, error) <span class="cov0" title="0">{
        if ciphertext == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">salt, err := conf.GetEnv("ENCRYPTION_SALT")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get encryption salt: %w", err)
        }</span>

        <span class="cov0" title="0">uid := GetAppUID()
        envKey := GenerateKey(uid, salt)
        if len(envKey) != 32 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("generated key must be 32 bytes, got %d", len(envKey))
        }</span>

        <span class="cov0" title="0">decrypted, err := Decrypt(ciphertext, []byte(envKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("decryption failed: %w", err)
        }</span>
        <span class="cov0" title="0">return decrypted, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package fileutil

import (
        "fmt"
        "log"

        "github.com/xuri/excelize/v2"
)

func ReadFile(filename string) <span class="cov0" title="0">{
        // 打开Excel文件
        f, err := excelize.OpenFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        }()

        // 获取工作表列表
        <span class="cov0" title="0">sheets := f.GetSheetList()

        // 读取第一个工作表的数据
        for _, sheet := range sheets </span><span class="cov0" title="0">{
                fmt.Printf("工作表名称: %s\n", sheet)
                rows, err := f.GetRows(sheet)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">for _, row := range rows </span><span class="cov0" title="0">{
                        for _, colCell := range row </span><span class="cov0" title="0">{
                                fmt.Print(colCell, "\t")
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// internal/pkg/limiter/rate_limiter.go
package limiter

import (
        "sync"

        "golang.org/x/time/rate"
)

type RateLimiter struct {
        limiters map[string]*rate.Limiter
        mu       sync.RWMutex
}

func NewRateLimiter() *RateLimiter <span class="cov0" title="0">{
        return &amp;RateLimiter{
                limiters: make(map[string]*rate.Limiter),
        }
}</span>

func (rl *RateLimiter) GetLimiter(key string, r rate.Limit, b int) *rate.Limiter <span class="cov0" title="0">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        if limiter, exists := rl.limiters[key]; exists </span><span class="cov0" title="0">{
                return limiter
        }</span>

        <span class="cov0" title="0">limiter := rate.NewLimiter(r, b)
        rl.limiters[key] = limiter
        return limiter</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package utils

func RemoveDuplicates[T comparable](slice []T) []T <span class="cov0" title="0">{
        seen := make(map[T]struct{})
        result := make([]T, 0, len(slice))

        for _, item := range slice </span><span class="cov0" title="0">{
                if _, exists := seen[item]; !exists </span><span class="cov0" title="0">{
                        seen[item] = struct{}{}
                        result = append(result, item)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func RemoveDuplicatesBy[T any, K comparable](slice []T, keyFunc func(T) K) []T <span class="cov0" title="0">{
        seen := make(map[K]struct{})
        result := make([]T, 0, len(slice))

        for _, item := range slice </span><span class="cov0" title="0">{
                key := keyFunc(item)
                if _, exists := seen[key]; !exists </span><span class="cov0" title="0">{
                        seen[key] = struct{}{}
                        result = append(result, item)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func Contains[T comparable](slice []T, target T) bool <span class="cov0" title="0">{
        for _, item := range slice </span><span class="cov0" title="0">{
                if item == target </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// 使用示例：
// nums := []int{1, 2, 3, 4, 5}
// fmt.Println(Contains(nums, 3)) // true
// fmt.Println(Contains(nums, 6)) // false
</pre>
		
		<pre class="file" id="file46" style="display: none">package server

import (
        v1 "nancalacc/api/account/v1"
        "nancalacc/internal/conf"
        "nancalacc/internal/service"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/go-kratos/kratos/v2/middleware/recovery"
        "github.com/go-kratos/kratos/v2/middleware/tracing"
        "github.com/go-kratos/kratos/v2/transport/grpc"

        "google.golang.org/grpc/health"
        "google.golang.org/grpc/health/grpc_health_v1"
)

// NewGRPCServer new a gRPC server.
func NewGRPCServer(c *conf.Server, accountService *service.AccountService, logger log.Logger) *grpc.Server <span class="cov0" title="0">{
        var opts = []grpc.ServerOption{
                grpc.Middleware(
                        recovery.Recovery(),
                        tracing.Server(),
                ),
        }
        if c.Grpc.Network != "" </span><span class="cov0" title="0">{
                opts = append(opts, grpc.Network(c.Grpc.Network))
        }</span>
        <span class="cov0" title="0">if c.Grpc.Addr != "" </span><span class="cov0" title="0">{
                opts = append(opts, grpc.Address(c.Grpc.Addr))
        }</span>
        <span class="cov0" title="0">if c.Grpc.Timeout != nil </span><span class="cov0" title="0">{
                opts = append(opts, grpc.Timeout(c.Grpc.Timeout.AsDuration()))
        }</span>
        <span class="cov0" title="0">srv := grpc.NewServer(opts...)

        healthCheck := health.NewServer()
        healthCheck.SetServingStatus("nancalacc.account.v1.asyncacc", grpc_health_v1.HealthCheckResponse_SERVING)
        v1.RegisterAccountServer(srv, accountService)
        return srv</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package server

import (
        "io"
        v1 "nancalacc/api/account/v1"
        "nancalacc/internal/conf"
        "nancalacc/internal/service"

        nethttp "net/http"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/go-kratos/kratos/v2/middleware/recovery"
        "github.com/go-kratos/kratos/v2/middleware/tracing"
        "github.com/go-kratos/kratos/v2/transport/http"
)

// NewHTTPServer new an HTTP server.
func NewHTTPServer(c *conf.Server, accountService *service.AccountService, logger log.Logger) *http.Server <span class="cov0" title="0">{
        var opts = []http.ServerOption{
                http.Middleware(
                        recovery.Recovery(),
                        tracing.Server(),
                ),

                http.RequestDecoder(func(r *http.Request, v interface{}) error </span><span class="cov0" title="0">{
                        if r.URL.Path == "/v1/upload" </span><span class="cov0" title="0">{
                                data, err := io.ReadAll(r.Body)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if req, ok := v.(*v1.UploadRequest); ok </span><span class="cov0" title="0">{
                                        req.File = data
                                        if filename := r.Header.Get("X-Filename"); filename != "" </span><span class="cov0" title="0">{
                                                req.Filename = filename
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }
                        }
                        <span class="cov0" title="0">return http.DefaultRequestDecoder(r, v)</span>
                }),
        }
        <span class="cov0" title="0">if c.Http.Network != "" </span><span class="cov0" title="0">{
                opts = append(opts, http.Network(c.Http.Network))
        }</span>
        <span class="cov0" title="0">if c.Http.Addr != "" </span><span class="cov0" title="0">{
                opts = append(opts, http.Address(c.Http.Addr))
        }</span>
        <span class="cov0" title="0">if c.Http.Timeout != nil </span><span class="cov0" title="0">{
                opts = append(opts, http.Timeout(c.Http.Timeout.AsDuration()))
        }</span>
        <span class="cov0" title="0">srv := http.NewServer(opts...)
        v1.RegisterAccountHTTPServer(srv, accountService)
        // 添加健康检查路由
        srv.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(nethttp.StatusOK)
                w.Write([]byte("OK"))
        }</span>)
        <span class="cov0" title="0">return srv</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package service

import (
        "context"
        "errors"
        "os"
        "path/filepath"
        "time"

        v1 "nancalacc/api/account/v1"
        "nancalacc/internal/biz"
        "nancalacc/internal/conf"
        "nancalacc/internal/pkg/limiter"

        "github.com/go-kratos/kratos/v2/log"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
)

type AccountService struct {
        v1.UnimplementedAccountServer
        accounterUsecase *biz.AccounterUsecase
        oauth2Usecase    *biz.Oauth2Usecase
        fullSyncUsecase  *biz.FullSyncUsecase
        limiter          *limiter.RateLimiter
        log              *log.Helper
}

func NewAccountService(accounterUsecase *biz.AccounterUsecase, oauth2Usecase *biz.Oauth2Usecase, fullSyncUsecase *biz.FullSyncUsecase, logger log.Logger) *AccountService <span class="cov0" title="0">{
        limiter := limiter.NewRateLimiter()
        return &amp;AccountService{accounterUsecase: accounterUsecase, oauth2Usecase: oauth2Usecase, fullSyncUsecase: fullSyncUsecase, limiter: limiter, log: log.NewHelper(logger)}
}</span>

func (s *AccountService) CreateSyncAccount(ctx context.Context, req *v1.CreateSyncAccountRequest) (*v1.CreateSyncAccountReply, error) <span class="cov0" title="0">{
        log := s.log.WithContext(ctx)
        log.Infof("CreateSyncAccount req: %v", req)
        if req.GetTaskName() != "" &amp;&amp; len(req.GetTaskName()) != 14 </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "invalid taskname: %s", req.GetTaskName())
        }</span>
        <span class="cov0" title="0">if req.GetTaskName() == "" </span><span class="cov0" title="0">{
                taskId := time.Now().Add(time.Duration(1) * time.Second).Format("20060102150405")
                req.TaskName = &amp;taskId
        }</span>
        // 这里设置传进来的最大分钟数
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, 50*time.Minute)
        defer cancel()
        return s.fullSyncUsecase.CreateSyncAccount(ctx, req)</span>
}
func (s *AccountService) GetSyncAccount(ctx context.Context, req *v1.GetSyncAccountRequest) (*v1.GetSyncAccountReply, error) <span class="cov0" title="0">{

        log.Infof("GetSyncAccount req: %v", req)
        globalConf := conf.Get()
        log.Infof("globalConf: %v", globalConf)
        ctx, cancel := context.WithTimeout(ctx, 50*time.Minute)
        defer cancel()
        return s.fullSyncUsecase.GetSyncAccount(ctx, req)
}</span>
func (s *AccountService) CancelSyncTask(ctx context.Context, req *v1.CancelSyncAccountRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        log := s.log.WithContext(ctx)
        log.Infof("CancelSyncTask req: %v", req)
        if req.TaskId == "" </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "task_id is empty")
        }</span>
        <span class="cov0" title="0">err := s.fullSyncUsecase.CleanSyncAccount(ctx, req.TaskId, req.GetTags())

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}
func (s *AccountService) GetUserInfo(ctx context.Context, req *v1.GetUserInfoRequest) (*v1.GetUserInfoResponse, error) <span class="cov0" title="0">{

        log := s.log.WithContext(ctx)
        log.Infof("GetUserInfo req: %v", req)

        accessToken := req.GetAccessToken()
        if accessToken == "" </span><span class="cov0" title="0">{
                return nil, errors.New("access_token is empty")
        }</span>
        <span class="cov0" title="0">userInfo, err := s.oauth2Usecase.GetUserInfo(ctx, &amp;v1.GetUserInfoRequest{
                AccessToken: accessToken,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return userInfo, nil</span>
}
func (s *AccountService) GetAccessToken(ctx context.Context, req *v1.GetAccessTokenRequest) (*v1.GetAccessTokenResponse, error) <span class="cov0" title="0">{

        log := s.log.WithContext(ctx)
        log.Infof("GetAccessToken req: %v", req)

        code := req.GetCode()
        if code == "" </span><span class="cov0" title="0">{
                return nil, errors.New("code is empty")
        }</span>
        <span class="cov0" title="0">accessTokenResp, err := s.oauth2Usecase.GetAccessToken(ctx, &amp;v1.GetAccessTokenRequest{
                Code: code,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return accessTokenResp, nil</span>
}

func (s *AccountService) Callback(ctx context.Context, req *v1.CallbackRequest) (*v1.CallbackResponse, error) <span class="cov0" title="0">{
        log := s.log.WithContext(ctx)
        log.Infof("Callback req: %v", req)

        globalConf := conf.Get()
        log.Infof("globalConf: %v", globalConf)
        return &amp;v1.CallbackResponse{
                Status:  "success",
                Message: "success",
        }, nil
}</span>

//        curl -X POST "http://your-server/v1/upload/excel" \
//          -H "X-Filename: test.xlsx" \
//          --data-binary "@/path/to/your/file.xlsx"

func (s *AccountService) UploadFile(ctx context.Context, req *v1.UploadRequest) (*v1.UploadReply, error) <span class="cov0" title="0">{

        log := s.log.WithContext(ctx)
        log.Infof("UploadFile req: %v", req)

        taskId := time.Now().Add(time.Duration(1) * time.Second).Format("20060102150405")

        if req.GetFile() == nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "file is empty")
        }</span>

        // 检查文件类型
        // if req.GetFile().GetContentType() != "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" {
        //         return nil, status.Errorf(codes.InvalidArgument, "file type is not excel")
        // }

        // // 检查文件大小
        // if req.GetFile().GetSize() &gt; 10*1024*1024 {
        //         return nil, status.Errorf(codes.InvalidArgument, "file size is too large")
        // }

        // 创建临时文件
        <span class="cov0" title="0">tempDir := os.TempDir()
        filename := filepath.Join(tempDir, taskId+".xlsx")

        // 写入文件
        err := os.WriteFile(filename, req.GetFile(), 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "failed to write file: %v", err)
        }</span>

        // 解析Excel文件 - 使用带超时的context
        <span class="cov0" title="0">parseCtx, cancel := context.WithTimeout(context.Background(), 30*time.Minute)
        defer cancel()

        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                log.Errorf("ParseExecell panic: %v", r)
                        }</span>
                }()
                <span class="cov0" title="0">s.fullSyncUsecase.ParseExecell(parseCtx, taskId, filename)</span>
        }()
        // if err != nil {
        //         return nil, status.Errorf(codes.Internal, "failed to parse excel: %v", err)
        // }
        <span class="cov0" title="0">s.accounterUsecase.CreateCacheTask(ctx, taskId, "")
        return &amp;v1.UploadReply{
                //Message: "Upload success",
                Task: taskId,
        }, nil</span>
}

func (s *AccountService) GetTask(ctx context.Context, in *v1.GetTaskRequest) (*v1.GetTaskReply, error) <span class="cov0" title="0">{

        log := s.log.WithContext(ctx)
        log.Infof("GetAccessToken req: %v", in)

        taskName := in.GetTaskName()
        if taskName == "" </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "taskName empty")
        }</span>

        <span class="cov0" title="0">if len(taskName) != 14 </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "taskName invalid")
        }</span>

        <span class="cov0" title="0">task, err := s.accounterUsecase.GetTask(ctx, taskName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "create task failed: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;v1.GetTaskReply{
                Task: task,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package service

import (
        "context"
        "nancalacc/internal/biz"
        "nancalacc/internal/conf"
        "sync/atomic"

        "github.com/go-kratos/kratos/v2/log"
        clientV2 "github.com/open-dingtalk/dingtalk-stream-sdk-go/clientV2"
)

type DingTalkEventService struct {
        cfg                    *conf.Auth_Dingtalk
        log                    *log.Helper
        incrementalSyncUsecase *biz.IncrementalSyncUsecase
        running                atomic.Bool
        cancel                 context.CancelFunc
        //client clientV2.OpenDingTalkClient
}

func NewDingTalkEventService(incrementalSyncUsecase *biz.IncrementalSyncUsecase, logger log.Logger) *DingTalkEventService <span class="cov0" title="0">{
        cfg := conf.Get().GetAuth().GetDingtalk()
        return &amp;DingTalkEventService{cfg: cfg, log: log.NewHelper(logger), incrementalSyncUsecase: incrementalSyncUsecase}
}</span>

func (es *DingTalkEventService) Start() <span class="cov0" title="0">{
        log.Info(es.cfg)

        cred := &amp;clientV2.AuthClientCredential{
                ClientId:     es.cfg.AppKey,
                ClientSecret: es.cfg.AppSecret,
        }

        ctx, cancel := context.WithCancel(context.Background())
        es.cancel = cancel
        es.running.Store(true)
        go func() </span><span class="cov0" title="0">{
                defer es.running.Store(false)
                e := clientV2.
                        NewBuilder().
                        Credential(cred).
                        //监听开放平台事件
                        RegisterAllEventHandler(es.HandleEvent).
                        Build().
                        Start(ctx)
                if e != nil </span><span class="cov0" title="0">{
                        log.Error("DingTalkEventService.Start failed", e.Error())
                }</span>
                <span class="cov0" title="0">log.Info("DingTalkEventService Start")</span>
        }()
        <span class="cov0" title="0">log.Info("DingTalkEventService.Starting...")</span>

}
func (es *DingTalkEventService) Stop() <span class="cov0" title="0">{
        if !es.running.Load() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">log.Info("=====DingTalkEventService.Stop===")
        es.cancel()</span>
}
func (es *DingTalkEventService) Running() bool <span class="cov0" title="0">{
        return es.running.Load()

}</span>

func (es *DingTalkEventService) HandleEvent(event *clientV2.GenericOpenDingTalkEvent) clientV2.EventStatus <span class="cov0" title="0">{
        println("HandleEvent ", event.Data)

        ctx := context.Background()
        switch event.EventType </span>{
        case "org_dept_create":<span class="cov0" title="0">
                es.log.Infof("org_dept_create: %v", event.Data)
                es.OrgDeptCreate(ctx, event)</span>
        case "org_dept_modify":<span class="cov0" title="0">
                es.log.Infof("org_dept_modify: %v", event.Data)
                es.OrgDeptModify(ctx, event)</span>
        case "org_dept_remove":<span class="cov0" title="0">
                es.log.Infof("org_dept_remove: %v", event.Data)
                es.OrgDeptRemove(ctx, event)</span>
        case "user_add_org":<span class="cov0" title="0">
                es.log.Infof("user_add_org: %v", event.Data)
                es.UserAddOrg(ctx, event)</span>
        case "user_modify_org":<span class="cov0" title="0">
                es.log.Infof("user_modify_org: %v", event.Data)
                es.UserModifyOrg(ctx, event)</span>
        case "user_leave_org":<span class="cov0" title="0">
                es.UserLeaveOrg(ctx, event)
                es.log.Infof("user_leave_org: %v", event.Data)</span>
        default:<span class="cov0" title="0">
                es.log.Infof("unknown event: %v", event.Data)
                return clientV2.EventStatusSuccess</span>
        }
        <span class="cov0" title="0">return clientV2.EventStatusSuccess</span>
}

func (es *DingTalkEventService) OrgDeptCreate(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) clientV2.EventStatus <span class="cov0" title="0">{
        es.log.Infof("OrgDeptCreate: %v", event.Data)
        err := es.incrementalSyncUsecase.OrgDeptCreate(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return clientV2.EventStatusLater
        }</span>

        <span class="cov0" title="0">return clientV2.EventStatusSuccess</span>
}
func (es *DingTalkEventService) OrgDeptModify(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) clientV2.EventStatus <span class="cov0" title="0">{

        err := es.incrementalSyncUsecase.OrgDeptModify(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return clientV2.EventStatusLater
        }</span>
        <span class="cov0" title="0">return clientV2.EventStatusSuccess</span>
}
func (es *DingTalkEventService) OrgDeptRemove(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) clientV2.EventStatus <span class="cov0" title="0">{

        err := es.incrementalSyncUsecase.OrgDeptRemove(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return clientV2.EventStatusLater
        }</span>
        <span class="cov0" title="0">return clientV2.EventStatusSuccess</span>
}
func (es *DingTalkEventService) UserAddOrg(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) clientV2.EventStatus <span class="cov0" title="0">{

        err := es.incrementalSyncUsecase.UserAddOrg(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return clientV2.EventStatusLater
        }</span>
        <span class="cov0" title="0">return clientV2.EventStatusSuccess</span>
}
func (es *DingTalkEventService) UserModifyOrg(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) clientV2.EventStatus <span class="cov0" title="0">{

        err := es.incrementalSyncUsecase.UserModifyOrg(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return clientV2.EventStatusLater
        }</span>
        <span class="cov0" title="0">return clientV2.EventStatusSuccess</span>
}
func (es *DingTalkEventService) UserLeaveOrg(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) clientV2.EventStatus <span class="cov0" title="0">{

        err := es.incrementalSyncUsecase.UserLeaveOrg(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return clientV2.EventStatusLater
        }</span>
        <span class="cov0" title="0">return clientV2.EventStatusSuccess</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// internal/task/cron.go
package task

import (
        "nancalacc/internal/biz"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/robfig/cron/v3"
)

type CronService struct {
        cron             *cron.Cron
        log              *log.Helper
        accounterUsecase *biz.AccounterUsecase
}

func NewCronService(accounterUsecase *biz.AccounterUsecase, logger log.Logger) *CronService <span class="cov0" title="0">{
        return &amp;CronService{
                cron:             cron.New(cron.WithSeconds()),
                log:              log.NewHelper(log.With(logger, "module", "task")),
                accounterUsecase: accounterUsecase,
        }
}</span>

func (s *CronService) Start() <span class="cov0" title="0">{
        s.log.Info("启动 CronService")
        s.cron.Start()
}</span>

func (s *CronService) Stop() <span class="cov0" title="0">{
        s.log.Info("停止 CronService")
        s.cron.Stop()
}</span>

func (s *CronService) AddFunc(spec string, cmd func()) (cron.EntryID, error) <span class="cov0" title="0">{
        s.log.Infof("注册任务 [%s]", spec)
        return s.cron.AddFunc(spec, cmd)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">// internal/task/jobs.go
package task

func RegisterJobs(s *CronService) <span class="cov0" title="0">{
        // 每小时执行一次
        // s.AddFunc("0 3 * * * *", func() {
        //         //s.log.Info("⏰ 执行任务：每小时任务")
        // })
        // // 0点执行一次
        // s.AddFunc("0 0 * * * *", func() {
        //         //s.log.Info("⏰ 执行任务：每小时任务")
        // })
        // 每30分钟执行一次
        s.AddFunc("0 */30 * * * *", func() </span>{<span class="cov0" title="0">
                //s.log.Info("⏰ 执行任务：每30分钟任务")
        }</span>)
        // 每5秒执行一次
        // s.AddFunc("10 2 * * * *", func() {
        //         s.log.Info("🔥 执行任务: 每天2点10分0秒全量同步一次任务")
        //         ctx, cancel := context.WithCancel(context.Background())
        //         defer cancel()
        //         res, err := s.accounterUsecase.CreateSyncAccount(ctx, &amp;v1.CreateSyncAccountRequest{
        //                 TriggerType: v1.TriggerType_TRIGGER_SCHEDULED,
        //                 SyncType:    v1.SyncType_FULL,
        //         })
        //         s.log.Infof("CreateSyncAccount: %v, err: %v", res, err)
        // })

        // 每分钟执行一次
        // s.AddFunc("0 * * * * *", func() {
        //         //s.log.Info("⏰ 执行任务：每分钟任务")
        // })
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package task

import (
        "nancalacc/internal/biz"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/google/wire"
)

var ProviderSet = wire.NewSet(
        NewCronServiceWithJobs,
)

func NewCronServiceWithJobs(accounterUsecase *biz.AccounterUsecase, logger log.Logger) *CronService <span class="cov0" title="0">{
        svc := NewCronService(accounterUsecase, logger)
        RegisterJobs(svc)
        return svc
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package tracer

import (
        "context"
        "os"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/exporters/stdout/stdouttrace"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
)

type TracerManager struct {
        tracerProvider *trace.TracerProvider
}

func NewTracerManager() *TracerManager <span class="cov0" title="0">{
        return &amp;TracerManager{}
}</span>

// 初始化 Tracer
func (tm *TracerManager) Init(env, name string) error <span class="cov0" title="0">{
        // io.Discard
        // os.Stdout

        exporter, err := stdouttrace.New(stdouttrace.WithWriter(os.Stdout))
        if err != nil </span><span class="cov0" title="0">{
                return err // 返回错误而不是直接退出
        }</span>

        <span class="cov0" title="0">tm.tracerProvider = trace.NewTracerProvider(
                trace.WithBatcher(exporter),
                trace.WithResource(resource.NewWithAttributes(
                        semconv.SchemaURL,
                        semconv.ServiceNameKey.String("name"),
                        attribute.String("environment", "env"),
                )),
        )
        otel.SetTracerProvider(tm.tracerProvider)

        otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        ))
        return nil</span>
}

// 优雅关闭 Tracer
func (tm *TracerManager) Shutdown() error <span class="cov0" title="0">{
        if tm.tracerProvider != nil </span><span class="cov0" title="0">{
                return tm.tracerProvider.Shutdown(context.Background())
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package wps

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "errors"
        "fmt"
        "net/http"
        "strings"
        "time"
)

type KsoSign struct {
        accessKey string
        secretKey string
}

type Out struct {
        Date          string // X-Kso-Date
        Authorization string // X-Kso-Authorization
}

const (
        ContentType   = "Content-Type"
        KsoAuthHeader = "X-Kso-Authorization"
        KsoDateHeader = "X-Kso-Date"
        Kso1Version   = "KSO-1"
)

func NewKsoSign(accessKey, secretKey string) (*KsoSign, error) <span class="cov0" title="0">{
        if accessKey == "" || secretKey == "" </span><span class="cov0" title="0">{
                return nil, errors.New("NewKsoSign error: AccessKey/SecretKey can not be empty")
        }</span>
        <span class="cov0" title="0">return &amp;KsoSign{
                accessKey: accessKey,
                secretKey: secretKey,
        }, nil</span>
}

// signUri := strings.TrimLeft(req.URL.Path, openApiPath)
func (k *KsoSign) getKso1Signature(secretKey, method, uri, ksoDate, contentType string, requestBody []byte) string <span class="cov0" title="0">{
        sha256Hex := ""
        if len(requestBody) &gt; 0 </span><span class="cov0" title="0">{
                s := sha256.New()
                s.Write(requestBody)
                sha256Hex = hex.EncodeToString(s.Sum(nil))
        }</span>

        <span class="cov0" title="0">mac := hmac.New(sha256.New, []byte(secretKey))

        signatureByte := []byte("KSO-1" + method + uri + contentType + ksoDate + sha256Hex)

        // fmt.Printf("signature origin: %s\n", string(signatureByte))
        // fmt.Printf("signature sha256Hex body: %s\n", sha256Hex)
        mac.Write(signatureByte)

        return hex.EncodeToString(mac.Sum(nil))</span>
}

func (k *KsoSign) KSO1Sign(method, signPath, contentType, ksoDate string, body []byte) (*Out, error) <span class="cov0" title="0">{

        fmt.Printf("[KSO1Sign] method: %s, signPath: %s, contentType: %s, ksoDate: %s, body: %s\n", method, signPath, contentType, ksoDate, string(body))
        ksoSignature := k.getKso1Signature(k.secretKey, method, signPath, ksoDate, contentType, body)
        authorization := fmt.Sprintf("%s %s:%s", "KSO-1", k.accessKey, ksoSignature)
        fmt.Printf("[KSO1Sign authorization]: %s\n", authorization)
        return &amp;Out{
                Date:          ksoDate,
                Authorization: authorization,
        }, nil
}</span>

func (k *KsoSign) validDate(ksoDate string) (tm time.Time, err error) <span class="cov0" title="0">{
        if tm, err = time.Parse(time.RFC1123, ksoDate); err == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if tm, err = time.Parse(time.RFC1123Z, ksoDate); err == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // 或者使用星期是全拼的非标准RFC1123
        <span class="cov0" title="0">RFC1123 := "Monday, 02 Jan 2006 15:04:05 MST"
        if tm, err = time.Parse(RFC1123, ksoDate); err == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">return tm, errors.New("kso1sign check error: invalid kso-date header")</span>
}

func (k *KsoSign) extractSign(authHeader string) (string, string, string, error) <span class="cov0" title="0">{
        spaceParts := strings.SplitN(authHeader, " ", 2)
        if len(spaceParts) != 2 </span><span class="cov0" title="0">{
                return "", "", "", errors.New("kso1sign check error: invalid authorization header")
        }</span>

        <span class="cov0" title="0">colonParts := strings.SplitN(spaceParts[1], ":", 2)
        if len(colonParts) != 2 </span><span class="cov0" title="0">{
                return "", "", "", errors.New("kso1sign check error: invalid authorization header")
        }</span>

        <span class="cov0" title="0">return spaceParts[0], colonParts[0], colonParts[1], nil</span>
}

func (k *KsoSign) validSign(req *http.Request, ksoSignature, secretKey, ksoDate, contentType string, requestBody []byte) error <span class="cov0" title="0">{
        sha256Hex := ""
        if len(requestBody) &gt; 0 </span><span class="cov0" title="0">{
                s := sha256.New()
                s.Write(requestBody)
                sha256Hex = hex.EncodeToString(s.Sum(nil))
        }</span>

        <span class="cov0" title="0">mac := hmac.New(sha256.New, []byte(secretKey))
        mac.Write([]byte("KSO-1" + req.Method + req.URL.RequestURI() + contentType + ksoDate + sha256Hex))
        sign := hex.EncodeToString(mac.Sum(nil))

        if sign == ksoSignature </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return errors.New("kso1sign check error: invalid signature")</span>
}

func (k *KsoSign) Kso1SignCheck(req *http.Request, requestBody []byte, SKGetter func(string) (string, error)) error <span class="cov0" title="0">{
        ksoAuthHeader := req.Header.Get(KsoAuthHeader)
        ksoDate := req.Header.Get(KsoDateHeader)
        contentType := req.Header.Get(ContentType)

        _, err := k.validDate(ksoDate)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">signVersion, accessKey, ksoSignature, err := k.extractSign(ksoAuthHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if signVersion != Kso1Version </span><span class="cov0" title="0">{
                return errors.New("kso1sign check error: unknown authorization version")
        }</span>

        // 获取 SK 及校验 AK 合法性
        <span class="cov0" title="0">secretKey, err := SKGetter(accessKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return k.validSign(req, ksoSignature, secretKey, ksoDate, contentType, requestBody)</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package wps

import (
        "context"
        "errors"
)

func ValidateWpsUser(ctx context.Context, user *UserItem) error <span class="cov0" title="0">{
        if user.ExUserID == "" </span><span class="cov0" title="0">{
                return errors.New("ex_user_id is empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package wps

import (
        "context"
        "encoding/json"
        "fmt"
        "nancalacc/internal/conf"
        "strings"
        "time"

        //httpwps "nancalacc/pkg/httputil/wps"

        "github.com/go-kratos/kratos/v2/log"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type wps struct {
        cfg *conf.Auth_Wpsapp
        log *log.Helper
}

func NewWps(logger log.Logger) Wps <span class="cov0" title="0">{
        return &amp;wps{
                cfg: conf.Get().GetAuth().GetWpsapp(),
                log: log.NewHelper(logger),
        }
}</span>

// BATCH_POST_USERS_PATH        = "/v7/users/batch_read"
func (ws *wps) BatchPostUsers(ctx context.Context, accessToken string, input BatchPostUsersRequest) (BatchPostUsersResponse, error) <span class="cov0" title="0">{
        log := ws.log.WithContext(ctx)
        log.Infof("PostBatchUsersByExDepIds req %v", input)

        var resp BatchPostUsersResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        log.Infof("BatchPostUsers uri: %s, input: %+v\n", BATCH_POST_USERS_PATH, input)
        bs, err := wpsReq.PostJSON(context.Background(), BATCH_POST_USERS_PATH, accessToken, input)
        log.Infof("BatchPostUsers: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 200 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot200
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
func (ws *wps) BatchPostDepartments(ctx context.Context, accessToken string, input BatchPostDepartmentsRequest) (BatchPostDepartmentsResponse, error) <span class="cov0" title="0">{
        log := ws.log.WithContext(ctx)
        log.Infof("BatchPostDepartments req %v", input)

        var resp BatchPostDepartmentsResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        bs, err := wpsReq.PostJSON(context.Background(), BATCH_POST_DEPTS_PATH, accessToken, input)

        log.Infof("BatchPostDepartments: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

func (ws *wps) PostBatchDepartmentsByExDepIds(ctx context.Context, accessToken string, input PostBatchDepartmentsByExDepIdsRequest) (*PostBatchDepartmentsByExDepIdsResponse, error) <span class="cov0" title="0">{
        log := ws.log.WithContext(ctx)
        log.Infof("PostBatchDepartmentsByExDepIds req %v", input)
        var resp *PostBatchDepartmentsByExDepIdsResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk)

        log.Infof("PostBatchDepartmentsByExDepIds uri: %s, input: %+v\n", POST_DEPTS_BY_EXDEPTIDS_PATH, input)
        bs, err := wpsReq.PostJSON(context.Background(), POST_DEPTS_BY_EXDEPTIDS_PATH, accessToken, input)

        log.Infof("PostBatchDepartmentsByExDepIds: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>

}

func (ws *wps) PostBatchDeleteDept(ctx context.Context, accessToken string, input PostBatchDeleteDeptRequest) (*PostBatchDeleteDeptResponse, error) <span class="cov0" title="0">{

        log := ws.log.WithContext(ctx)
        log.Infof("PostBatchDeleteDept req %v", input)
        var resp *PostBatchDeleteDeptResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk)

        log.Infof("PostBatchDeleteDept uri: %s, input: %+v\n", POST_DELETE_DEPTS_PATH, input)
        bs, err := wpsReq.PostJSON(context.Background(), POST_DELETE_DEPTS_PATH, accessToken, input)

        log.Infof("PostBatchDeleteDept: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
func (ws *wps) PostBatchDeleteUser(ctx context.Context, accessToken string, input PostBatchDeleteUserRequest) (*PostBatchDeleteUserResponse, error) <span class="cov0" title="0">{
        log := ws.log.WithContext(ctx)
        log.Infof("PostBatchDeleteUser req %v", input)
        var resp *PostBatchDeleteUserResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk)

        log.Infof("PostBatchDeleteUser uri: %s, input: %+v\n", POST_DELETE_USERS_PATH, input)
        bs, err := wpsReq.PostJSON(context.Background(), POST_DELETE_USERS_PATH, accessToken, input)

        log.Infof("PostBatchDeleteUser: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

func (ws *wps) PostRomoveUserIdFromDeptId(ctx context.Context, accessToken string, input PostRomoveUserIdFromDeptIdRequest) (*PostRomoveUserIdFromDeptIdResponse, error) <span class="cov0" title="0">{
        log := ws.log.WithContext(ctx)
        log.Infof("PostRomoveUserIdFromDeptId req %v", input)
        var resp *PostRomoveUserIdFromDeptIdResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk)

        uri := strings.Replace(POST_DELETE_USERID_FROM_DEPTID_PATH, "{dept_id}", input.DeptID, 1)
        uri = strings.Replace(uri, "{user_id}", input.UserID, 1)

        log.Infof("PostRomoveUserIdFromDeptId uri: %s, input: %+v\n", uri, nil)
        bs, err := wpsReq.PostJSON(context.Background(), uri, accessToken, nil)

        log.Infof("PostRomoveUserIdFromDeptId: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
func (ws *wps) PostAddUserIdToDeptId(ctx context.Context, accessToken string, input PostAddUserIdToDeptIdRequest) (*PostAddUserIdToDeptIdResponse, error) <span class="cov0" title="0">{
        log := ws.log.WithContext(ctx)
        log.Infof("PostAddUserIdToDeptId req %v", input)
        var resp *PostAddUserIdToDeptIdResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk)

        uri := strings.Replace(POST_ADD_USERID_TO_DEPTID_PATH, "{dept_id}", input.DeptID, 1)
        uri = strings.Replace(uri, "{user_id}", input.UserID, 1)

        log.Infof("PostAddUserIdToDeptId uri: %s, input: %+v\n", uri, nil)
        bs, err := wpsReq.PostJSON(context.Background(), uri, accessToken, nil)

        log.Infof("PostAddUserIdToDeptId: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
func (ws *wps) PostBatchUsersByExDepIds(ctx context.Context, accessToken string, input PostBatchUsersByExDepIdsRequest) (*PostBatchUsersByExDepIdsResponse, error) <span class="cov0" title="0">{

        log := ws.log.WithContext(ctx)
        log.Infof("PostBatchUsersByExDepIds req %v", input)

        var resp *PostBatchUsersByExDepIdsResponse

        // input := &amp;EcisaccountsyncIncrementRequest{
        //         ThirdCompanyId: thirdCompanyId,
        // }
        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        log.Infof("PostBatchUsersByExDepIds uri: %s, input: %+v\n", POST_USERS_BY_EXDEPTIDS_PATH, input)
        bs, err := wpsReq.PostJSON(context.Background(), POST_USERS_BY_EXDEPTIDS_PATH, accessToken, input)

        log.Infof("PostBatchUsersByExDepIds res: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>

}

func (ws *wps) GetDepartmentRoot(ctx context.Context, accessToken string, input GetDepartmentRootRequest) (GetDepartmentRootResponse, error) <span class="cov0" title="0">{

        log := ws.log.WithContext(ctx)
        log.Infof("GetDepartmentRoot req %v", input)

        var resp GetDepartmentRootResponse

        // input := &amp;EcisaccountsyncIncrementRequest{
        //         ThirdCompanyId: thirdCompanyId,
        // }
        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        bs, err := wpsReq.GET(context.Background(), GET_DEPARTMENT_ROOT, accessToken, "")

        log.Infof("GetDepartmentRoot: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        //fmt.Printf("resp: %+v\n", resp)
        //fmt.Println()
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

//        func (ws *wps) GetDepartmentChildrenList(ctx context.Context, accessToken string, input GetDepartmentChildrenListRequest) (GetDepartmentChildrenListResponse, error) {
//                var resp GetDepartmentChildrenListResponse
//                return resp, nil
//        }
func (ws *wps) GetUserByUserId(ctx context.Context, accessToken string, input GetUserByUserIdRequest) (GetUserByUserIdResponse, error) <span class="cov0" title="0">{
        log := ws.log.WithContext(ctx)
        log.Infof("GetUserByUserId req %v", input)

        var resp GetUserByUserIdResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        uri := strings.Replace(GET_USER_DEPT_BY_USERID, "{user_id}", input.UserID, 1)

        bs, err := wpsReq.GET(context.Background(), uri, accessToken, "")

        log.Infof("GetUserByUserId: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        //fmt.Printf("resp: %+v\n", resp)
        //fmt.Println()
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>

}

// TODO 内部网关的签名是不是不对
func (ws *wps) CacheSet(ctx context.Context, accessToken string, key string, value interface{}, expiration time.Duration) error <span class="cov0" title="0">{

        ws.log.WithContext(ctx).Infof("CacheSet req %v", key)
        return status.Error(codes.Unimplemented, "GetDeptByPage")
        // log := ws.log.WithContext(ctx)
        // log.Infof("CacheSet key: %s, value: %v", key, value)

        // ak := ws.serviceConf.Auth.App.ClientId
        // sk := ws.serviceConf.Auth.App.ClientSecret
        // wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        // bs, err := wpsReq.PostJSON(context.Background(), POST_CACHE_SET, accessToken, map[string]interface{}{
        //         "key":       key,
        //         "value":     value,
        //         "expire":    expiration,
        //         "namespace": "nancalacc",
        // })

        // log.Infof("CacheSet: %s, err: %+v\n", string(bs), err)
        // if err != nil {
        //         return err
        // }

}</span>
func (ws *wps) CacheGet(ctx context.Context, accessToken string, key string) (interface{}, error) <span class="cov0" title="0">{

        ws.log.WithContext(ctx).Infof("CacheGet req %v", key)
        return nil, status.Error(codes.Unimplemented, "GetDeptByPage")
        // log := ws.log.WithContext(ctx)
        // log.Infof("CacheGet key %v", key)

        // ak := ws.serviceConf.Auth.App.ClientId
        // sk := ws.serviceConf.Auth.App.ClientSecret
        // wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        // bs, err := wpsReq.PostJSON(context.Background(), POST_CACHE_GET, accessToken, map[string]interface{}{
        //         "key":       key,
        //         "namespace": "nancalacc",
        // })

        // log.Infof("CacheGet: %s, err: %+v\n", string(bs), err)
        // if err != nil {
        //         return nil, err
        // }

        // var resp map[string]interface{}
        // err = json.Unmarshal(bs, &amp;resp)
        // if err != nil {
        //         return nil, err
        // }
}</span>

func (ws *wps) CacheDel(ctx context.Context, accessToken, input string) error <span class="cov0" title="0">{
        ws.log.WithContext(ctx).Infof("CacheDel req %v", input)
        return status.Error(codes.Unimplemented, "GetDeptByPage")

        // log := ws.log.WithContext(ctx)
        // log.Infof("CacheDel key %v", key)

        // ak := ws.serviceConf.Auth.App.ClientId
        // sk := ws.serviceConf.Auth.App.ClientSecret
        // wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        // bs, err := wpsReq.PostJSON(context.Background(), POST_CACHE_DEL, accessToken, map[string]interface{}{
        //         "key":       key,
        //         "namespace": "nancalacc",
        // })

        // log.Infof("CacheDel: %s, err: %+v\n", string(bs), err)
        // if err != nil {
        //         return err
        // }

        // var resp map[string]interface{}
        // err = json.Unmarshal(bs, &amp;resp)
        // if err != nil {
        //         return err
        // }
}</span>

func (ws *wps) PostUpdateDept(ctx context.Context, accessToken string, input PostUpdateDeptRequest) (*PostUpdateDeptResponse, error) <span class="cov0" title="0">{
        ws.log.WithContext(ctx).Infof("PostUpdateDept req %v", input)
        return nil, status.Error(codes.Unimplemented, "PostUpdateDept")
}</span>
func (ws *wps) PostUpdateUser(ctx context.Context, accessToken string, input PostUpdateUserRequest) (*PostUpdateUserResponse, error) <span class="cov0" title="0">{
        ws.log.WithContext(ctx).Infof("PostUpdateUser req %v", input)
        return nil, status.Error(codes.Unimplemented, "PostUpdateUser")
}</span>

func (ws *wps) PostBatchUserByPage(ctx context.Context, accessToken string, input PostBatchUserByPageRequest) (*PostBatchUserByPageResponse, error) <span class="cov0" title="0">{
        ws.log.WithContext(ctx).Infof("PostCreateUser req %v", input)
        return nil, status.Error(codes.Unimplemented, "PostBatchUserByPage")
}</span>

func (ws *wps) GetDeptByPage(ctx context.Context, accessToken string, input GetDeptByPageRequest) (*GetDeptByPageResponse, error) <span class="cov0" title="0">{
        ws.log.WithContext(ctx).Infof("GetDeptByPage req %v", input)
        return nil, status.Error(codes.Unimplemented, "GetDeptByPage")
}</span>

func (ws *wps) GetUserDeptsByUserId(ctx context.Context, accessToken string, input GetUserDeptsByUserIdRequest) (*GetUserDeptsByUserIdResponse, error) <span class="cov0" title="0">{
        log := ws.log.WithContext(ctx)
        log.Infof("GetUserDeptsByUserId req %v", input)

        var resp GetUserDeptsByUserIdResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        uri := strings.Replace(GET_USER_DEPT_BY_USERID, "{user_id}", input.UserID, 1)
        bs, err := wpsReq.GET(context.Background(), uri, accessToken, "")

        log.Infof("GetUserDeptsByUserId: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Infof("GetUserDeptsByUserId res %v", resp)
        //fmt.Printf("resp: %+v\n", resp)
        //fmt.Println()
        if resp.Code != 0 </span><span class="cov0" title="0">{
                return nil, ErrCodeNot0
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

func (ws *wps) GetDeptChildren(ctx context.Context, accessToken string, input GetDeptChildrenRequest) (*GetDeptChildrenResponse, error) <span class="cov0" title="0">{

        log := ws.log.WithContext(ctx)
        log.Infof("GetDeptChildren req %v", input)

        var resp GetDeptChildrenResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        path := strings.Replace(GET_DEPT_CHILDREN, "{dept_id}", input.DeptID, 1)

        uri := fmt.Sprintf(
                "%s?recursive=%t&amp;page_size=%d&amp;with_total=%t",
                path,
                input.Recursive,
                input.PageSize,
                // input.PageToken,
                input.WithTotal,
        )

        if len(input.PageToken) &gt; 0 </span><span class="cov0" title="0">{
                uri += fmt.Sprintf("&amp;page_token=%s", input.PageToken)
        }</span>

        <span class="cov0" title="0">bs, err := wpsReq.GET(context.Background(), uri, accessToken, "")

        log.Infof("GetDeptChildren: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        //fmt.Printf("resp: %+v\n", resp)
        //fmt.Println()
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return nil, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return &amp;resp, nil</span>

}

func (ws *wps) GetCompAllUsers(ctx context.Context, accessToken string, input GetCompAllUsersRequest) (*GetCompAllUsersResponse, error) <span class="cov0" title="0">{
        ws.log.WithContext(ctx).Infof("GetCompAllUsers req %v", input)

        log := ws.log.WithContext(ctx)
        log.Infof("GetCompAllUsers req %v", input)

        var resp GetCompAllUsersResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        uri := fmt.Sprintf(
                "%s?recursive=%t&amp;page_size=%d&amp;with_total=%t",
                GET_ALL_USER_PARH,
                input.Recursive,
                input.PageSize,
                input.WithTotal,
        )
        if len(input.Status) &gt; 0 </span><span class="cov0" title="0">{
                for _, status := range input.Status </span><span class="cov0" title="0">{
                        uri += fmt.Sprintf("&amp;status=%s", status)
                }</span>
        }
        <span class="cov0" title="0">if len(input.PageToken) &gt; 0 </span><span class="cov0" title="0">{
                uri += fmt.Sprintf("&amp;page_token=%s", input.PageToken)
        }</span>
        <span class="cov0" title="0">log.Infof("GetCompAllUsers req: %s\n", uri)
        bs, err := wpsReq.GET(context.Background(), uri, accessToken, "")

        log.Infof("GetCompAllUsers res: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        //fmt.Printf("resp: %+v\n", resp)
        //fmt.Println()
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return nil, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return &amp;resp, nil</span>
}

func (ws *wps) PostCreateDept(ctx context.Context, accessToken string, input PostCreateDeptRequest) (*PostCreateDeptResponse, error) <span class="cov0" title="0">{

        log := ws.log.WithContext(ctx)
        log.Infof("PostCreateDept req %v", input)

        var resp *PostCreateDeptResponse

        // input := &amp;EcisaccountsyncIncrementRequest{
        //         ThirdCompanyId: thirdCompanyId,
        // }
        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        log.Infof("PostCreateDept uri: %s, input: %+v\n", POST_CREATE_DEPT_PATH, input)
        bs, err := wpsReq.PostJSON(context.Background(), POST_CREATE_DEPT_PATH, accessToken, input)

        log.Infof("PostCreateDept res: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>

}

func (ws *wps) PostCreateUser(ctx context.Context, accessToken string, input PostCreateUserRequest) (*PostCreateUserResponse, error) <span class="cov0" title="0">{
        log := ws.log.WithContext(ctx)
        log.Infof("PostCreateUser req %v", input)

        var resp *PostCreateUserResponse

        // input := &amp;EcisaccountsyncIncrementRequest{
        //         ThirdCompanyId: thirdCompanyId,
        // }
        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        log.Infof("PostCreateUser uri: %s, input: %+v\n", POST_CREATE_USER_PATH, input)
        bs, err := wpsReq.PostJSON(context.Background(), POST_CREATE_USER_PATH, accessToken, input)

        log.Infof("PostCreateUser res: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

func (ws *wps) GetUsersSearch(ctx context.Context, accessToken string, input GetUsersSearchRequest) (*GetUsersSearchResponse, error) <span class="cov0" title="0">{
        log := ws.log.WithContext(ctx)
        log.Infof("GetUsersSearch req %v", input)

        var resp *GetUsersSearchResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        log.Infof("GetUsersSearch uri: %s, input: %+v\n", GET_USERS_SEARCH_PATH, input)
        uri := fmt.Sprintf("%s?keyword=%s&amp;page_size=%d", GET_USERS_SEARCH_PATH, input.Keyword, input.PageSize)

        if input.PageToken != "" </span><span class="cov0" title="0">{
                uri += "&amp;page_token=true"
                uri += fmt.Sprintf("&amp;page_token=%s", input.PageToken)
        }</span>
        <span class="cov0" title="0">if len(input.Status) &gt; 0 </span><span class="cov0" title="0">{
                for _, status := range input.Status </span><span class="cov0" title="0">{
                        uri += fmt.Sprintf("&amp;status=%s", status)
                }</span>
        }
        <span class="cov0" title="0">if input.SearchFieldConfigEnabled </span><span class="cov0" title="0">{
                uri += "&amp;search_field_config_enabled=true"
        }</span>

        <span class="cov0" title="0">if len(input.SearchSource) &gt; 0 </span><span class="cov0" title="0">{
                for _, searchSource := range input.SearchSource </span><span class="cov0" title="0">{
                        uri += fmt.Sprintf("&amp;search_source=%s", searchSource)
                }</span>
        }
        <span class="cov0" title="0">bs, err := wpsReq.GET(context.Background(), uri, accessToken, "")

        log.Infof("GetUsersSearch res: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

func (ws *wps) GetContactPermission(ctx context.Context, accessToken string, input GetContactPermissionRequest) (*GetContactPermissionResponse, error) <span class="cov0" title="0">{
        log := ws.log.WithContext(ctx)
        log.Infof("GetContactPermission req %v", input)

        var resp *GetContactPermissionResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        log.Infof("GetUsersSearch uri: %s, input: %+v\n", GET_CONTACT_PERMISSION_PATH, input)
        var uri string
        for _, status := range input.Scopes </span><span class="cov0" title="0">{
                uri += fmt.Sprintf("&amp;scope=%s", status)
        }</span>
        <span class="cov0" title="0">bs, err := wpsReq.GET(context.Background(), GET_CONTACT_PERMISSION_PATH+"?"+uri, accessToken, "")

        log.Infof("GetUsersSearch res: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

// 内部网关
func (ws *wps) GetObjUploadUrl(ctx context.Context, accessToken string, input GetObjUploadUrlRequest) (*GetObjUploadUrlResponse, error) <span class="cov0" title="0">{
        log := ws.log.WithContext(ctx)
        log.Infof("GetObjUploadUrl req %v", input)

        var resp *GetObjUploadUrlResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        // http: //encs-pri-cams-engine/{c}/asyncacc/v1/task

        uri := "http://119.3.173.229/api/cams/sdk/api/v1/wps3/presigned_upload"
        uri = "http://119.3.173.229/api/cams/sdk/api/v1/wps3/presigned_upload"

        log.Infof("GetObjUploadUrl uri: %s, input: %+v\n", uri, "")
        bs, err := wpsReq.GET(context.Background(), uri, accessToken, "")

        log.Infof("GetObjUploadUrl res: %s, err: %+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package wps

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "net/http"
        "net/url"

        "strings"
        "time"
)

type Wps4Auth struct {
        AccessKey string
        SecretKey string
}

var (
        Wps4AuthSign    = "Wps-Docs-Authorization"
        contentTypeSign = "application/json"
        wps4DateSign    = "Wps-Docs-Date"
        //connectionSign =

)

func NewWps4Auth(accessKey, secretKey string) *Wps4Auth <span class="cov0" title="0">{
        auth := &amp;Wps4Auth{}
        auth.AccessKey = accessKey
        auth.SecretKey = secretKey
        return auth
}</span>

func (a *Wps4Auth) BuildWps4Headers(method string, url *url.URL, data []byte, contentType string) *http.Header <span class="cov0" title="0">{
        if strings.TrimSpace(contentType) == "" </span><span class="cov0" title="0">{
                contentType = "application/json"
        }</span>

        <span class="cov0" title="0">header := http.Header{}
        auth, date := a.prepare(method, url, data, contentType)
        header.Set(Wps4AuthSign, auth)
        header.Set(contentTypeSign, contentType)
        header.Set(wps4DateSign, date)
        //header.Set(connectionSign, "keep-alive")
        return &amp;header</span>
}

func (a *Wps4Auth) prepare(method string, url *url.URL, data []byte, contentType string) (auth, date string) <span class="cov0" title="0">{
        path := url.Path
        if url.RawQuery != "" </span><span class="cov0" title="0">{
                path += fmt.Sprintf("?%s", url.RawQuery)
        }</span>

        <span class="cov0" title="0">var content []byte
        if data != nil </span><span class="cov0" title="0">{
                content = data
        }</span>

        <span class="cov0" title="0">date = time.Now().UTC().Format(http.TimeFormat)
        sig := a.sign(method, path, contentType, date, content)
        auth = fmt.Sprintf("WPS-4 %s:%s", a.AccessKey, sig)

        return</span>
}

func (a *Wps4Auth) sign(method, uri, contentType, date string, content []byte) (sign string) <span class="cov0" title="0">{
        bodySha := ""
        if content != nil </span><span class="cov0" title="0">{
                bodySha = a.getSha256(content)
        }</span>

        <span class="cov0" title="0">mac := hmac.New(sha256.New, []byte(a.SecretKey))
        mac.Write([]byte("WPS-4"))
        mac.Write([]byte(method))
        mac.Write([]byte(uri))
        mac.Write([]byte(contentType))
        mac.Write([]byte(date))
        mac.Write([]byte(bodySha))

        return hex.EncodeToString(mac.Sum(nil))</span>
}

func (a *Wps4Auth) getSha256(ontent []byte) string <span class="cov0" title="0">{
        h := sha256.New()
        h.Write(ontent)
        return hex.EncodeToString(h.Sum(nil))
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package wps

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/moul/http2curl"
)

const (
        defaultContentType  = "application/json"
        defaultTimeout      = 30 * time.Second
        AuthorizationHeader = "Authorization"
        RFC1123             = "Mon, 02 Jan 2006 15:04:05 GMT"
        // RFC1123             = "Monday, 02 Jan 2006 15:04:05 MST"
)

var (
        ErrInvalidRequest = errors.New("invalid request parameters")
        ErrHTTPRequest    = errors.New("HTTP request failed")
        openApiPathPrefix = "/openapi"
)

type WPSRequest struct {
        logger      *log.Helper
        baseURL     string
        method      string
        path        string
        body        []byte
        contentType string
        ksoDate     string
        timeout     time.Duration
        headers     map[string]string
        queryParams map[string]string
        accessKey   string
        secretKey   string
        client      *http.Client
        accessToken string
}

type Option func(*WPSRequest)

func NewWPSRequest(baseURL, accessKey, secretKey string, opts ...Option) *WPSRequest <span class="cov0" title="0">{
        r := &amp;WPSRequest{
                baseURL:     strings.TrimRight(baseURL, "/"),
                accessKey:   accessKey,
                secretKey:   secretKey,
                timeout:     defaultTimeout,
                contentType: defaultContentType,
                headers:     make(map[string]string),
                queryParams: make(map[string]string),
                client:      &amp;http.Client{Timeout: defaultTimeout},
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(r)
        }</span>

        <span class="cov0" title="0">return r</span>
}

func WithLogger(logger *log.Helper) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.logger = logger
        }</span>
}

// Option setters
func WithMethod(method string) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.method = strings.ToUpper(method)
        }</span>
}

func WithPath(path string) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                //r.path = strings.TrimLeft(path, "/")
                r.path = path
        }</span>
}

func WithBody(body []byte) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.body = body
        }</span>
}

func WithJSONBody(v interface{}) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                if b, err := json.Marshal(v); err == nil </span><span class="cov0" title="0">{
                        r.body = b
                        r.contentType = "application/json"
                }</span>
        }
}

func WithTimeout(timeout time.Duration) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.timeout = timeout
                r.client.Timeout = timeout
        }</span>
}

func WithHeader(key, value string) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.headers[key] = value
        }</span>
}

func WithQueryParam(key, value string) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.queryParams[key] = value
        }</span>
}

func WithContentType(contentType string) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.contentType = contentType
        }</span>
}

func WithKsoDate(date string) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.ksoDate = date
        }</span>
}

func WithAuthorization(accessToken string) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.accessToken = "Bearer " + accessToken
        }</span>
}

// Core methods
func (r *WPSRequest) BuildRequest() (*http.Request, error) <span class="cov0" title="0">{
        if r.method == "" || r.path == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: method and path are required", ErrInvalidRequest)
        }</span>

        // Build URL with query params
        <span class="cov0" title="0">u, err := url.Parse(fmt.Sprintf("%s%s", r.baseURL, r.path))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: invalid URL", ErrInvalidRequest)
        }</span>

        <span class="cov0" title="0">q := u.Query()
        for k, v := range r.queryParams </span><span class="cov0" title="0">{
                q.Add(k, v)
        }</span>
        <span class="cov0" title="0">u.RawQuery = q.Encode()

        // Create request
        req, err := http.NewRequest(r.method, u.String(), bytes.NewBuffer(r.body))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: failed to create request", ErrHTTPRequest)
        }</span>

        // Set headers
        <span class="cov0" title="0">if r.body != nil &amp;&amp; r.contentType != "" </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", r.contentType)
        }</span>
        <span class="cov0" title="0">if r.method == http.MethodGet &amp;&amp; r.contentType == "" </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", "")
        }</span>
        <span class="cov0" title="0">for k, v := range r.headers </span><span class="cov0" title="0">{
                req.Header.Set(k, v)
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

func (r *WPSRequest) Do(ctx context.Context) ([]byte, error) <span class="cov0" title="0">{
        req, err := r.BuildRequest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Add KSO signature
        <span class="cov0" title="0">signer, err := NewKsoSign(r.accessKey, r.secretKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create signer: %w", err)
        }</span>

        <span class="cov0" title="0">signPath := strings.TrimPrefix(req.URL.Path, openApiPathPrefix)
        if len(req.URL.RawQuery) &gt; 0 </span><span class="cov0" title="0">{
                signPath += "?" + req.URL.RawQuery
        }</span>

        <span class="cov0" title="0">sign, err := signer.KSO1Sign(r.method, signPath, r.contentType, r.ksoDate, r.body)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set(KsoDateHeader, sign.Date)
        req.Header.Set(KsoAuthHeader, sign.Authorization)
        req.Header.Set(AuthorizationHeader, r.accessToken)

        command, _ := http2curl.GetCurlCommand(req)
        // fmt.Println()

        //r.logger.Infof("request command: %s\n", command)
        fmt.Printf("request command: %s\n", command)

        // Execute request
        resp, err := r.client.Do(req.WithContext(ctx))

        fmt.Printf("request resp: %+v, err: %+v\n", resp, err)
        // fmt.Println()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %v", ErrHTTPRequest, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        fmt.Printf("request resp.StatusCode: %d, detail: %s, err:%+v\n", resp.StatusCode, string(body), err)
        if resp.StatusCode &gt;= http.StatusBadRequest </span><span class="cov0" title="0">{

                return nil, fmt.Errorf("%w: status %d", ErrHTTPRequest, resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return body, err</span>
}

// Convenience method
func (r *WPSRequest) PostJSON(ctx context.Context, path string, accessToken string, body interface{}) ([]byte, error) <span class="cov0" title="0">{
        req := NewWPSRequest(r.baseURL, r.accessKey, r.secretKey,
                WithMethod(http.MethodPost),
                WithPath(path),
                WithJSONBody(body),
                WithKsoDate(time.Now().UTC().Format(RFC1123)),
                WithAuthorization(accessToken),
        )
        return req.Do(ctx)
}</span>

func (r *WPSRequest) GET(ctx context.Context, path string, accessToken string, query interface{}) ([]byte, error) <span class="cov0" title="0">{
        req := NewWPSRequest(r.baseURL, r.accessKey, r.secretKey,
                WithMethod(http.MethodGet),
                WithPath(path),
                WithContentType(""),
                WithKsoDate(time.Now().UTC().Format(RFC1123)),
                WithAuthorization(accessToken),
        )
        return req.Do(ctx)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package wps

import (
        "context"
        "encoding/json"
)

var (
        Source = "sync"
)

func (ws *wps) PostEcisaccountsyncAll(ctx context.Context, accessToken string, input *EcisaccountsyncAllRequest) (EcisaccountsyncAllResponse, error) <span class="cov0" title="0">{

        ws.log.Infof("PostEcisaccountsyncAll input:%+v", input)
        var resp EcisaccountsyncAllResponse

        // input := &amp;EcisaccountsyncAllRequest{
        //         ThirdCompanyId: thirdCompanyId,
        // }
        input.CollectCost = CollectCost
        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk)

        ws.log.Infof("PostEcisaccountsyncAll.req path:%s,input:%+v\n", ECISACCOUNTSYNC_PATH_INCREMENT, input)

        bs, err := wpsReq.PostJSON(context.Background(), ECISACCOUNTSYNC_PATH_INCREMENT, accessToken, input)

        ws.log.Infof("PostEcisaccountsyncAll.res bs:%s,err:%+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != "200" </span><span class="cov0" title="0">{
                return resp, ErrCodeNot200
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

func (ws *wps) PostEcisaccountsyncIncrement(ctx context.Context, accessToken string, input *EcisaccountsyncIncrementRequest) (EcisaccountsyncIncrementResponse, error) <span class="cov0" title="0">{

        var resp EcisaccountsyncIncrementResponse

        // input := &amp;EcisaccountsyncIncrementRequest{
        //         ThirdCompanyId: thirdCompanyId,
        // }
        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk)

        ws.log.Infof("PostEcisaccountsyncIncrement.req path:%s,input:%+v\n", ECISACCOUNTSYNC_PATH_INCREMENT, input)

        bs, err := wpsReq.PostJSON(context.Background(), ECISACCOUNTSYNC_PATH_INCREMENT, accessToken, input)

        ws.log.Infof("PostEcisaccountsyncIncrement.res bs:%s,err:%+v\n", string(bs), err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != "200" </span><span class="cov0" title="0">{
                return resp, ErrCodeNot200
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package httputil

import (
        "bytes"
        "fmt"
        "io"
        "net/http"
        "time"
)

func PostJSON(uri string, jsonData []byte, timeout time.Duration) ([]byte, error) <span class="cov0" title="0">{
        httpClient := &amp;http.Client{Timeout: timeout}
        resp, err := httpClient.Post(uri, "application/json", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &gt;= http.StatusBadRequest </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP error: %s", resp.Status)
        }</span>

        <span class="cov0" title="0">bs, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return bs, nil</span>
}

func Post(uri string, data []byte, timeout time.Duration) ([]byte, error) <span class="cov0" title="0">{
        httpClient := &amp;http.Client{Timeout: timeout}
        resp, err := httpClient.Post(uri, "application/x-www-form-urlencoded", bytes.NewBuffer(data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &gt;= http.StatusBadRequest </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP error: %s", resp.Status)
        }</span>

        <span class="cov0" title="0">bs, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return bs, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>


<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">nancalacc/api/account/v1/account.pb.go (0.0%)</option>
				
				<option value="file1">nancalacc/api/account/v1/account_grpc.pb.go (0.0%)</option>
				
				<option value="file2">nancalacc/api/account/v1/account_http.pb.go (0.0%)</option>
				
				<option value="file3">nancalacc/cmd/client/main.go (0.0%)</option>
				
				<option value="file4">nancalacc/cmd/nancalacc/main.go (0.0%)</option>
				
				<option value="file5">nancalacc/cmd/nancalacc/wire_gen.go (0.0%)</option>
				
				<option value="file6">nancalacc/internal/auth/cache.go (0.0%)</option>
				
				<option value="file7">nancalacc/internal/auth/common.go (0.0%)</option>
				
				<option value="file8">nancalacc/internal/auth/dingtalk_auth.go (0.0%)</option>
				
				<option value="file9">nancalacc/internal/auth/wpsapp_auth.go (0.0%)</option>
				
				<option value="file10">nancalacc/internal/biz/account.go (0.0%)</option>
				
				<option value="file11">nancalacc/internal/biz/account_sync.go (0.0%)</option>
				
				<option value="file12">nancalacc/internal/biz/full_sync.go (0.0%)</option>
				
				<option value="file13">nancalacc/internal/biz/incre_sync.go (0.0%)</option>
				
				<option value="file14">nancalacc/internal/biz/oauth2.go (0.0%)</option>
				
				<option value="file15">nancalacc/internal/conf/conf.pb.go (0.0%)</option>
				
				<option value="file16">nancalacc/internal/conf/envvars.go (0.0%)</option>
				
				<option value="file17">nancalacc/internal/conf/example_usage.go (0.0%)</option>
				
				<option value="file18">nancalacc/internal/conf/loader.go (0.0%)</option>
				
				<option value="file19">nancalacc/internal/conf/validator.go (0.0%)</option>
				
				<option value="file20">nancalacc/internal/data/account.go (0.0%)</option>
				
				<option value="file21">nancalacc/internal/data/data.go (0.0%)</option>
				
				<option value="file22">nancalacc/internal/data/data_sync.go (0.0%)</option>
				
				<option value="file23">nancalacc/internal/data/database_factory.go (0.0%)</option>
				
				<option value="file24">nancalacc/internal/data/database_init.go (0.0%)</option>
				
				<option value="file25">nancalacc/internal/data/etcd/client.go (0.0%)</option>
				
				<option value="file26">nancalacc/internal/data/etcd/config.go (0.0%)</option>
				
				<option value="file27">nancalacc/internal/data/gorm_logger.go (0.0%)</option>
				
				<option value="file28">nancalacc/internal/data/local_cache.go (0.0%)</option>
				
				<option value="file29">nancalacc/internal/data/migrations.go (0.0%)</option>
				
				<option value="file30">nancalacc/internal/data/models/account.go (0.0%)</option>
				
				<option value="file31">nancalacc/internal/data/models/company.go (0.0%)</option>
				
				<option value="file32">nancalacc/internal/data/models/converter.go (0.0%)</option>
				
				<option value="file33">nancalacc/internal/data/models/department.go (0.0%)</option>
				
				<option value="file34">nancalacc/internal/data/models/department_user.go (0.0%)</option>
				
				<option value="file35">nancalacc/internal/data/models/saga.go (0.0%)</option>
				
				<option value="file36">nancalacc/internal/data/models/task.go (0.0%)</option>
				
				<option value="file37">nancalacc/internal/data/models/user.go (0.0%)</option>
				
				<option value="file38">nancalacc/internal/data/redis.go (0.0%)</option>
				
				<option value="file39">nancalacc/internal/data/redis_cache.go (0.0%)</option>
				
				<option value="file40">nancalacc/internal/data/saga_repository.go (0.0%)</option>
				
				<option value="file41">nancalacc/internal/dingtalk/dingtalk.go (0.0%)</option>
				
				<option value="file42">nancalacc/internal/dingtalk/validate.go (0.0%)</option>
				
				<option value="file43">nancalacc/internal/otel/config.go (0.0%)</option>
				
				<option value="file44">nancalacc/internal/otel/helpers.go (0.0%)</option>
				
				<option value="file45">nancalacc/internal/otel/integration.go (0.0%)</option>
				
				<option value="file46">nancalacc/internal/otel/logger_adapter.go (0.0%)</option>
				
				<option value="file47">nancalacc/internal/otel/loki_exporter.go (0.0%)</option>
				
				<option value="file48">nancalacc/internal/otel/middleware.go (0.0%)</option>
				
				<option value="file49">nancalacc/internal/otel/service.go (0.0%)</option>
				
				<option value="file50">nancalacc/internal/pkg/cache/redis.go (0.0%)</option>
				
				<option value="file51">nancalacc/internal/pkg/cipherutil/cipherutil.go (0.0%)</option>
				
				<option value="file52">nancalacc/internal/pkg/limiter/example.go (0.0%)</option>
				
				<option value="file53">nancalacc/internal/pkg/limiter/limiter.go (0.0%)</option>
				
				<option value="file54">nancalacc/internal/pkg/utils/slice.go (0.0%)</option>
				
				<option value="file55">nancalacc/internal/server/grpc.go (0.0%)</option>
				
				<option value="file56">nancalacc/internal/server/http.go (0.0%)</option>
				
				<option value="file57">nancalacc/internal/service/account.go (0.0%)</option>
				
				<option value="file58">nancalacc/internal/service/dingtalkevent.go (0.0%)</option>
				
				<option value="file59">nancalacc/internal/service/otel.go (0.0%)</option>
				
				<option value="file60">nancalacc/internal/service/otel_unified.go (0.0%)</option>
				
				<option value="file61">nancalacc/internal/task/config.go (0.0%)</option>
				
				<option value="file62">nancalacc/internal/task/cron.go (0.0%)</option>
				
				<option value="file63">nancalacc/internal/task/jobs.go (0.0%)</option>
				
				<option value="file64">nancalacc/internal/task/provider.go (0.0%)</option>
				
				<option value="file65">nancalacc/internal/wps/helpers.go (0.0%)</option>
				
				<option value="file66">nancalacc/internal/wps/signature.go (0.0%)</option>
				
				<option value="file67">nancalacc/internal/wps/types.go (0.0%)</option>
				
				<option value="file68">nancalacc/internal/wps/validate.go (0.0%)</option>
				
				<option value="file69">nancalacc/internal/wps/wps.go (0.0%)</option>
				
				<option value="file70">nancalacc/internal/wps/wps4sign.go (0.0%)</option>
				
				<option value="file71">nancalacc/internal/wps/wpsrequest.go (0.0%)</option>
				
				<option value="file72">nancalacc/internal/wps/wpssync.go (0.0%)</option>
				
				<option value="file73">nancalacc/pkg/httputil/http.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v5.29.3
// source: api/account/v1/account.proto

package v1

import (
        _ "google.golang.org/genproto/googleapis/api/annotations"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TriggerType int32

const (
        TriggerType_TRIGGER_UNKNOWN   TriggerType = 0 // 未知触发方式（默认值）
        TriggerType_TRIGGER_MANUAL    TriggerType = 1 // 手动触发（如管理员点击按钮）
        TriggerType_TRIGGER_SCHEDULED TriggerType = 2 // 定时任务触发（如每天凌晨2点自动同步）
)

// Enum value maps for TriggerType.
var (
        TriggerType_name = map[int32]string{
                0: "TRIGGER_UNKNOWN",
                1: "TRIGGER_MANUAL",
                2: "TRIGGER_SCHEDULED",
        }
        TriggerType_value = map[string]int32{
                "TRIGGER_UNKNOWN":   0,
                "TRIGGER_MANUAL":    1,
                "TRIGGER_SCHEDULED": 2,
        }
)

func (x TriggerType) Enum() *TriggerType <span class="cov0" title="0">{
        p := new(TriggerType)
        *p = x
        return p
}</span>

func (x TriggerType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (TriggerType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_enumTypes[0].Descriptor()
}</span>

func (TriggerType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_api_account_v1_account_proto_enumTypes[0]
}</span>

func (x TriggerType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use TriggerType.Descriptor instead.
func (TriggerType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{0}
}</span>

type SyncType int32

const (
        SyncType_FULL        SyncType = 0 // 全量同步
        SyncType_INCREMENTAL SyncType = 1 // 增量同步
)

// Enum value maps for SyncType.
var (
        SyncType_name = map[int32]string{
                0: "FULL",
                1: "INCREMENTAL",
        }
        SyncType_value = map[string]int32{
                "FULL":        0,
                "INCREMENTAL": 1,
        }
)

func (x SyncType) Enum() *SyncType <span class="cov0" title="0">{
        p := new(SyncType)
        *p = x
        return p
}</span>

func (x SyncType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (SyncType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_enumTypes[1].Descriptor()
}</span>

func (SyncType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_api_account_v1_account_proto_enumTypes[1]
}</span>

func (x SyncType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use SyncType.Descriptor instead.
func (SyncType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{1}
}</span>

type GetSyncAccountReply_Status int32

const (
        GetSyncAccountReply_PENDING GetSyncAccountReply_Status = 0 // 待执行
        GetSyncAccountReply_RUNNING GetSyncAccountReply_Status = 1 // 执行中
        GetSyncAccountReply_SUCCESS GetSyncAccountReply_Status = 2 // 成功
        GetSyncAccountReply_FAILED  GetSyncAccountReply_Status = 3 // 失败
)

// Enum value maps for GetSyncAccountReply_Status.
var (
        GetSyncAccountReply_Status_name = map[int32]string{
                0: "PENDING",
                1: "RUNNING",
                2: "SUCCESS",
                3: "FAILED",
        }
        GetSyncAccountReply_Status_value = map[string]int32{
                "PENDING": 0,
                "RUNNING": 1,
                "SUCCESS": 2,
                "FAILED":  3,
        }
)

func (x GetSyncAccountReply_Status) Enum() *GetSyncAccountReply_Status <span class="cov0" title="0">{
        p := new(GetSyncAccountReply_Status)
        *p = x
        return p
}</span>

func (x GetSyncAccountReply_Status) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (GetSyncAccountReply_Status) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_enumTypes[2].Descriptor()
}</span>

func (GetSyncAccountReply_Status) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_api_account_v1_account_proto_enumTypes[2]
}</span>

func (x GetSyncAccountReply_Status) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use GetSyncAccountReply_Status.Descriptor instead.
func (GetSyncAccountReply_Status) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{7, 0}
}</span>

type GetTaskRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        TaskName      string                 `protobuf:"bytes,1,opt,name=task_name,json=taskName,proto3" json:"task_name,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetTaskRequest) Reset() <span class="cov0" title="0">{
        *x = GetTaskRequest{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTaskRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTaskRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTaskRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTaskRequest.ProtoReflect.Descriptor instead.
func (*GetTaskRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{0}
}</span>

func (x *GetTaskRequest) GetTaskName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TaskName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetTaskReply struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Task          *GetTaskReply_Task     `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetTaskReply) Reset() <span class="cov0" title="0">{
        *x = GetTaskReply{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTaskReply) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTaskReply) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTaskReply) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTaskReply.ProtoReflect.Descriptor instead.
func (*GetTaskReply) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GetTaskReply) GetTask() *GetTaskReply_Task <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Task
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UploadRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        File          []byte                 `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
        Filename      string                 `protobuf:"bytes,2,opt,name=filename,proto3" json:"filename,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UploadRequest) Reset() <span class="cov0" title="0">{
        *x = UploadRequest{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UploadRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UploadRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UploadRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UploadRequest.ProtoReflect.Descriptor instead.
func (*UploadRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{2}
}</span>

func (x *UploadRequest) GetFile() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.File
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UploadRequest) GetFilename() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Filename
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UploadReply struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Url           string                 `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
        Task          string                 `protobuf:"bytes,2,opt,name=task,proto3" json:"task,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UploadReply) Reset() <span class="cov0" title="0">{
        *x = UploadReply{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UploadReply) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UploadReply) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UploadReply) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UploadReply.ProtoReflect.Descriptor instead.
func (*UploadReply) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{3}
}</span>

func (x *UploadReply) GetUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Url
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UploadReply) GetTask() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Task
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// 创建同步请求
type CreateSyncAccountRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        TriggerType   TriggerType            `protobuf:"varint,1,opt,name=trigger_type,json=triggerType,proto3,enum=api.account.v1.TriggerType" json:"trigger_type,omitempty"` // 触发类型
        SyncType      SyncType               `protobuf:"varint,2,opt,name=sync_type,json=syncType,proto3,enum=api.account.v1.SyncType" json:"sync_type,omitempty"`             // 同步类型
        TaskName      *string                `protobuf:"bytes,3,opt,name=task_name,json=taskName,proto3,oneof" json:"task_name,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateSyncAccountRequest) Reset() <span class="cov0" title="0">{
        *x = CreateSyncAccountRequest{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateSyncAccountRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateSyncAccountRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateSyncAccountRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateSyncAccountRequest.ProtoReflect.Descriptor instead.
func (*CreateSyncAccountRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{4}
}</span>

func (x *CreateSyncAccountRequest) GetTriggerType() TriggerType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TriggerType
        }</span>
        <span class="cov0" title="0">return TriggerType_TRIGGER_UNKNOWN</span>
}

func (x *CreateSyncAccountRequest) GetSyncType() SyncType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SyncType
        }</span>
        <span class="cov0" title="0">return SyncType_FULL</span>
}

func (x *CreateSyncAccountRequest) GetTaskName() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.TaskName != nil </span><span class="cov0" title="0">{
                return *x.TaskName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// 创建同步响应
type CreateSyncAccountReply struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        TaskId        string                 `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`             // 生成的任务ID
        CreateTime    *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"` // 任务创建时间
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateSyncAccountReply) Reset() <span class="cov0" title="0">{
        *x = CreateSyncAccountReply{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateSyncAccountReply) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateSyncAccountReply) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateSyncAccountReply) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateSyncAccountReply.ProtoReflect.Descriptor instead.
func (*CreateSyncAccountReply) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{5}
}</span>

func (x *CreateSyncAccountReply) GetTaskId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TaskId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateSyncAccountReply) GetCreateTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreateTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// 查询同步请求
type GetSyncAccountRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        TaskId        string                 `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"` // 要查询的任务ID
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetSyncAccountRequest) Reset() <span class="cov0" title="0">{
        *x = GetSyncAccountRequest{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSyncAccountRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSyncAccountRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSyncAccountRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSyncAccountRequest.ProtoReflect.Descriptor instead.
func (*GetSyncAccountRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{6}
}</span>

func (x *GetSyncAccountRequest) GetTaskId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TaskId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// 查询同步响应
type GetSyncAccountReply struct {
        state                       protoimpl.MessageState     `protogen:"open.v1"`
        Status                      GetSyncAccountReply_Status `protobuf:"varint,1,opt,name=status,proto3,enum=api.account.v1.GetSyncAccountReply_Status" json:"status,omitempty"`
        UserCount                   int64                      `protobuf:"varint,2,opt,name=user_count,json=userCount,proto3" json:"user_count,omitempty"`
        DepartmentCount             int64                      `protobuf:"varint,3,opt,name=department_count,json=departmentCount,proto3" json:"department_count,omitempty"`
        UserDepartmentRelationCount int64                      `protobuf:"varint,4,opt,name=user_department_relation_count,json=userDepartmentRelationCount,proto3" json:"user_department_relation_count,omitempty"`
        ActualTime                  int64                      `protobuf:"varint,5,opt,name=actual_time,json=actualTime,proto3" json:"actual_time,omitempty"`
        StartTime                   *timestamppb.Timestamp     `protobuf:"bytes,6,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
        LatestSyncTime              *timestamppb.Timestamp     `protobuf:"bytes,7,opt,name=latest_sync_time,json=latestSyncTime,proto3" json:"latest_sync_time,omitempty"`
        unknownFields               protoimpl.UnknownFields
        sizeCache                   protoimpl.SizeCache
}

func (x *GetSyncAccountReply) Reset() <span class="cov0" title="0">{
        *x = GetSyncAccountReply{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSyncAccountReply) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSyncAccountReply) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSyncAccountReply) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSyncAccountReply.ProtoReflect.Descriptor instead.
func (*GetSyncAccountReply) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{7}
}</span>

func (x *GetSyncAccountReply) GetStatus() GetSyncAccountReply_Status <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return GetSyncAccountReply_PENDING</span>
}

func (x *GetSyncAccountReply) GetUserCount() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetSyncAccountReply) GetDepartmentCount() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DepartmentCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetSyncAccountReply) GetUserDepartmentRelationCount() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserDepartmentRelationCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetSyncAccountReply) GetActualTime() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ActualTime
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetSyncAccountReply) GetStartTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StartTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetSyncAccountReply) GetLatestSyncTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LatestSyncTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CancelSyncAccountRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        TaskId        string                 `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"` // 要删除的任务ID
        Tags          []string               `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CancelSyncAccountRequest) Reset() <span class="cov0" title="0">{
        *x = CancelSyncAccountRequest{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CancelSyncAccountRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CancelSyncAccountRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CancelSyncAccountRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CancelSyncAccountRequest.ProtoReflect.Descriptor instead.
func (*CancelSyncAccountRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{8}
}</span>

func (x *CancelSyncAccountRequest) GetTaskId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TaskId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CancelSyncAccountRequest) GetTags() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetAccessTokenRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Code          string                 `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetAccessTokenRequest) Reset() <span class="cov0" title="0">{
        *x = GetAccessTokenRequest{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetAccessTokenRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetAccessTokenRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetAccessTokenRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetAccessTokenRequest.ProtoReflect.Descriptor instead.
func (*GetAccessTokenRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{9}
}</span>

func (x *GetAccessTokenRequest) GetCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetAccessTokenResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        AccessToken   string                 `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        RefreshToken  string                 `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
        ExpiresIn     int64                  `protobuf:"varint,3,opt,name=expires_in,json=expiresIn,proto3" json:"expires_in,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetAccessTokenResponse) Reset() <span class="cov0" title="0">{
        *x = GetAccessTokenResponse{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetAccessTokenResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetAccessTokenResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetAccessTokenResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetAccessTokenResponse.ProtoReflect.Descriptor instead.
func (*GetAccessTokenResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{10}
}</span>

func (x *GetAccessTokenResponse) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetAccessTokenResponse) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetAccessTokenResponse) GetExpiresIn() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresIn
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetUserInfoRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        AccessToken   string                 `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserInfoRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserInfoRequest{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserInfoRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserInfoRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserInfoRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserInfoRequest.ProtoReflect.Descriptor instead.
func (*GetUserInfoRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{11}
}</span>

func (x *GetUserInfoRequest) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetUserInfoResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UnionId       string                 `protobuf:"bytes,1,opt,name=union_id,json=unionId,proto3" json:"union_id,omitempty"`
        UserId        string                 `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Name          string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
        Email         string                 `protobuf:"bytes,4,opt,name=email,proto3" json:"email,omitempty"`
        Avatar        string                 `protobuf:"bytes,5,opt,name=avatar,proto3" json:"avatar,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserInfoResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserInfoResponse{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserInfoResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserInfoResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserInfoResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserInfoResponse.ProtoReflect.Descriptor instead.
func (*GetUserInfoResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{12}
}</span>

func (x *GetUserInfoResponse) GetUnionId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UnionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetUserInfoResponse) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetUserInfoResponse) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetUserInfoResponse) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetUserInfoResponse) GetAvatar() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Avatar
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CallbackRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Code          string                 `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`   // OAuth2 授权码
        State         string                 `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"` // 防止 CSRF 的随机字符串
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CallbackRequest) Reset() <span class="cov0" title="0">{
        *x = CallbackRequest{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CallbackRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CallbackRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CallbackRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CallbackRequest.ProtoReflect.Descriptor instead.
func (*CallbackRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{13}
}</span>

func (x *CallbackRequest) GetCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CallbackRequest) GetState() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.State
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// 定义回调响应
type CallbackResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Status        string                 `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`   // 例如 "success" 或 "error"
        Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"` // 可选描述信息
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CallbackResponse) Reset() <span class="cov0" title="0">{
        *x = CallbackResponse{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CallbackResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CallbackResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CallbackResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CallbackResponse.ProtoReflect.Descriptor instead.
func (*CallbackResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{14}
}</span>

func (x *CallbackResponse) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CallbackResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetTaskReply_Task struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Status        string                 `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
        CreateTime    *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
        StartTime     *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
        CompletedTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=completed_time,json=completedTime,proto3" json:"completed_time,omitempty"`
        ActurlTime    int32                  `protobuf:"varint,6,opt,name=acturl_time,json=acturlTime,proto3" json:"acturl_time,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetTaskReply_Task) Reset() <span class="cov0" title="0">{
        *x = GetTaskReply_Task{}
        mi := &amp;file_api_account_v1_account_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTaskReply_Task) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTaskReply_Task) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTaskReply_Task) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_account_v1_account_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTaskReply_Task.ProtoReflect.Descriptor instead.
func (*GetTaskReply_Task) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_account_v1_account_proto_rawDescGZIP(), []int{1, 0}
}</span>

func (x *GetTaskReply_Task) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetTaskReply_Task) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetTaskReply_Task) GetCreateTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreateTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetTaskReply_Task) GetStartTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StartTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetTaskReply_Task) GetCompletedTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CompletedTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetTaskReply_Task) GetActurlTime() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ActurlTime
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_api_account_v1_account_proto protoreflect.FileDescriptor

const file_api_account_v1_account_proto_rawDesc = "" +
        "\n" +
        "\x1capi/account/v1/account.proto\x12\x0eapi.account.v1\x1a\x1cgoogle/api/annotations.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bgoogle/protobuf/empty.proto\"-\n" +
        "\x0eGetTaskRequest\x12\x1b\n" +
        "\ttask_name\x18\x01 \x01(\tR\btaskName\"\xd6\x02\n" +
        "\fGetTaskReply\x125\n" +
        "\x04task\x18\x01 \x01(\v2!.api.account.v1.GetTaskReply.TaskR\x04task\x1a\x8e\x02\n" +
        "\x04Task\x12\x12\n" +
        "\x04name\x18\x01 \x01(\tR\x04name\x12\x16\n" +
        "\x06status\x18\x02 \x01(\tR\x06status\x12;\n" +
        "\vcreate_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
        "createTime\x129\n" +
        "\n" +
        "start_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\tstartTime\x12A\n" +
        "\x0ecompleted_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\rcompletedTime\x12\x1f\n" +
        "\vacturl_time\x18\x06 \x01(\x05R\n" +
        "acturlTime\"?\n" +
        "\rUploadRequest\x12\x12\n" +
        "\x04file\x18\x01 \x01(\fR\x04file\x12\x1a\n" +
        "\bfilename\x18\x02 \x01(\tR\bfilename\"3\n" +
        "\vUploadReply\x12\x10\n" +
        "\x03url\x18\x01 \x01(\tR\x03url\x12\x12\n" +
        "\x04task\x18\x02 \x01(\tR\x04task\"\xc1\x01\n" +
        "\x18CreateSyncAccountRequest\x12&gt;\n" +
        "\ftrigger_type\x18\x01 \x01(\x0e2\x1b.api.account.v1.TriggerTypeR\vtriggerType\x125\n" +
        "\tsync_type\x18\x02 \x01(\x0e2\x18.api.account.v1.SyncTypeR\bsyncType\x12 \n" +
        "\ttask_name\x18\x03 \x01(\tH\x00R\btaskName\x88\x01\x01B\f\n" +
        "\n" +
        "_task_name\"n\n" +
        "\x16CreateSyncAccountReply\x12\x17\n" +
        "\atask_id\x18\x01 \x01(\tR\x06taskId\x12;\n" +
        "\vcreate_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
        "createTime\"0\n" +
        "\x15GetSyncAccountRequest\x12\x17\n" +
        "\atask_id\x18\x01 \x01(\tR\x06taskId\"\xc7\x03\n" +
        "\x13GetSyncAccountReply\x12B\n" +
        "\x06status\x18\x01 \x01(\x0e2*.api.account.v1.GetSyncAccountReply.StatusR\x06status\x12\x1d\n" +
        "\n" +
        "user_count\x18\x02 \x01(\x03R\tuserCount\x12)\n" +
        "\x10department_count\x18\x03 \x01(\x03R\x0fdepartmentCount\x12C\n" +
        "\x1euser_department_relation_count\x18\x04 \x01(\x03R\x1buserDepartmentRelationCount\x12\x1f\n" +
        "\vactual_time\x18\x05 \x01(\x03R\n" +
        "actualTime\x129\n" +
        "\n" +
        "start_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\tstartTime\x12D\n" +
        "\x10latest_sync_time\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\x0elatestSyncTime\";\n" +
        "\x06Status\x12\v\n" +
        "\aPENDING\x10\x00\x12\v\n" +
        "\aRUNNING\x10\x01\x12\v\n" +
        "\aSUCCESS\x10\x02\x12\n" +
        "\n" +
        "\x06FAILED\x10\x03\"G\n" +
        "\x18CancelSyncAccountRequest\x12\x17\n" +
        "\atask_id\x18\x01 \x01(\tR\x06taskId\x12\x12\n" +
        "\x04tags\x18\x02 \x03(\tR\x04tags\"+\n" +
        "\x15GetAccessTokenRequest\x12\x12\n" +
        "\x04code\x18\x02 \x01(\tR\x04code\"\x7f\n" +
        "\x16GetAccessTokenResponse\x12!\n" +
        "\faccess_token\x18\x01 \x01(\tR\vaccessToken\x12#\n" +
        "\rrefresh_token\x18\x02 \x01(\tR\frefreshToken\x12\x1d\n" +
        "\n" +
        "expires_in\x18\x03 \x01(\x03R\texpiresIn\"7\n" +
        "\x12GetUserInfoRequest\x12!\n" +
        "\faccess_token\x18\x01 \x01(\tR\vaccessToken\"\x8b\x01\n" +
        "\x13GetUserInfoResponse\x12\x19\n" +
        "\bunion_id\x18\x01 \x01(\tR\aunionId\x12\x17\n" +
        "\auser_id\x18\x02 \x01(\tR\x06userId\x12\x12\n" +
        "\x04name\x18\x03 \x01(\tR\x04name\x12\x14\n" +
        "\x05email\x18\x04 \x01(\tR\x05email\x12\x16\n" +
        "\x06avatar\x18\x05 \x01(\tR\x06avatar\";\n" +
        "\x0fCallbackRequest\x12\x12\n" +
        "\x04code\x18\x01 \x01(\tR\x04code\x12\x14\n" +
        "\x05state\x18\x02 \x01(\tR\x05state\"D\n" +
        "\x10CallbackResponse\x12\x16\n" +
        "\x06status\x18\x01 \x01(\tR\x06status\x12\x18\n" +
        "\amessage\x18\x02 \x01(\tR\amessage*M\n" +
        "\vTriggerType\x12\x13\n" +
        "\x0fTRIGGER_UNKNOWN\x10\x00\x12\x12\n" +
        "\x0eTRIGGER_MANUAL\x10\x01\x12\x15\n" +
        "\x11TRIGGER_SCHEDULED\x10\x02*%\n" +
        "\bSyncType\x12\b\n" +
        "\x04FULL\x10\x00\x12\x0f\n" +
        "\vINCREMENTAL\x10\x012\x87\a\n" +
        "\aAccount\x12}\n" +
        "\x11CreateSyncAccount\x12(.api.account.v1.CreateSyncAccountRequest\x1a&amp;.api.account.v1.CreateSyncAccountReply\"\x16\x82\xd3\xe4\x93\x02\x10:\x01*\"\v/v1/account\x12q\n" +
        "\x0eGetSyncAccount\x12%.api.account.v1.GetSyncAccountRequest\x1a#.api.account.v1.GetSyncAccountReply\"\x13\x82\xd3\xe4\x93\x02\r\x12\v/v1/account\x12g\n" +
        "\x0eCancelSyncTask\x12(.api.account.v1.CancelSyncAccountRequest\x1a\x16.google.protobuf.Empty\"\x13\x82\xd3\xe4\x93\x02\r*\v/v1/account\x12u\n" +
        "\vGetUserInfo\x12\".api.account.v1.GetUserInfoRequest\x1a#.api.account.v1.GetUserInfoResponse\"\x1d\x82\xd3\xe4\x93\x02\x17\x12\x15/v1/oauth/userinfo/me\x12\x82\x01\n" +
        "\x0eGetAccessToken\x12%.api.account.v1.GetAccessTokenRequest\x1a&amp;.api.account.v1.GetAccessTokenResponse\"!\x82\xd3\xe4\x93\x02\x1b\x12\x19/v1/oauth/userAccessToken\x12i\n" +
        "\bCallback\x12\x1f.api.account.v1.CallbackRequest\x1a .api.account.v1.CallbackResponse\"\x1a\x82\xd3\xe4\x93\x02\x14\x12\x12/v1/oauth/callback\x12_\n" +
        "\n" +
        "UploadFile\x12\x1d.api.account.v1.UploadRequest\x1a\x1b.api.account.v1.UploadReply\"\x15\x82\xd3\xe4\x93\x02\x0f:\x01*\"\n" +
        "/v1/upload\x12Y\n" +
        "\aGetTask\x12\x1e.api.account.v1.GetTaskRequest\x1a\x1c.api.account.v1.GetTaskReply\"\x10\x82\xd3\xe4\x93\x02\n" +
        "\x12\b/v1/taskB?\n" +
        "\x0eapi.account.v1B\x0eAccountProtoV1P\x01Z\x1bnancalacc/api/account/v1;v1b\x06proto3"

var (
        file_api_account_v1_account_proto_rawDescOnce sync.Once
        file_api_account_v1_account_proto_rawDescData []byte
)

func file_api_account_v1_account_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_api_account_v1_account_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_api_account_v1_account_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_account_v1_account_proto_rawDesc), len(file_api_account_v1_account_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_api_account_v1_account_proto_rawDescData</span>
}

var file_api_account_v1_account_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_api_account_v1_account_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_api_account_v1_account_proto_goTypes = []any{
        (TriggerType)(0),                 // 0: api.account.v1.TriggerType
        (SyncType)(0),                    // 1: api.account.v1.SyncType
        (GetSyncAccountReply_Status)(0),  // 2: api.account.v1.GetSyncAccountReply.Status
        (*GetTaskRequest)(nil),           // 3: api.account.v1.GetTaskRequest
        (*GetTaskReply)(nil),             // 4: api.account.v1.GetTaskReply
        (*UploadRequest)(nil),            // 5: api.account.v1.UploadRequest
        (*UploadReply)(nil),              // 6: api.account.v1.UploadReply
        (*CreateSyncAccountRequest)(nil), // 7: api.account.v1.CreateSyncAccountRequest
        (*CreateSyncAccountReply)(nil),   // 8: api.account.v1.CreateSyncAccountReply
        (*GetSyncAccountRequest)(nil),    // 9: api.account.v1.GetSyncAccountRequest
        (*GetSyncAccountReply)(nil),      // 10: api.account.v1.GetSyncAccountReply
        (*CancelSyncAccountRequest)(nil), // 11: api.account.v1.CancelSyncAccountRequest
        (*GetAccessTokenRequest)(nil),    // 12: api.account.v1.GetAccessTokenRequest
        (*GetAccessTokenResponse)(nil),   // 13: api.account.v1.GetAccessTokenResponse
        (*GetUserInfoRequest)(nil),       // 14: api.account.v1.GetUserInfoRequest
        (*GetUserInfoResponse)(nil),      // 15: api.account.v1.GetUserInfoResponse
        (*CallbackRequest)(nil),          // 16: api.account.v1.CallbackRequest
        (*CallbackResponse)(nil),         // 17: api.account.v1.CallbackResponse
        (*GetTaskReply_Task)(nil),        // 18: api.account.v1.GetTaskReply.Task
        (*timestamppb.Timestamp)(nil),    // 19: google.protobuf.Timestamp
        (*emptypb.Empty)(nil),            // 20: google.protobuf.Empty
}
var file_api_account_v1_account_proto_depIdxs = []int32{
        18, // 0: api.account.v1.GetTaskReply.task:type_name -&gt; api.account.v1.GetTaskReply.Task
        0,  // 1: api.account.v1.CreateSyncAccountRequest.trigger_type:type_name -&gt; api.account.v1.TriggerType
        1,  // 2: api.account.v1.CreateSyncAccountRequest.sync_type:type_name -&gt; api.account.v1.SyncType
        19, // 3: api.account.v1.CreateSyncAccountReply.create_time:type_name -&gt; google.protobuf.Timestamp
        2,  // 4: api.account.v1.GetSyncAccountReply.status:type_name -&gt; api.account.v1.GetSyncAccountReply.Status
        19, // 5: api.account.v1.GetSyncAccountReply.start_time:type_name -&gt; google.protobuf.Timestamp
        19, // 6: api.account.v1.GetSyncAccountReply.latest_sync_time:type_name -&gt; google.protobuf.Timestamp
        19, // 7: api.account.v1.GetTaskReply.Task.create_time:type_name -&gt; google.protobuf.Timestamp
        19, // 8: api.account.v1.GetTaskReply.Task.start_time:type_name -&gt; google.protobuf.Timestamp
        19, // 9: api.account.v1.GetTaskReply.Task.completed_time:type_name -&gt; google.protobuf.Timestamp
        7,  // 10: api.account.v1.Account.CreateSyncAccount:input_type -&gt; api.account.v1.CreateSyncAccountRequest
        9,  // 11: api.account.v1.Account.GetSyncAccount:input_type -&gt; api.account.v1.GetSyncAccountRequest
        11, // 12: api.account.v1.Account.CancelSyncTask:input_type -&gt; api.account.v1.CancelSyncAccountRequest
        14, // 13: api.account.v1.Account.GetUserInfo:input_type -&gt; api.account.v1.GetUserInfoRequest
        12, // 14: api.account.v1.Account.GetAccessToken:input_type -&gt; api.account.v1.GetAccessTokenRequest
        16, // 15: api.account.v1.Account.Callback:input_type -&gt; api.account.v1.CallbackRequest
        5,  // 16: api.account.v1.Account.UploadFile:input_type -&gt; api.account.v1.UploadRequest
        3,  // 17: api.account.v1.Account.GetTask:input_type -&gt; api.account.v1.GetTaskRequest
        8,  // 18: api.account.v1.Account.CreateSyncAccount:output_type -&gt; api.account.v1.CreateSyncAccountReply
        10, // 19: api.account.v1.Account.GetSyncAccount:output_type -&gt; api.account.v1.GetSyncAccountReply
        20, // 20: api.account.v1.Account.CancelSyncTask:output_type -&gt; google.protobuf.Empty
        15, // 21: api.account.v1.Account.GetUserInfo:output_type -&gt; api.account.v1.GetUserInfoResponse
        13, // 22: api.account.v1.Account.GetAccessToken:output_type -&gt; api.account.v1.GetAccessTokenResponse
        17, // 23: api.account.v1.Account.Callback:output_type -&gt; api.account.v1.CallbackResponse
        6,  // 24: api.account.v1.Account.UploadFile:output_type -&gt; api.account.v1.UploadReply
        4,  // 25: api.account.v1.Account.GetTask:output_type -&gt; api.account.v1.GetTaskReply
        18, // [18:26] is the sub-list for method output_type
        10, // [10:18] is the sub-list for method input_type
        10, // [10:10] is the sub-list for extension type_name
        10, // [10:10] is the sub-list for extension extendee
        0,  // [0:10] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_api_account_v1_account_proto_init() }</span>
func file_api_account_v1_account_proto_init() <span class="cov0" title="0">{
        if File_api_account_v1_account_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_api_account_v1_account_proto_msgTypes[4].OneofWrappers = []any{}
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_account_v1_account_proto_rawDesc), len(file_api_account_v1_account_proto_rawDesc)),
                        NumEnums:      3,
                        NumMessages:   16,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_api_account_v1_account_proto_goTypes,
                DependencyIndexes: file_api_account_v1_account_proto_depIdxs,
                EnumInfos:         file_api_account_v1_account_proto_enumTypes,
                MessageInfos:      file_api_account_v1_account_proto_msgTypes,
        }.Build()
        File_api_account_v1_account_proto = out.File
        file_api_account_v1_account_proto_goTypes = nil
        file_api_account_v1_account_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: api/account/v1/account.proto

package v1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Account_CreateSyncAccount_FullMethodName = "/api.account.v1.Account/CreateSyncAccount"
        Account_GetSyncAccount_FullMethodName    = "/api.account.v1.Account/GetSyncAccount"
        Account_CancelSyncTask_FullMethodName    = "/api.account.v1.Account/CancelSyncTask"
        Account_GetUserInfo_FullMethodName       = "/api.account.v1.Account/GetUserInfo"
        Account_GetAccessToken_FullMethodName    = "/api.account.v1.Account/GetAccessToken"
        Account_Callback_FullMethodName          = "/api.account.v1.Account/Callback"
        Account_UploadFile_FullMethodName        = "/api.account.v1.Account/UploadFile"
        Account_GetTask_FullMethodName           = "/api.account.v1.Account/GetTask"
)

// AccountClient is the client API for Account service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AccountClient interface {
        CreateSyncAccount(ctx context.Context, in *CreateSyncAccountRequest, opts ...grpc.CallOption) (*CreateSyncAccountReply, error)
        GetSyncAccount(ctx context.Context, in *GetSyncAccountRequest, opts ...grpc.CallOption) (*GetSyncAccountReply, error)
        CancelSyncTask(ctx context.Context, in *CancelSyncAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*GetUserInfoResponse, error)
        GetAccessToken(ctx context.Context, in *GetAccessTokenRequest, opts ...grpc.CallOption) (*GetAccessTokenResponse, error)
        Callback(ctx context.Context, in *CallbackRequest, opts ...grpc.CallOption) (*CallbackResponse, error)
        UploadFile(ctx context.Context, in *UploadRequest, opts ...grpc.CallOption) (*UploadReply, error)
        GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*GetTaskReply, error)
}

type accountClient struct {
        cc grpc.ClientConnInterface
}

func NewAccountClient(cc grpc.ClientConnInterface) AccountClient <span class="cov0" title="0">{
        return &amp;accountClient{cc}
}</span>

func (c *accountClient) CreateSyncAccount(ctx context.Context, in *CreateSyncAccountRequest, opts ...grpc.CallOption) (*CreateSyncAccountReply, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateSyncAccountReply)
        err := c.cc.Invoke(ctx, Account_CreateSyncAccount_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *accountClient) GetSyncAccount(ctx context.Context, in *GetSyncAccountRequest, opts ...grpc.CallOption) (*GetSyncAccountReply, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetSyncAccountReply)
        err := c.cc.Invoke(ctx, Account_GetSyncAccount_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *accountClient) CancelSyncTask(ctx context.Context, in *CancelSyncAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, Account_CancelSyncTask_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *accountClient) GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*GetUserInfoResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserInfoResponse)
        err := c.cc.Invoke(ctx, Account_GetUserInfo_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *accountClient) GetAccessToken(ctx context.Context, in *GetAccessTokenRequest, opts ...grpc.CallOption) (*GetAccessTokenResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetAccessTokenResponse)
        err := c.cc.Invoke(ctx, Account_GetAccessToken_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *accountClient) Callback(ctx context.Context, in *CallbackRequest, opts ...grpc.CallOption) (*CallbackResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CallbackResponse)
        err := c.cc.Invoke(ctx, Account_Callback_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *accountClient) UploadFile(ctx context.Context, in *UploadRequest, opts ...grpc.CallOption) (*UploadReply, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UploadReply)
        err := c.cc.Invoke(ctx, Account_UploadFile_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *accountClient) GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*GetTaskReply, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetTaskReply)
        err := c.cc.Invoke(ctx, Account_GetTask_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AccountServer is the server API for Account service.
// All implementations must embed UnimplementedAccountServer
// for forward compatibility.
type AccountServer interface {
        CreateSyncAccount(context.Context, *CreateSyncAccountRequest) (*CreateSyncAccountReply, error)
        GetSyncAccount(context.Context, *GetSyncAccountRequest) (*GetSyncAccountReply, error)
        CancelSyncTask(context.Context, *CancelSyncAccountRequest) (*emptypb.Empty, error)
        GetUserInfo(context.Context, *GetUserInfoRequest) (*GetUserInfoResponse, error)
        GetAccessToken(context.Context, *GetAccessTokenRequest) (*GetAccessTokenResponse, error)
        Callback(context.Context, *CallbackRequest) (*CallbackResponse, error)
        UploadFile(context.Context, *UploadRequest) (*UploadReply, error)
        GetTask(context.Context, *GetTaskRequest) (*GetTaskReply, error)
        mustEmbedUnimplementedAccountServer()
}

// UnimplementedAccountServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAccountServer struct{}

func (UnimplementedAccountServer) CreateSyncAccount(context.Context, *CreateSyncAccountRequest) (*CreateSyncAccountReply, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateSyncAccount not implemented")
}</span>
func (UnimplementedAccountServer) GetSyncAccount(context.Context, *GetSyncAccountRequest) (*GetSyncAccountReply, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSyncAccount not implemented")
}</span>
func (UnimplementedAccountServer) CancelSyncTask(context.Context, *CancelSyncAccountRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CancelSyncTask not implemented")
}</span>
func (UnimplementedAccountServer) GetUserInfo(context.Context, *GetUserInfoRequest) (*GetUserInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserInfo not implemented")
}</span>
func (UnimplementedAccountServer) GetAccessToken(context.Context, *GetAccessTokenRequest) (*GetAccessTokenResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetAccessToken not implemented")
}</span>
func (UnimplementedAccountServer) Callback(context.Context, *CallbackRequest) (*CallbackResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Callback not implemented")
}</span>
func (UnimplementedAccountServer) UploadFile(context.Context, *UploadRequest) (*UploadReply, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UploadFile not implemented")
}</span>
func (UnimplementedAccountServer) GetTask(context.Context, *GetTaskRequest) (*GetTaskReply, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetTask not implemented")
}</span>
func (UnimplementedAccountServer) mustEmbedUnimplementedAccountServer() {<span class="cov0" title="0">}</span>
func (UnimplementedAccountServer) testEmbeddedByValue()                 {<span class="cov0" title="0">}</span>

// UnsafeAccountServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccountServer will
// result in compilation errors.
type UnsafeAccountServer interface {
        mustEmbedUnimplementedAccountServer()
}

func RegisterAccountServer(s grpc.ServiceRegistrar, srv AccountServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedAccountServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Account_ServiceDesc, srv)</span>
}

func _Account_CreateSyncAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateSyncAccountRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AccountServer).CreateSyncAccount(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Account_CreateSyncAccount_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AccountServer).CreateSyncAccount(ctx, req.(*CreateSyncAccountRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Account_GetSyncAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetSyncAccountRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AccountServer).GetSyncAccount(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Account_GetSyncAccount_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AccountServer).GetSyncAccount(ctx, req.(*GetSyncAccountRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Account_CancelSyncTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CancelSyncAccountRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AccountServer).CancelSyncTask(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Account_CancelSyncTask_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AccountServer).CancelSyncTask(ctx, req.(*CancelSyncAccountRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Account_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AccountServer).GetUserInfo(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Account_GetUserInfo_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AccountServer).GetUserInfo(ctx, req.(*GetUserInfoRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Account_GetAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetAccessTokenRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AccountServer).GetAccessToken(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Account_GetAccessToken_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AccountServer).GetAccessToken(ctx, req.(*GetAccessTokenRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Account_Callback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CallbackRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AccountServer).Callback(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Account_Callback_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AccountServer).Callback(ctx, req.(*CallbackRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Account_UploadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UploadRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AccountServer).UploadFile(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Account_UploadFile_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AccountServer).UploadFile(ctx, req.(*UploadRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Account_GetTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetTaskRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AccountServer).GetTask(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Account_GetTask_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AccountServer).GetTask(ctx, req.(*GetTaskRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Account_ServiceDesc is the grpc.ServiceDesc for Account service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Account_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "api.account.v1.Account",
        HandlerType: (*AccountServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateSyncAccount",
                        Handler:    _Account_CreateSyncAccount_Handler,
                },
                {
                        MethodName: "GetSyncAccount",
                        Handler:    _Account_GetSyncAccount_Handler,
                },
                {
                        MethodName: "CancelSyncTask",
                        Handler:    _Account_CancelSyncTask_Handler,
                },
                {
                        MethodName: "GetUserInfo",
                        Handler:    _Account_GetUserInfo_Handler,
                },
                {
                        MethodName: "GetAccessToken",
                        Handler:    _Account_GetAccessToken_Handler,
                },
                {
                        MethodName: "Callback",
                        Handler:    _Account_Callback_Handler,
                },
                {
                        MethodName: "UploadFile",
                        Handler:    _Account_UploadFile_Handler,
                },
                {
                        MethodName: "GetTask",
                        Handler:    _Account_GetTask_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "api/account/v1/account.proto",
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.4
// - protoc             v5.29.3
// source: api/account/v1/account.proto

package v1

import (
        context "context"
        http "github.com/go-kratos/kratos/v2/transport/http"
        binding "github.com/go-kratos/kratos/v2/transport/http/binding"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationAccountCallback = "/api.account.v1.Account/Callback"
const OperationAccountCancelSyncTask = "/api.account.v1.Account/CancelSyncTask"
const OperationAccountCreateSyncAccount = "/api.account.v1.Account/CreateSyncAccount"
const OperationAccountGetAccessToken = "/api.account.v1.Account/GetAccessToken"
const OperationAccountGetSyncAccount = "/api.account.v1.Account/GetSyncAccount"
const OperationAccountGetTask = "/api.account.v1.Account/GetTask"
const OperationAccountGetUserInfo = "/api.account.v1.Account/GetUserInfo"
const OperationAccountUploadFile = "/api.account.v1.Account/UploadFile"

type AccountHTTPServer interface {
        Callback(context.Context, *CallbackRequest) (*CallbackResponse, error)
        CancelSyncTask(context.Context, *CancelSyncAccountRequest) (*emptypb.Empty, error)
        CreateSyncAccount(context.Context, *CreateSyncAccountRequest) (*CreateSyncAccountReply, error)
        GetAccessToken(context.Context, *GetAccessTokenRequest) (*GetAccessTokenResponse, error)
        GetSyncAccount(context.Context, *GetSyncAccountRequest) (*GetSyncAccountReply, error)
        GetTask(context.Context, *GetTaskRequest) (*GetTaskReply, error)
        GetUserInfo(context.Context, *GetUserInfoRequest) (*GetUserInfoResponse, error)
        UploadFile(context.Context, *UploadRequest) (*UploadReply, error)
}

func RegisterAccountHTTPServer(s *http.Server, srv AccountHTTPServer) <span class="cov0" title="0">{
        r := s.Route("/")
        r.POST("/v1/account", _Account_CreateSyncAccount0_HTTP_Handler(srv))
        r.GET("/v1/account", _Account_GetSyncAccount0_HTTP_Handler(srv))
        r.DELETE("/v1/account", _Account_CancelSyncTask0_HTTP_Handler(srv))
        r.GET("/v1/oauth/userinfo/me", _Account_GetUserInfo0_HTTP_Handler(srv))
        r.GET("/v1/oauth/userAccessToken", _Account_GetAccessToken0_HTTP_Handler(srv))
        r.GET("/v1/oauth/callback", _Account_Callback0_HTTP_Handler(srv))
        r.POST("/v1/upload", _Account_UploadFile0_HTTP_Handler(srv))
        r.GET("/v1/task", _Account_GetTask0_HTTP_Handler(srv))
}</span>

func _Account_CreateSyncAccount0_HTTP_Handler(srv AccountHTTPServer) func(ctx http.Context) error <span class="cov0" title="0">{
        return func(ctx http.Context) error </span><span class="cov0" title="0">{
                var in CreateSyncAccountRequest
                if err := ctx.Bind(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := ctx.BindQuery(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">http.SetOperation(ctx, OperationAccountCreateSyncAccount)
                h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return srv.CreateSyncAccount(ctx, req.(*CreateSyncAccountRequest))
                }</span>)
                <span class="cov0" title="0">out, err := h(ctx, &amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reply := out.(*CreateSyncAccountReply)
                return ctx.Result(200, reply)</span>
        }
}

func _Account_GetSyncAccount0_HTTP_Handler(srv AccountHTTPServer) func(ctx http.Context) error <span class="cov0" title="0">{
        return func(ctx http.Context) error </span><span class="cov0" title="0">{
                var in GetSyncAccountRequest
                if err := ctx.BindQuery(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">http.SetOperation(ctx, OperationAccountGetSyncAccount)
                h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return srv.GetSyncAccount(ctx, req.(*GetSyncAccountRequest))
                }</span>)
                <span class="cov0" title="0">out, err := h(ctx, &amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reply := out.(*GetSyncAccountReply)
                return ctx.Result(200, reply)</span>
        }
}

func _Account_CancelSyncTask0_HTTP_Handler(srv AccountHTTPServer) func(ctx http.Context) error <span class="cov0" title="0">{
        return func(ctx http.Context) error </span><span class="cov0" title="0">{
                var in CancelSyncAccountRequest
                if err := ctx.BindQuery(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">http.SetOperation(ctx, OperationAccountCancelSyncTask)
                h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return srv.CancelSyncTask(ctx, req.(*CancelSyncAccountRequest))
                }</span>)
                <span class="cov0" title="0">out, err := h(ctx, &amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reply := out.(*emptypb.Empty)
                return ctx.Result(200, reply)</span>
        }
}

func _Account_GetUserInfo0_HTTP_Handler(srv AccountHTTPServer) func(ctx http.Context) error <span class="cov0" title="0">{
        return func(ctx http.Context) error </span><span class="cov0" title="0">{
                var in GetUserInfoRequest
                if err := ctx.BindQuery(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">http.SetOperation(ctx, OperationAccountGetUserInfo)
                h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return srv.GetUserInfo(ctx, req.(*GetUserInfoRequest))
                }</span>)
                <span class="cov0" title="0">out, err := h(ctx, &amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reply := out.(*GetUserInfoResponse)
                return ctx.Result(200, reply)</span>
        }
}

func _Account_GetAccessToken0_HTTP_Handler(srv AccountHTTPServer) func(ctx http.Context) error <span class="cov0" title="0">{
        return func(ctx http.Context) error </span><span class="cov0" title="0">{
                var in GetAccessTokenRequest
                if err := ctx.BindQuery(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">http.SetOperation(ctx, OperationAccountGetAccessToken)
                h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return srv.GetAccessToken(ctx, req.(*GetAccessTokenRequest))
                }</span>)
                <span class="cov0" title="0">out, err := h(ctx, &amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reply := out.(*GetAccessTokenResponse)
                return ctx.Result(200, reply)</span>
        }
}

func _Account_Callback0_HTTP_Handler(srv AccountHTTPServer) func(ctx http.Context) error <span class="cov0" title="0">{
        return func(ctx http.Context) error </span><span class="cov0" title="0">{
                var in CallbackRequest
                if err := ctx.BindQuery(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">http.SetOperation(ctx, OperationAccountCallback)
                h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return srv.Callback(ctx, req.(*CallbackRequest))
                }</span>)
                <span class="cov0" title="0">out, err := h(ctx, &amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reply := out.(*CallbackResponse)
                return ctx.Result(200, reply)</span>
        }
}

func _Account_UploadFile0_HTTP_Handler(srv AccountHTTPServer) func(ctx http.Context) error <span class="cov0" title="0">{
        return func(ctx http.Context) error </span><span class="cov0" title="0">{
                var in UploadRequest
                if err := ctx.Bind(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := ctx.BindQuery(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">http.SetOperation(ctx, OperationAccountUploadFile)
                h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return srv.UploadFile(ctx, req.(*UploadRequest))
                }</span>)
                <span class="cov0" title="0">out, err := h(ctx, &amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reply := out.(*UploadReply)
                return ctx.Result(200, reply)</span>
        }
}

func _Account_GetTask0_HTTP_Handler(srv AccountHTTPServer) func(ctx http.Context) error <span class="cov0" title="0">{
        return func(ctx http.Context) error </span><span class="cov0" title="0">{
                var in GetTaskRequest
                if err := ctx.BindQuery(&amp;in); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">http.SetOperation(ctx, OperationAccountGetTask)
                h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        return srv.GetTask(ctx, req.(*GetTaskRequest))
                }</span>)
                <span class="cov0" title="0">out, err := h(ctx, &amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reply := out.(*GetTaskReply)
                return ctx.Result(200, reply)</span>
        }
}

type AccountHTTPClient interface {
        Callback(ctx context.Context, req *CallbackRequest, opts ...http.CallOption) (rsp *CallbackResponse, err error)
        CancelSyncTask(ctx context.Context, req *CancelSyncAccountRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
        CreateSyncAccount(ctx context.Context, req *CreateSyncAccountRequest, opts ...http.CallOption) (rsp *CreateSyncAccountReply, err error)
        GetAccessToken(ctx context.Context, req *GetAccessTokenRequest, opts ...http.CallOption) (rsp *GetAccessTokenResponse, err error)
        GetSyncAccount(ctx context.Context, req *GetSyncAccountRequest, opts ...http.CallOption) (rsp *GetSyncAccountReply, err error)
        GetTask(ctx context.Context, req *GetTaskRequest, opts ...http.CallOption) (rsp *GetTaskReply, err error)
        GetUserInfo(ctx context.Context, req *GetUserInfoRequest, opts ...http.CallOption) (rsp *GetUserInfoResponse, err error)
        UploadFile(ctx context.Context, req *UploadRequest, opts ...http.CallOption) (rsp *UploadReply, err error)
}

type AccountHTTPClientImpl struct {
        cc *http.Client
}

func NewAccountHTTPClient(client *http.Client) AccountHTTPClient <span class="cov0" title="0">{
        return &amp;AccountHTTPClientImpl{client}
}</span>

func (c *AccountHTTPClientImpl) Callback(ctx context.Context, in *CallbackRequest, opts ...http.CallOption) (*CallbackResponse, error) <span class="cov0" title="0">{
        var out CallbackResponse
        pattern := "/v1/oauth/callback"
        path := binding.EncodeURL(pattern, in, true)
        opts = append(opts, http.Operation(OperationAccountCallback))
        opts = append(opts, http.PathTemplate(pattern))
        err := c.cc.Invoke(ctx, "GET", path, nil, &amp;out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;out, nil</span>
}

func (c *AccountHTTPClientImpl) CancelSyncTask(ctx context.Context, in *CancelSyncAccountRequest, opts ...http.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        var out emptypb.Empty
        pattern := "/v1/account"
        path := binding.EncodeURL(pattern, in, true)
        opts = append(opts, http.Operation(OperationAccountCancelSyncTask))
        opts = append(opts, http.PathTemplate(pattern))
        err := c.cc.Invoke(ctx, "DELETE", path, nil, &amp;out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;out, nil</span>
}

func (c *AccountHTTPClientImpl) CreateSyncAccount(ctx context.Context, in *CreateSyncAccountRequest, opts ...http.CallOption) (*CreateSyncAccountReply, error) <span class="cov0" title="0">{
        var out CreateSyncAccountReply
        pattern := "/v1/account"
        path := binding.EncodeURL(pattern, in, false)
        opts = append(opts, http.Operation(OperationAccountCreateSyncAccount))
        opts = append(opts, http.PathTemplate(pattern))
        err := c.cc.Invoke(ctx, "POST", path, in, &amp;out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;out, nil</span>
}

func (c *AccountHTTPClientImpl) GetAccessToken(ctx context.Context, in *GetAccessTokenRequest, opts ...http.CallOption) (*GetAccessTokenResponse, error) <span class="cov0" title="0">{
        var out GetAccessTokenResponse
        pattern := "/v1/oauth/userAccessToken"
        path := binding.EncodeURL(pattern, in, true)
        opts = append(opts, http.Operation(OperationAccountGetAccessToken))
        opts = append(opts, http.PathTemplate(pattern))
        err := c.cc.Invoke(ctx, "GET", path, nil, &amp;out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;out, nil</span>
}

func (c *AccountHTTPClientImpl) GetSyncAccount(ctx context.Context, in *GetSyncAccountRequest, opts ...http.CallOption) (*GetSyncAccountReply, error) <span class="cov0" title="0">{
        var out GetSyncAccountReply
        pattern := "/v1/account"
        path := binding.EncodeURL(pattern, in, true)
        opts = append(opts, http.Operation(OperationAccountGetSyncAccount))
        opts = append(opts, http.PathTemplate(pattern))
        err := c.cc.Invoke(ctx, "GET", path, nil, &amp;out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;out, nil</span>
}

func (c *AccountHTTPClientImpl) GetTask(ctx context.Context, in *GetTaskRequest, opts ...http.CallOption) (*GetTaskReply, error) <span class="cov0" title="0">{
        var out GetTaskReply
        pattern := "/v1/task"
        path := binding.EncodeURL(pattern, in, true)
        opts = append(opts, http.Operation(OperationAccountGetTask))
        opts = append(opts, http.PathTemplate(pattern))
        err := c.cc.Invoke(ctx, "GET", path, nil, &amp;out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;out, nil</span>
}

func (c *AccountHTTPClientImpl) GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...http.CallOption) (*GetUserInfoResponse, error) <span class="cov0" title="0">{
        var out GetUserInfoResponse
        pattern := "/v1/oauth/userinfo/me"
        path := binding.EncodeURL(pattern, in, true)
        opts = append(opts, http.Operation(OperationAccountGetUserInfo))
        opts = append(opts, http.PathTemplate(pattern))
        err := c.cc.Invoke(ctx, "GET", path, nil, &amp;out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;out, nil</span>
}

func (c *AccountHTTPClientImpl) UploadFile(ctx context.Context, in *UploadRequest, opts ...http.CallOption) (*UploadReply, error) <span class="cov0" title="0">{
        var out UploadReply
        pattern := "/v1/upload"
        path := binding.EncodeURL(pattern, in, false)
        opts = append(opts, http.Operation(OperationAccountUploadFile))
        opts = append(opts, http.PathTemplate(pattern))
        err := c.cc.Invoke(ctx, "POST", path, in, &amp;out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;out, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "flag"
        "fmt"

        // "fmt"
        "nancalacc/internal/conf"

        "github.com/go-kratos/kratos/v2/config"
        "github.com/go-kratos/kratos/v2/config/file"
)

var (
        bc conf.Bootstrap
)

func init() <span class="cov0" title="0">{
        var flagconf string
        flag.StringVar(&amp;flagconf, "conf", "../../configs", "config path, eg: -conf config.yaml")
        flag.Parse()

        c := config.New(
                config.WithSource(
                        file.NewSource(flagconf),
                ),
        )
        defer c.Close()

        if err := c.Load(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">if err := c.Scan(&amp;bc); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func main() <span class="cov0" title="0">{

        fmt.Println("start...")

        // CheckReadExcell()
        // ctx := context.Background()
        // fmt.Printf("bc: %+v\n", bc.Service)
        // 初始化 WpsSync
        // token, err := auth.NewAppAuthenticator(bc.Service).GetAccessToken(ctx)

        // if err != nil {
        //         panic(err)
        // }

        // fmt.Printf("token: %+v\n", token)

        //token := GetToken()
        //fmt.Println(token)
        // token := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NTM2MTU2MTgsImNvbXBfaWQiOiIxIiwiY2xpZW50X2lkIjoiY29tLmFjYy5hc3luYyIsInRrX3R5cGUiOiJhcHAiLCJzY29wZSI6Imtzby5hY2NvdW50c3luYy5zeW5jLGtzby5jb250YWN0LnJlYWQsa3NvLmNvbnRhY3QucmVhZHdyaXRlIiwiY29tcGFueV9pZCI6MSwiY2xpZW50X3ByaW5jaXBhbF9pZCI6IjczIiwiaXNfd3BzMzY1Ijp0cnVlfQ.ZOkiwnZ6f1uW45_sq5uT_ZW3dmA6yCXuKetMaUI7mCw"
        // 29290326581145992
        //CheckBatchGetDepartment(token)
        //CheckPostBatchUsersByExDepIds(token)
        // CheckPostBatchDepartmentsByExDepIds(token)
        //CheckGetUserByUserId(token)
        //CheckBatchPostUsers(token)

        // CheckPostBatchDepartmentsByExDepIds(token)
        // CheckUserLeaveOrg()
        // CheckPostBatchUsersByExDepIds(token)
        // CheckGetDepartmentRoot(token)
        //CheckBatchGetDepartment(token)
        // 033014104332101118010 test
        // CheckCallEcisaccountsync(token)
        // CheckGetDingtalkUserDetail()
        // "29290326581145992"
        // 03301410433273270
        //users, err := FindWpsUser(context.Background(), []string{"29290326581145992"})

        // if err != nil {
        //         panic(err)
        // }
        // for _, u := range users {
        //         fmt.Printf("FindWpsUser user: %v\n", *u)
        // }
        //CheckGetCompAllUsers()
        // CheckGetCompAllDepts()
        // FindAndDeleteUser()
        //FindAndDeleteDept("存在应用授权")
        // ctx := context.Background()
        // appAccessToken, err := auth.NewAppAuthenticator(bc.Service).GetAccessToken(ctx)
        // if err != nil {
        //         panic(err)
        // }
        //fmt.Printf("appAccessToken: %s\n", appAccessToken.AccessToken)
        // CheckPostCreateUser(appAccessToken.AccessToken)
        //CheckDeleteDept(appAccessToken.AccessToken)
        // authApp := auth.NewAppAuthenticator(bc.Service)

        // authCache := auth.NewAppCacheAuthenticator(authApp)

        // AesEncryptGcmByKey

        // mobile, err := cipherutil.DecryptValueWithEnvSalt("HyyjnqUeVqHoid9cprHMoPgkOAVu8farJigGpvOi+xm0aLO2ZytG")
        // fmt.Printf("mobile: %s, err:%v\n", mobile, err)
        // CheckGetCompAllUsers(appAccessToken.AccessToken)
        // CheckInternalGateWay(appAccessToken.AccessToken)

        // 81
        // CheckGetUsersSearch(appAccessToken.AccessToken)
        // authDingtalk := auth.NewDingTalkAuthenticator(bc.Service)
        // authCache := auth.NewDingtalkCacheAuthenticator(authDingtalk)

        // // authCache := auth.NewDingtalkCacheAuthenticator(authDingtalk, auth.WithKey[*auth.DingtalkCacheConfig]("custom_key"))

        // token, err := authCache.GetAccessToken(ctx)
        // if err != nil {
        //         panic(err)
        // }
        // dingtalkRepo := dingtalk.NewDingTalkRepo(bc.Service.Auth.Dingtalk, authCache, log.GetLogger())

        // depts, err := dingtalkRepo.FetchDepartments(ctx, token.AccessToken)
        // log.Infof("CreateSyncAccount.FetchDepartments: depts: %+v, err: %v", depts, err)
        // if err != nil {
        //         panic(err)
        // }
        // for _, dept := range depts {
        //         log.Infof("biz.CreateSyncAccount: dept: %+v", dept)
        // }
        // var deptIds []int64
        // for _, dept := range depts {
        //         deptIds = append(deptIds, dept.DeptID)
        // }

        // deptUsers, err := dingtalkRepo.FetchDepartmentUsers(ctx, token.AccessToken, deptIds)

        // log.Infof("CreateSyncAccount.FetchDepartmentUsers deptUsers: %v, err: %v", deptUsers, err)
        // for _, deptUser := range deptUsers {
        //         log.Infof("biz.CreateSyncAccount: deptUser: %+v", deptUser)
        // }
        // if err != nil {
        //         panic(err)
        // }
        // fmt.Println("success")
        // for i := 1; i &lt;= 3; i++ {
        //         token, err := authCache.GetAccessToken(ctx)
        //         fmt.Printf("GetAccessToken i:%d, token:%s, err:%v", i, token.AccessToken, err)
        //         // return
        // }

}</span>

// func CheckInternalGateWay(token string) {
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())
//         // 批量删除用户
//         res, err := wpsClient.GetObjUploadUrl(context.Background(), token, wps.GetObjUploadUrlRequest{})

//         fmt.Printf("res:%+v, err:%+v", res, err)

// }
// func CheckPostBatchDeleteUser(token string, userids []string) {
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())
//         // 批量删除用户
//         delUserRes, err := wpsClient.PostBatchDeleteUser(context.Background(), token, wps.PostBatchDeleteUserRequest{
//                 UserIDs: userids,
//         })
//         fmt.Printf("delUserRes:%v, err:%v", delUserRes, err)
// }
// func CheckPostCreateUser(appToken string) {
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())
//         createUserRes, err := wpsClient.PostCreateUser(context.Background(), appToken, wps.PostCreateUserRequest{
//                 ExUserID:  "test01_user",
//                 Email:     "test01@163.com",
//                 UserName:  "test01",
//                 LoginName: "13888888888",
//                 Phone:     "13888888888",
//                 DeptIDs:   []string{"1"},
//                 Source:    "sync",
//                 WorkPlace: "bj",
//         })

//         fmt.Printf("createUserRes:%v, err:%v", createUserRes, err)
// }

// // 创建的也存在授权
// func CheckPostCreateDept(appToken string) {
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())
//         parentID := "1"
//         createDeptRes, err := wpsClient.PostCreateDept(context.Background(), appToken, wps.PostCreateDeptRequest{
//                 ExDeptID: "test01",
//                 Name:     "test01_dep",
//                 ParentID: parentID,
//                 Source:   "sync",
//                 Order:    99,
//         })
//         fmt.Printf("createDeptRes:%v, err:%v", createDeptRes, err)
// }
// func CheckGetUsersSearch(appToken string) {

//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())
//         // 批量删除部门
//         // := []string{"6", "4"}
//         // deleDeptRes, err := wpsClient.GetUsersSearch(context.Background(), appToken, wps.GetUsersSearchRequest{
//         //         Keyword:  "18910953345",
//         //         PageSize: 10,
//         //         //Status:                   []string{"active", "notactive", "disabled"},
//         //         //SearchSource:             []string{"company_user", "external_contact", "enterprise_partner"},
//         //         //SearchFieldConfigEnabled: false,
//         // })
//         // fmt.Printf("deleDeptRes:%v, err:%v", deleDeptRes, err)

//         // 获取通讯录权限
//         contactPermissionRes, err := wpsClient.GetContactPermission(context.Background(), appToken, wps.GetContactPermissionRequest{
//                 Scopes: []string{"org"},
//         })
//         if err != nil {
//                 panic(err)
//         }
//         fmt.Printf("contactPermissionRes:%v, err:%v", contactPermissionRes, err)
// }

// func CheckDeleteDept(appToken string) {

//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())
//         // 批量删除部门
//         needDeldept := []string{"6000", "4000"}
//         deleDeptRes, err := wpsClient.PostBatchDeleteDept(context.Background(), appToken, wps.PostBatchDeleteDeptRequest{
//                 DeptIDs: needDeldept,
//         })
//         fmt.Printf("deleDeptRes:%v, err:%v", deleDeptRes, err)
// }
// func FindAndDeleteDept() {
//         ctx := context.Background()
//         appAccessToken, err := auth.NewAppAuthenticator(bc.Service).GetAccessToken(ctx)
//         if err != nil {
//                 panic(err)
//         }
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())
//         //查询根部门
//         rootDept, err := wpsClient.GetDepartmentRoot(ctx, appAccessToken.AccessToken, wps.GetDepartmentRootRequest{})
//         if err != nil {
//                 panic(err)
//         }
//         log.Infof("rootDept: %v", rootDept)

//         // 2. 查询部门下的子部门(要递归)
//         allDepts, err := wpsClient.GetDeptChildren(ctx, appAccessToken.AccessToken, wps.GetDeptChildrenRequest{
//                 DeptID:    rootDept.Data.ID,
//                 Recursive: true,
//                 PageSize:  50,
//                 WithTotal: true,
//         })
//         if err != nil {
//                 panic(err)
//         }
//         log.Infof("children: %v", allDepts)

//         //删除部门除了根部门
//         var alldeptes []string
//         for _, dept := range allDepts.Data.Items {
//                 if dept.ID == rootDept.Data.ID {
//                         continue
//                 }
//                 alldeptes = append(alldeptes, dept.ID)
//         }

//         needDeldept := alldeptes[:2]
//         fmt.Printf("deletedept: %v", needDeldept)
//         // 批量删除部门
//         deleDeptRes, err := wpsClient.PostBatchDeleteDept(ctx, appAccessToken.AccessToken, wps.PostBatchDeleteDeptRequest{
//                 DeptIDs: needDeldept,
//         })
//         fmt.Printf("deleDeptRes:%v, err:%v", deleDeptRes, err)
// }
// func FindAndDeleteUser() {
//         ctx := context.Background()
//         appAccessToken, err := auth.NewAppAuthenticator(bc.Service).GetAccessToken(ctx)
//         if err != nil {
//                 panic(err)
//         }
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         users, err := wpsClient.GetCompAllUsers(ctx, appAccessToken.AccessToken, wps.GetCompAllUsersRequest{
//                 Recursive: true,
//                 PageSize:  50,
//                 WithTotal: true,
//                 Status:    []string{"active", "notactive", "disabled"},
//         })
//         if err != nil {
//                 panic(err)
//         }

//         var deleteUser *dingtalk.DingtalkDeptUser
//         for _, user := range users.Data.Items {
//                 log.Infof("user: %+v", user)
//                 if user.Phone == "18910953345" {
//                         deleteUser = &amp;dingtalk.DingtalkDeptUser{
//                                 Userid: user.ExUserID,
//                                 Mobile: user.Phone,
//                                 Name:   user.UserName,
//                                 Email:  user.Email,
//                         }
//                 }
//                 for _, dep := range user.Depts {
//                         depId, _ := strconv.ParseInt(dep.DeptID, 10, 64)
//                         deleteUser.DeptIDList = append(deleteUser.DeptIDList, depId)
//                 }
//         }
//         syncDB, err := data.NewMysqlSyncDB(bc.Data, log.GetLogger())
//         if err != nil {
//                 panic(err)
//                 //return nil, nil, err
//         }
//         mainDB, err := data.NewMysqlDB(bc.Data, log.GetLogger())
//         if err != nil {
//                 panic(err)
//                 //return nil, nil, err
//         }
//         client, err := data.NewRedisClient(bc.Data, log.GetLogger())
//         if err != nil {
//                 panic(err)
//                 //return nil, nil, err
//         }
//         dataData, _, err := data.NewData(syncDB, mainDB, client, log.GetLogger())
//         if err != nil {
//                 panic(err)
//                 // return nil, nil, err
//         }

//         accounterRepo := data.NewAccounterRepo(bc.Service, dataData, log.GetLogger())
//         err = accounterRepo.SaveIncrementUsers(ctx, nil, []*dingtalk.DingtalkDeptUser{deleteUser}, nil)
//         if err != nil {
//                 panic(err)
//                 //return err
//         }

//         wpsSync := wps.NewWpsSync(bc.Service, log.GetLogger())
//         res, err := wpsSync.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
//                 ThirdCompanyId: "1",
//         })
//         fmt.Printf("res:%v, err:%v", res, err)
//         return
//         // var alluserids []string
//         // for _, u := range users.Data.Items {
//         //         fmt.Printf("FindWpsUser user: %v\n", u)
//         //         if u.ID == "1" {
//         //                 continue
//         //         }
//         //         alluserids = append(alluserids, u.ID)
//         // }
//         // deleteuser := alluserids[:2]
//         // fmt.Printf("deleteuser: %v", deleteuser)
//         // // 存在授权问题
//         // delRes, err := wpsClient.PostBatchDeleteUser(ctx, appAccessToken.AccessToken, wps.PostBatchDeleteUserRequest{
//         //         UserIDs: deleteuser,
//         // })
//         // fmt.Printf("delRes:%v, err:%v", delRes, err)

// }
// func CheckGetCompAllDepts() {
//         appAccessToken, err := auth.NewAppAuthenticator(bc.Service).GetAccessToken(context.Background())
//         if err != nil {
//                 panic(err)
//         }
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())
//         rootDept, err := wpsClient.GetDepartmentRoot(context.Background(), appAccessToken.AccessToken, wps.GetDepartmentRootRequest{})
//         if err != nil {
//                 panic(err)
//         }
//         log.Infof("rootDept: %v", rootDept)

//         allDepts, err := wpsClient.GetDeptChildren(context.Background(), appAccessToken.AccessToken, wps.GetDeptChildrenRequest{
//                 DeptID:    rootDept.Data.ID,
//                 Recursive: true,
//                 PageSize:  50,
//                 WithTotal: true,
//         })
//         if err != nil {
//                 panic(err)
//         }

//         for _, d := range allDepts.Data.Items {
//                 fmt.Printf("CheckGetCompAllDepts dept: %v\n", d)
//         }
// }
// func CheckGetCompAllUsers(token string) {

//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         users, err := wpsClient.GetCompAllUsers(context.Background(), token, wps.GetCompAllUsersRequest{
//                 Recursive: true,
//                 PageSize:  50,
//                 WithTotal: true,
//                 Status:    []string{"active", "notactive", "disabled"},
//         })
//         if err != nil {
//                 panic(err)
//         }
//         for _, u := range users.Data.Items {
//                 fmt.Printf("FindWpsUser user: %+v\n", u)
//         }

// }
// func FindWpsUser(ctx context.Context, userids []string) ([]*dingtalk.DingtalkDeptUser, error) {
//         fmt.Printf("FindWpsUser userids: %v\n", userids)
//         var users []*dingtalk.DingtalkDeptUser

//         appAccessToken, err := auth.NewAppAuthenticator(bc.Service).GetAccessToken(context.Background())
//         if err != nil {
//                 return nil, err
//         }
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         for _, userId := range userids {
//                 wpsUserInfo, err := wpsClient.PostBatchUsersByExDepIds(ctx, appAccessToken.AccessToken, wps.PostBatchUsersByExDepIdsRequest{
//                         ExUserIDs: []string{userId},
//                         Status:    []string{wps.UserStatusActive, wps.UserStatusNoActive, wps.UserStatusDisabled},
//                 })
//                 fmt.Printf("FindWpsUser wpsUserInfo: %v, err: %v\n", wpsUserInfo, err)
//                 if err != nil {
//                         return nil, err
//                 }

//                 if len(wpsUserInfo.Data.Items) == 1 {
//                         fmt.Printf("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;wpsUserInfo: %v\n", wpsUserInfo)
//                         wpsUserid := wpsUserInfo.Data.Items[0].ID

//                         wpsDeptInfo, err := wpsClient.GetUserDeptsByUserId(ctx, appAccessToken.AccessToken, wps.GetUserDeptsByUserIdRequest{
//                                 UserID: wpsUserid,
//                         })
//                         if err != nil {
//                                 return nil, err
//                         }
//                         if len(wpsDeptInfo.Data.Items) &gt; 0 {
//                                 for _, item := range wpsDeptInfo.Data.Items {

//                                         //if _, ok := relationsMap[wpsUserid+item.ID]; !ok {
//                                         user := &amp;dingtalk.DingtalkDeptUser{
//                                                 Userid: userId,
//                                         }
//                                         deptId, err := strconv.ParseInt(item.ExDeptID, 10, 64)
//                                         if err != nil {
//                                                 return nil, err
//                                         }
//                                         user.DeptIDList = append(user.DeptIDList, deptId)
//                                         users = append(users, user)
//                                         //}
//                                 }
//                         }

//                 }
//         }
//         return users, nil
// }

// func CheckGetDingtalkUserDetail() {
//         confService := bc.GetService()
//         auth := auth.NewDingtalkCacheAuthenticator(auth.NewDingTalkAuthenticator(confService))
//         dingtalkRepo := dingtalk.NewDingTalkRepo(confService.Auth.Dingtalk, auth, log.GetLogger())
//         ctx := context.Background()
//         // accessToken, err := dingtalkRepo.GetAccessToken(ctx, "code")
//         // log.Infof("UserAddOrg.GetAccessToken accessToken: %v, err: %v", accessToken, err)
//         // if err != nil {
//         //         panic(err)
//         // }
//         accessToken := "2a99752c4fd9317f81d4a20c0f1d7c7e"
//         //user, err := dingtalkRepo.FetchUserDetail(ctx, accessToken, []string{"03301410433273270"})

//         depts, _ := dingtalkRepo.FetchDeptDetails(ctx, accessToken, []int64{1002216804})
//         fmt.Println()
//         for i, dept := range depts {
//                 fmt.Printf("部门 %d: %+v\n", i, *dept)
//         }
// }
// func CheckReadExcell() {
//         f, err := excelize.OpenFile("Book1.xlsx")
//         if err != nil {
//                 fmt.Println(err)
//                 return
//         }
//         defer func() {
//                 // Close the spreadsheet.
//                 if err := f.Close(); err != nil {
//                         fmt.Println(err)
//                 }
//         }()
//         // Get value from cell by given worksheet name and cell reference.
//         cell, err := f.GetCellValue("Sheet1", "B2")
//         if err != nil {
//                 fmt.Println(err)
//                 return
//         }
//         fmt.Println(cell)
//         // Get all the rows in the Sheet1.
//         rows, err := f.GetRows("Sheet1")
//         if err != nil {
//                 fmt.Println(err)
//                 return
//         }
//         for _, row := range rows {
//                 for _, colCell := range row {
//                         fmt.Print(colCell, "\t")
//                 }
//                 fmt.Println()
//         }
// }
// func CheckGetUserByUserId(token string) {
//         ctx := context.Background()
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         // 调用 Wps 接口
//         res, err := wpsClient.GetUserByUserId(ctx, token, wps.GetUserByUserIdRequest{
//                 UserID: "81",
//         })

//         fmt.Printf("CheckGetUserByUserId res: %+v, err:%+v\n", res, err)
// }
// func CheckUserLeaveOrg() {

//         ctx := context.Background()
//         nancalDB, _ := data.NewMysqlDB(bc.Data, log.GetLogger())

//         syncDB, _ := data.NewMysqlSyncDB(bc.Data, log.GetLogger())

//         client, _ := data.NewRedisClient(bc.Data, log.GetLogger())

//         dataData, _, err := data.NewData(syncDB, nancalDB, client, log.GetLogger())
//         if err != nil {
//                 panic(err)
//         }
//         confService := bc.GetService()
//         accounterRepo := data.NewAccounterRepo(confService, dataData, log.GetLogger())
//         authDingtalk := auth.NewDingtalkCacheAuthenticator(auth.NewDingTalkAuthenticator(confService))
//         dingtalkDingtalk := dingtalk.NewDingTalkRepo(service_Auth_Dingtalk, authDingtalk, log.GetLogger())
//         authenticator := auth.NewAppAuthenticator(confService)
//         wpsSync := wps.NewWpsSync(confService, log.GetLogger())
//         wpsWps := wps.NewWps(confService, log.GetLogger())
//         service_Business := conf.ProvideBusinessConfig(confService)
//         accounterIncreUsecase := biz.NewAccounterIncreUsecase(accounterRepo, dingtalkDingtalk, authenticator, wpsSync, wpsWps, service_Business, log.GetLogger())

//         // deptId
//         // org_dept_create
//         // org_dept_modify
//         // org_dept_remove
//         // userId
//         // user_add_org
//         // user_modify_org
//         // user_leave_org
//         // map[string]interface{"userId": []string{"033014104332101118010"}
//         event := &amp;clientV2.GenericOpenDingTalkEvent{
//                 EventId:           "111",
//                 EventBornTime:     "111",
//                 EventCorpId:       "111",
//                 EventType:         "user_leave_org",
//                 EventUnifiedAppId: "111",
//                 Data:              make(map[string]interface{}, 0),
//         }
//         event.Data["userId"] = []string{"033014104332101118010"}

//         err = accounterIncreUsecase.UserLeaveOrg(ctx, event)

//         fmt.Printf("err:%+v", err)
// }
// func CheckUserAddOrg(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) {

// }

// func GetToken() string {
//         // fmt.Printf("bc.Service: %v", bc.Service)
//         token, err := auth.NewAppAuthenticator(bc.Service).GetAccessToken(context.Background())

//         if err != nil {
//                 panic(err)
//         }

//         //fmt.Printf("token: %+v\n", token)
//         return token.AccessToken
// }
// func CheckBatchPostUsers(token string) {
//         ctx := context.Background()
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         // 调用 Wps 接口
//         res, err := wpsClient.BatchPostUsers(ctx, token, wps.BatchPostUsersRequest{
//                 UserIDs:  []string{"81", "2"},
//                 Status:   []string{wps.UserStatusActive, wps.UserStatusNoActive, wps.UserStatusDisabled},
//                 WithDept: true,
//         })

//         fmt.Printf("CheckBatchPostUsers res: %+v, err:%+v\n", res, err)
// }
// func CheckPostBatchUsersByExDepIds(token string) {
//         ctx := context.Background()
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         // 调用 Wps 接口
//         res, err := wpsClient.PostBatchUsersByExDepIds(ctx, token, wps.PostBatchUsersByExDepIdsRequest{
//                 ExUserIDs: []string{"033014104332101118010", "18910953345"},
//                 Status:    []string{wps.UserStatusActive, wps.UserStatusNoActive, wps.UserStatusDisabled},
//         })

//         fmt.Printf("CheckPostBatchUsersByExDepIds res: %+v, err:%+v\n", res, err)
// }

// func CheckPostBatchDepartmentsByExDepIds(token string) {
//         ctx := context.Background()
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         // 调用 Wps 接口
//         res, err := wpsClient.PostBatchDepartmentsByExDepIds(ctx, token, wps.PostBatchDepartmentsByExDepIdsRequest{
//                 ExDeptIDs: []string{"1002216804"},
//         })

//         fmt.Printf("CheckPostBatchDepartmentsByExDepIds res: %+v, err:%+v\n", res, err)
// }
// func CheckGetDepartmentRoot(token string) {
//         ctx := context.Background()
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         // 调用 Wps 接口
//         res, err := wpsClient.GetDepartmentRoot(ctx, token, wps.GetDepartmentRootRequest{})

//         fmt.Printf("CheckGetDepartmentRoot res: %+v, err:%+v\n", res, err)

// }
// func CheckBatchGetDepartment(token string) {
//         ctx := context.Background()
//         wpsClient := wps.NewWps(bc.Service, log.GetLogger())

//         // 调用 Wps 接口
//         res, err := wpsClient.BatchPostDepartments(ctx, token, wps.BatchPostDepartmentsRequest{
//                 DeptIDs: []string{"201", "1", "33"},
//         })
//         fmt.Printf("CheckBatchGetDepartment res: %+v, err:%+v\n", res, err)

// }
// func CheckPostEcisaccountsync(token string) {
//         ctx := context.Background()
//         wpsSync := wps.NewWpsSync(bc.Service, log.GetLogger())
//         res, err := wpsSync.PostEcisaccountsyncIncrement(ctx, token, &amp;wps.EcisaccountsyncIncrementRequest{
//                 ThirdCompanyId: "1",
//         })

//         fmt.Printf("PostEcisaccountsyncIncrement res: %+v, err:%+v\n", res, err)
//         res1, err := wpsSync.PostEcisaccountsyncAll(ctx, token, &amp;wps.EcisaccountsyncAllRequest{
//                 ThirdCompanyId: "1",
//                 TaskId:         time.Now().Add(time.Duration(1) * time.Second).Format("20060102150405"),
//         })

//         fmt.Printf("PostEcisaccountsyncAll res: %+v, err:%+v\n", res1, err)
// }
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "flag"
        "os"

        "nancalacc/internal/conf"
        "nancalacc/internal/otel"
        "nancalacc/internal/service"
        "nancalacc/internal/task"

        "github.com/go-kratos/kratos/v2"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/go-kratos/kratos/v2/transport/grpc"
        "github.com/go-kratos/kratos/v2/transport/http"

        _ "go.uber.org/automaxprocs"
)

// go build -ldflags "-X main.Version=x.y.z"
var (
        // Name is the name of the compiled software.
        Name string
        // Version is the version of the compiled software.
        Version string

        Env string
        // flagconf is the config flag.
        flagconf string

        id, _ = os.Hostname()
)

func init() <span class="cov0" title="0">{
        flag.StringVar(&amp;flagconf, "conf", "../../configs", "config path, eg: -conf config.yaml")
}</span>

// newApp 创建应用实例
func newApp(integration *otel.Integration, gs *grpc.Server, hs *http.Server, cronService *task.CronService, eventService *service.DingTalkEventService) *kratos.App <span class="cov0" title="0">{
        // 从 integration 获取 Kratos 兼容的 logger
        logger := integration.CreateLogger()

        return kratos.New(
                kratos.ID(id),
                kratos.Name(Name),
                kratos.Version(Version),
                kratos.Metadata(map[string]string{}),
                kratos.Logger(logger),
                kratos.Server(
                        gs,
                        hs,
                ),
                kratos.BeforeStart(func(ctx context.Context) error </span><span class="cov0" title="0">{
                        logger.Log(log.LevelInfo, "msg", "starting application with OpenTelemetry")
                        cronService.Start()
                        return nil
                }</span>),
                kratos.AfterStop(func(ctx context.Context) error <span class="cov0" title="0">{
                        logger.Log(log.LevelInfo, "msg", "stopping application with OpenTelemetry")
                        cronService.Stop()
                        return nil
                }</span>),
                kratos.BeforeStart(func(ctx context.Context) error <span class="cov0" title="0">{
                        eventService.Start()
                        return nil
                }</span>),
                kratos.AfterStop(func(ctx context.Context) error <span class="cov0" title="0">{
                        eventService.Stop()
                        return nil
                }</span>),
        )
}

func main() <span class="cov0" title="0">{
        flag.Parse()

        // 加载配置
        bc, err := conf.Load(flagconf)
        if err != nil </span><span class="cov0" title="0">{
                panic("failed to load config: " + err.Error())</span>
        }

        // 初始化OpenTelemetry
        <span class="cov0" title="0">otelIntegration := initOpenTelemetry(bc)
        defer otelIntegration.Shutdown(context.Background())

        // 创建日志器
        otelIntegration.CreateLogger().Log(log.LevelInfo,
                "msg", "app start",
                "company:", bc.GetApp().GetCompanyId(),
                "third company:", bc.GetApp().GetThirdCompanyId(),
                "platform ids:", bc.GetApp().GetPlatformIds())
        // 创建应用
        app, cleanup, err := wireApp(bc.Server, bc.Data, bc.Otel, otelIntegration)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer cleanup()

        // 启动应用
        if err := app.Run(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// initOpenTelemetry 初始化OpenTelemetry
func initOpenTelemetry(bc *conf.Bootstrap) *otel.Integration <span class="cov0" title="0">{
        // 创建配置适配器
        adapter := otel.NewConfigAdapter()
        config := adapter.FromBootstrap(bc)

        // 创建集成器
        integration := otel.NewIntegration(config)

        // 初始化
        if err := integration.Init(context.Background()); err != nil </span><span class="cov0" title="0">{
                panic("failed to init OpenTelemetry: " + err.Error())</span>
        }

        <span class="cov0" title="0">return integration</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
        "github.com/go-kratos/kratos/v2"
        "github.com/go-kratos/kratos/v2/log"
        "nancalacc/internal/biz"
        "nancalacc/internal/conf"
        "nancalacc/internal/data"
        "nancalacc/internal/dingtalk"
        "nancalacc/internal/otel"
        "nancalacc/internal/server"
        "nancalacc/internal/service"
        "nancalacc/internal/task"
        "nancalacc/internal/wps"
)

import (
        _ "go.uber.org/automaxprocs"
)

// Injectors from wire.go:

// wireApp init kratos application with OpenTelemetry integration.
func wireApp(confServer *conf.Server, confData *conf.Data, openTelemetry *conf.OpenTelemetry, integration *otel.Integration) (*kratos.App, func(), error) <span class="cov0" title="0">{
        logger := provideLogger(integration)
        databaseFactory := data.NewDatabaseFactory(confData, logger, openTelemetry)
        client, err := data.NewRedisClient(confData, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">dataData, cleanup, err := data.NewDataWithFactory(databaseFactory, client, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">accounterRepo := data.NewAccounterRepo(dataData, logger)
        dingtalkDingtalk := dingtalk.NewDingTalkRepo(logger)
        wpsWps := wps.NewWps(logger)
        cacheService := data.NewLocalCacheService(logger)
        accounterUsecase := biz.NewAccounterUsecase(accounterRepo, dingtalkDingtalk, wpsWps, cacheService, logger)
        oauth2Usecase := biz.NewOauth2Usecase(dingtalkDingtalk, logger)
        fullSyncUsecase := biz.NewFullSyncUsecase(accounterRepo, dingtalkDingtalk, wpsWps, cacheService, logger)
        accountService := service.NewAccountService(accounterUsecase, oauth2Usecase, fullSyncUsecase, logger)
        grpcServer := server.NewGRPCServer(confServer, accountService, integration)
        httpServer := server.NewHTTPServer(confServer, accountService, integration, openTelemetry)
        cronService := task.NewCronServiceWithJobs(fullSyncUsecase, dataData, logger)
        incrementalSyncUsecase := biz.NewIncrementalSyncUsecase(accounterRepo, dingtalkDingtalk, wpsWps, logger)
        dingTalkEventService := service.NewDingTalkEventService(incrementalSyncUsecase, logger)
        app := newApp(integration, grpcServer, httpServer, cronService, dingTalkEventService)
        return app, func() </span><span class="cov0" title="0">{
                cleanup()
        }</span>, nil
}

// wire.go:

// provideLogger creates a logger from the integration
func provideLogger(integration *otel.Integration) log.Logger <span class="cov0" title="0">{
        return integration.CreateLogger()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package auth

import (
        "time"

        gocache "github.com/patrickmn/go-cache"
)

// Cache 缓存接口
type Cache interface {
        Get(key string) (interface{}, bool)
        Set(key string, value interface{}, ttl time.Duration)
        Delete(key string)
}

// LocalCache 本地缓存实现
type LocalCache struct {
        cache *gocache.Cache
}

// NewLocalCache 创建新的本地缓存实例
func NewLocalCache() Cache <span class="cov0" title="0">{
        // 默认清理间隔为10分钟，默认过期时间为1小时
        return &amp;LocalCache{
                cache: gocache.New(1*time.Hour, 10*time.Minute),
        }
}</span>

func (lc *LocalCache) Get(key string) (interface{}, bool) <span class="cov0" title="0">{
        return lc.cache.Get(key)
}</span>

func (lc *LocalCache) Set(key string, value interface{}, ttl time.Duration) <span class="cov0" title="0">{
        lc.cache.Set(key, value, ttl)
}</span>

func (lc *LocalCache) Delete(key string) <span class="cov0" title="0">{
        lc.cache.Delete(key)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package auth

import (
        "crypto/sha256"
        "fmt"
        "net/http"
        "time"
)

func MakeSECSecret(clientId, clientSecret string, t time.Time) string <span class="cov0" title="0">{
        utc := t.Format(http.TimeFormat)
        return fmt.Sprintf("SEC %x;%s",
                sha256.Sum256([]byte(fmt.Sprintf("%s:%s:%s", clientId, clientSecret, utc))), utc)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package auth

import (
        "context"
        "fmt"
        "nancalacc/internal/conf"
        "time"

        openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
        dingtalkoauth2_1_0 "github.com/alibabacloud-go/dingtalk/oauth2_1_0"
        util "github.com/alibabacloud-go/tea-utils/v2/service"
        "github.com/alibabacloud-go/tea/tea"
)

const (
        DingtalkAuthType = "dingtalk"
)

type DingTalkAuthenticator interface {
        Authenticator
}

type DingTalkAuth struct {
        AppKey    string
        AppSecret string
        Endpoint  string
        //Timeout     string
        dingtalkCli *dingtalkoauth2_1_0.Client
        cache       Cache
}

func NewDingTalkAuthenticator() DingTalkAuthenticator <span class="cov0" title="0">{

        cfg := conf.Get().GetAuth().GetDingtalk()
        config := &amp;openapi.Config{
                Protocol: tea.String("https"),
                RegionId: tea.String("central"),
        }
        client, err := dingtalkoauth2_1_0.NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("NewClient err: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;DingTalkAuth{
                Endpoint:    cfg.Endpoint,
                AppKey:      cfg.AppKey,
                AppSecret:   cfg.AppSecret,
                dingtalkCli: client,
                cache:       NewLocalCache(),
        }</span>
}

func (r *DingTalkAuth) GetAccessToken(ctx context.Context) (*AccessTokenResp, error) <span class="cov0" title="0">{
        // 尝试从缓存获取
        cacheKey := fmt.Sprintf("dingtalk_token_%s", r.AppKey)
        if cached, found := r.cache.Get(cacheKey); found </span><span class="cov0" title="0">{
                if token, ok := cached.(*AccessTokenResp); ok </span><span class="cov0" title="0">{
                        return token, nil
                }</span>
        }

        // 缓存中没有，从API获取
        <span class="cov0" title="0">token, err := r.getAccessTokenFromAPI(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 缓存token，提前5分钟过期
        <span class="cov0" title="0">cacheTTL := time.Duration(token.ExpiresIn-300) * time.Second
        if cacheTTL &gt; 0 </span><span class="cov0" title="0">{
                r.cache.Set(cacheKey, token, cacheTTL)
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}

func (r *DingTalkAuth) getAccessTokenFromAPI(ctx context.Context) (*AccessTokenResp, error) <span class="cov0" title="0">{
        request := &amp;dingtalkoauth2_1_0.GetAccessTokenRequest{
                AppKey:    tea.String(r.AppKey),
                AppSecret: tea.String(r.AppSecret),
        }

        var res *AccessTokenResp
        var accessToken dingtalkoauth2_1_0.GetAccessTokenResponseBody

        tryErr := func() error </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := tea.Recover(recover()); r != nil </span><span class="cov0" title="0">{
                                err := r
                                fmt.Printf("恢复的错误: %v\n", err)
                        }</span>
                }()

                <span class="cov0" title="0">response, err := r.dingtalkCli.GetAccessToken(request)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">accessToken = *response.Body
                return nil</span>
        }()

        <span class="cov0" title="0">if tryErr != nil </span><span class="cov0" title="0">{
                // 处理错误
                var sdkErr = &amp;tea.SDKError{}
                if _t, ok := tryErr.(*tea.SDKError); ok </span><span class="cov0" title="0">{
                        sdkErr = _t
                }</span> else<span class="cov0" title="0"> {
                        sdkErr.Message = tea.String(tryErr.Error())
                }</span>

                <span class="cov0" title="0">if !tea.BoolValue(util.Empty(sdkErr.Code)) &amp;&amp; !tea.BoolValue(util.Empty(sdkErr.Message)) </span><span class="cov0" title="0">{
                        return res, fmt.Errorf("获取access_token失败: [%s] %s", *sdkErr.Code, *sdkErr.Message)
                }</span>
                <span class="cov0" title="0">return res, fmt.Errorf("获取access_token失败: %s", *sdkErr.Message)</span>
        }

        <span class="cov0" title="0">return &amp;AccessTokenResp{
                AccessToken: *accessToken.AccessToken,
                ExpiresIn:   int(*accessToken.ExpireIn),
        }, nil</span>
}

// InvalidateCache 清除缓存
func (r *DingTalkAuth) InvalidateCache() <span class="cov0" title="0">{
        cacheKey := fmt.Sprintf("dingtalk_token_%s", r.AppKey)
        r.cache.Delete(cacheKey)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package auth

import (
        "context"
        "encoding/json"
        "fmt"
        "nancalacc/internal/conf"
        "nancalacc/pkg/httputil"
        stdurl "net/url"
        "strings"
        "time"
)

const (
        AppAuthType = "app"
)

type WpsAppAuthenticator interface {
        Authenticator
}

type WpsAppAuth struct {
        clientId     string
        clientSecret string
        url          string
        cache        Cache
}

const (
        AppAuthPath = "/openapi/oauth2/token"
        grantType   = "client_credentials"
)

func NewWpsAppAuthenticator() WpsAppAuthenticator <span class="cov0" title="0">{
        cfg := conf.Get().GetAuth().GetWpsapp()
        return &amp;WpsAppAuth{
                clientId:     cfg.ClientId,
                clientSecret: cfg.ClientSecret,
                url:          cfg.AuthUrl,
                cache:        NewLocalCache(),
        }
}</span>

func (a *WpsAppAuth) GetAccessToken(ctx context.Context) (*AccessTokenResp, error) <span class="cov0" title="0">{
        // 尝试从缓存获取
        cacheKey := fmt.Sprintf("wps_token_%s", a.clientId)
        if cached, found := a.cache.Get(cacheKey); found </span><span class="cov0" title="0">{
                if token, ok := cached.(*AccessTokenResp); ok </span><span class="cov0" title="0">{
                        return token, nil
                }</span>
        }

        // 缓存中没有，从API获取
        <span class="cov0" title="0">token, err := a.getAccessTokenFromAPI(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 缓存token，提前5分钟过期
        <span class="cov0" title="0">cacheTTL := time.Duration(token.ExpiresIn-300) * time.Second
        if cacheTTL &gt; 0 </span><span class="cov0" title="0">{
                a.cache.Set(cacheKey, token, cacheTTL)
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}

func (a *WpsAppAuth) getAccessTokenFromAPI(ctx context.Context) (*AccessTokenResp, error) <span class="cov0" title="0">{
        clientId := a.clientId
        clientSecret := a.clientSecret
        url := a.url

        _, err := stdurl.Parse(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid URL: %v", err)
        }</span>

        <span class="cov0" title="0">if !strings.Contains(url, "https") &amp;&amp; !strings.Contains(url, "http") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("domain must be https or http")
        }</span>
        <span class="cov0" title="0">if strings.Contains(url, "https") </span><span class="cov0" title="0">{
                clientSecret = MakeSECSecret(clientId, clientSecret, time.Now())
        }</span>

        <span class="cov0" title="0">uri := fmt.Sprintf("%s%s", url, AppAuthPath)

        dataStr := fmt.Sprintf(`grant_type=%s&amp;client_id=%s&amp;client_secret=%s`, grantType, clientId, clientSecret)
        data := []byte(dataStr)
        bs, err := httputil.Post(uri, data, 5*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var resp *AccessTokenResp
        err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

// InvalidateCache 清除缓存
func (a *WpsAppAuth) InvalidateCache() <span class="cov0" title="0">{
        cacheKey := fmt.Sprintf("wps_token_%s", a.clientId)
        a.cache.Delete(cacheKey)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package biz

import (
        "context"
        v1 "nancalacc/api/account/v1"
        "nancalacc/internal/auth"
        "nancalacc/internal/dingtalk"
        "nancalacc/internal/wps"

        //"github.com/go-kratos/kratos/v2/errors"
        "github.com/go-kratos/kratos/v2/log"
)

// GreeterUsecase is a Greeter usecase.
type AccounterUsecase struct {
        repo         AccounterRepo
        dingTalkRepo dingtalk.Dingtalk
        appAuth      auth.Authenticator
        wps          wps.Wps
        localCache   CacheService
        log          log.Logger
}

var (
        prefix = "nancalacc:cache:"
)

// NewGreeterUsecase new a Greeter usecase.
func NewAccounterUsecase(repo AccounterRepo, dingTalkRepo dingtalk.Dingtalk, wps wps.Wps, cache CacheService, logger log.Logger) *AccounterUsecase <span class="cov0" title="0">{
        appAuth := auth.NewWpsAppAuthenticator()
        return &amp;AccounterUsecase{repo: repo, dingTalkRepo: dingTalkRepo, appAuth: appAuth, wps: wps, localCache: cache, log: logger}
}</span>

func (uc *AccounterUsecase) CreateTask(ctx context.Context, taskName string) (int, error) <span class="cov0" title="0">{
        uc.log.Log(log.LevelInfo, "msg", "CreateTask", "taskName", taskName)
        return uc.repo.CreateTask(ctx, taskName)

}</span>
func (uc *AccounterUsecase) GetTask(ctx context.Context, taskName string) (*v1.GetTaskReply_Task, error) <span class="cov0" title="0">{

        return &amp;v1.GetTaskReply_Task{}, nil

}</span>
func (uc *AccounterUsecase) UpdateTask(ctx context.Context, taskName, status string) error <span class="cov0" title="0">{
        uc.log.Log(log.LevelInfo, "msg", "UpdateTask", "taskId", taskName, "status", status)
        return uc.repo.UpdateTask(ctx, taskName, status)

}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package biz

import (
        "context"
        "encoding/json"
        "fmt"
        v1 "nancalacc/api/account/v1"
        "nancalacc/internal/data/models"
        "nancalacc/internal/wps"
        "os"

        "github.com/go-kratos/kratos/v2/log"
)

func (uc *AccounterUsecase) CreateSyncTask(ctx context.Context, req *v1.CreateSyncAccountRequest) (*v1.CreateSyncAccountReply, error) <span class="cov0" title="0">{

        // wpsAllDept, err := uc.GetAllWpsDept(ctx)
        // if err != nil {
        //         return nil, err
        // }
        wpsAllDeptJson, err := os.ReadFile("data/wpsAllDept.json")
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "CreateSyncTask.os.OpenFile", "err", err)
        }</span>
        <span class="cov0" title="0">var wpsAllDept []wps.DeptItem
        err = json.Unmarshal(wpsAllDeptJson, &amp;wpsAllDept)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "CreateSyncTask.json.Unmarshal", "err", err)
        }</span>

        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "CreateSyncTask", "wpsAllDept len", len(wpsAllDept))

        wpsAlluserJson, err := os.ReadFile("data/wpsAlluser.json")
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "CreateSyncTask.os.OpenFile", "err", err)
        }</span>
        <span class="cov0" title="0">var wpsAlluser []wps.UserItem
        err = json.Unmarshal(wpsAlluserJson, &amp;wpsAlluser)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "CreateSyncTask.json.Unmarshal", "err", err)
        }</span>

        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "CreateSyncTask", "wpsAlluser len", len(wpsAlluser))

        taskName := "20250818130326"
        thirdCompanyId := "1"
        platformId := "1"
        allTableDept, err := uc.repo.BatchGetDepts(ctx, taskName, thirdCompanyId, platformId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">allTableUser, err := uc.repo.BatchGetUsers(ctx, taskName, thirdCompanyId, platformId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">allTableDeptuser, err := uc.repo.BatchGetDeptUsers(ctx, taskName, thirdCompanyId, platformId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "CreateSyncTask", "allTableDept len", len(allTableDept), "allTableUser len", len(allTableUser), "allTableDeptuser len", len(allTableDeptuser))

        wpsAllDeptMap := make(map[string]*wps.DeptItem, len(wpsAllDept))
        for _, item := range wpsAllDept </span><span class="cov0" title="0">{
                wpsAllDeptMap[item.ExDeptID] = &amp;item
        }</span>

        <span class="cov0" title="0">var addDept, updDept, delDept []*wps.DeptItem
        for _, dept := range allTableDept </span><span class="cov0" title="0">{
                if v, ok := wpsAllDeptMap[dept.Did]; ok </span><span class="cov0" title="0">{
                        itemDept := v
                        itemDept.Name = dept.Name
                        // itemDept.ParentID = dept.ParentID
                        itemDept.Order = dept.Order
                        itemDept.Source = dept.Source

                        //存在加一条更新的,更新字段后

                        updDept = append(updDept, itemDept)
                        //dept.Name = v.Name
                        delete(wpsAllDeptMap, dept.Did)
                }</span> else<span class="cov0" title="0"> {
                        //这几个参数有可能不对
                        newDept := wps.DeptItem{
                                ExDeptID: dept.Did,
                                Name:     dept.Name,
                                Order:    dept.Order,
                                Source:   dept.Source,
                        }
                        addDept = append(addDept, &amp;newDept)
                }</span>
        }
        <span class="cov0" title="0">if len(wpsAllDeptMap) &gt; 0 </span><span class="cov0" title="0">{
                for _, v := range wpsAllDeptMap </span><span class="cov0" title="0">{
                        delDept = append(delDept, v)
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("addDept: %v, updDept: %v, delDept: %v", addDept, updDept, delDept)

        return nil, nil
        // for _, user := range allTableUser {

        wpsAlluserMap := make(map[string]*wps.UserItem, len(wpsAlluser))
        for _, item := range wpsAlluser </span><span class="cov0" title="0">{
                wpsAlluserMap[item.ExUserID] = &amp;item
        }</span>

        // wpsAllDeptJson, err := json.Marshal(wpsAllDept)
        // if err != nil {
        //         uc.log.Log(log.LevelError, "msg", "CreateSyncTask.json.Marshal", "err", err)
        // }

        // f, err := os.OpenFile("data/wpsAllDept.json", os.O_CREATE|os.O_WRONLY, 0644)
        // if err != nil {
        //         uc.log.Log(log.LevelError, "msg", "CreateSyncTask.os.OpenFile", "err", err)
        // }
        // defer f.Close()
        // f.Write(wpsAllDeptJson)
        // uc.log.Log(log.LevelInfo, "msg", "CreateSyncTask", "wpsAllDeptJson", string(wpsAllDeptJson))

        // wpsAlluser, err := uc.GetAllWpsUser(ctx)

        // uc.log.Log(log.LevelInfo, "msg", "CreateSyncTask", "wpsAlluser len", len(wpsAlluser))
        // if err != nil {
        //         return nil, err
        // }
        // wpsAlluserJson, err := json.Marshal(wpsAlluser)
        // if err != nil {
        //         uc.log.Log(log.LevelError, "msg", "CreateSyncTask.json.Marshal", "err", err)
        // }
        // f, err := os.OpenFile("data/wpsAlluser.json", os.O_CREATE|os.O_WRONLY, 0644)
        // if err != nil {
        //         uc.log.Log(log.LevelError, "msg", "CreateSyncTask.os.OpenFile", "err", err)
        // }
        // defer f.Close()
        // f.Write(wpsAlluserJson)
        // uc.log.Log(log.LevelInfo, "msg", "CreateSyncTask", "wpsAlluserJson", string(wpsAlluserJson))

        <span class="cov0" title="0">return nil, nil

        allTableDeptMap := make(map[string]*models.TbLasDepartment, len(allTableDept))
        allTableUserMap := make(map[string]*models.TbLasUser, len(allTableUser))
        allTableDeptuserMap := make(map[string][]*models.TbLasDepartmentUser, 0)
        for _, item := range allTableDept </span><span class="cov0" title="0">{
                allTableDeptMap[item.Did] = item
        }</span>
        <span class="cov0" title="0">for _, item := range allTableUser </span><span class="cov0" title="0">{
                allTableUserMap[item.Uid] = item
        }</span>
        <span class="cov0" title="0">for _, item := range allTableDeptuser </span><span class="cov0" title="0">{
                allTableDeptuserMap[item.Uid] = append(allTableDeptuserMap[item.Uid], item)
        }</span>

        <span class="cov0" title="0">var addp, updp, delp []*models.TbLasDepartment
        // for _, item := range wpsAllDept {
        //         if v, ok := allTableDeptMap[item.ExDeptID]; ok {
        //                 updp = append(updp, v)
        //                 delete(allTableDeptMap, item.ExDeptID)
        //         } else {
        //                 addp = append(addp, v)
        //         }
        // }
        if len(allTableDeptMap) &gt; 0 </span><span class="cov0" title="0">{
                for _, v := range allTableDeptMap </span><span class="cov0" title="0">{
                        delp = append(delp, v)
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("addp: %v, updp: %v, del: %v", addp, updp, delp)

        var addu, updu, delu []wps.UserItem
        for _, item := range wpsAlluser </span><span class="cov0" title="0">{
                if v, ok := allTableUserMap[item.ExUserID]; ok </span><span class="cov0" title="0">{
                        //这里可以将tabuser里 的属性拷贝到WPS user
                        item.UserName = v.NickName
                        updu = append(updu, item)
                        delete(allTableUserMap, item.ExUserID)
                }</span> else<span class="cov0" title="0"> {
                        //这个也调用makeWpsUser生成的wps user

                        delu = append(addu, item)
                }</span>
        }
        <span class="cov0" title="0">if len(allTableUserMap) &gt; 0 </span><span class="cov0" title="0">{
                for _, v := range allTableUserMap </span><span class="cov0" title="0">{
                        addu = append(delu, makeWpsUser(*v))
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("addu: %v, updu: %v, del: %v", addu, updu, delu)

        for _, item := range addu </span><span class="cov0" title="0">{
                if relations, ok := allTableDeptuserMap[item.ExUserID]; ok </span><span class="cov0" title="0">{
                        var depts []wps.Dept
                        for _, relation := range relations </span><span class="cov0" title="0">{
                                depts = append(depts, wps.Dept{DeptID: relation.Did, Name: allTableDeptMap[relation.Did].Name})
                        }</span>
                        <span class="cov0" title="0">item.Depts = depts</span>
                }

        }

        <span class="cov0" title="0">for _, item := range updu </span><span class="cov0" title="0">{
                if relations, ok := allTableDeptuserMap[item.ExUserID]; ok </span><span class="cov0" title="0">{
                        var depts []wps.Dept
                        for _, relation := range relations </span><span class="cov0" title="0">{
                                depts = append(depts, wps.Dept{DeptID: relation.Did, Name: allTableDeptMap[relation.Did].Name})
                        }</span>
                        <span class="cov0" title="0">item.Depts = depts</span>
                }

        }
        <span class="cov0" title="0">fmt.Printf("addu: %v, updu: %v, del: %v", addu, updu, delu)

        return nil, nil</span>
}

func makeWpsUser(tbuser models.TbLasUser) wps.UserItem <span class="cov0" title="0">{
        user := wps.UserItem{
                ExUserID: tbuser.Uid,
        }
        return user
}</span>

func (uc *AccounterUsecase) GetAllWpsUser(ctx context.Context) (users []wps.UserItem, err error) <span class="cov0" title="0">{
        appAccessToken, err := uc.appAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">pageSize := 50
        // 查询企业下所有用户
        req := wps.GetCompAllUsersRequest{
                Recursive: true,
                PageSize:  pageSize,
                WithTotal: true,
                Status:    []string{"active", "notactive", "disabled"},
                WithDept:  true,
        }
        for </span><span class="cov0" title="0">{
                alluser, err := uc.wps.GetCompAllUsers(ctx, appAccessToken.AccessToken, req)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "GetAllWpsUser.GetCompAllUsers", "err", err)
                        return nil, err
                }</span>

                <span class="cov0" title="0">for _, u := range alluser.Data.Items </span><span class="cov0" title="0">{
                        if u.ID == "1" </span>{<span class="cov0" title="0">
                                //continue
                        }</span>
                        //if u.Source == "sync" {
                        <span class="cov0" title="0">users = append(users, u)</span>
                        //}

                }
                <span class="cov0" title="0">if alluser.Data.NextPageToken != "" </span><span class="cov0" title="0">{
                        req.PageToken = alluser.Data.NextPageToken
                }</span>
                <span class="cov0" title="0">if alluser.Data.Total &lt; pageSize || alluser.Data.NextPageToken == "" </span><span class="cov0" title="0">{
                        break</span>
                }

        }
        <span class="cov0" title="0">return</span>

}

func (uc *AccounterUsecase) GetAllWpsDept(ctx context.Context) (depts []wps.DeptItem, err error) <span class="cov0" title="0">{
        appAccessToken, err := uc.appAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        //查询根部门
        <span class="cov0" title="0">rootDept, err := uc.wps.GetDepartmentRoot(ctx, appAccessToken.AccessToken, wps.GetDepartmentRootRequest{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Infof("rootDept: %v", rootDept)
        queue := []string{rootDept.Data.ID}
        for len(queue) &gt; 0 </span><span class="cov0" title="0">{
                currDepId := queue[0]

                req := wps.GetDeptChildrenRequest{
                        DeptID:    currDepId,
                        Recursive: true,
                        PageSize:  50,
                        WithTotal: true,
                }
                // 2. 查询部门下的子部门(要递归)
                deptInfo, err := uc.wps.GetDeptChildren(ctx, appAccessToken.AccessToken, req)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "GetAllWpsDept.GetDeptChildren", "err", err)
                        return nil, err
                }</span>

                <span class="cov0" title="0">if deptInfo.Data.Total == 0 </span><span class="cov0" title="0">{
                        queue = queue[1:]
                        continue</span>
                } else<span class="cov0" title="0"> if deptInfo.Data.Total &gt; 0 &amp;&amp; deptInfo.Data.Total &lt; 50 </span><span class="cov0" title="0">{
                        queue = queue[1:]
                        for _, item := range deptInfo.Data.Items </span><span class="cov0" title="0">{
                                depts = append(depts, item)
                                queue = append(queue, item.ID)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                } else<span class="cov0" title="0"> if deptInfo.Data.NextPageToken != "" </span><span class="cov0" title="0">{
                        req.PageToken = deptInfo.Data.NextPageToken
                }</span> else<span class="cov0" title="0"> {
                        queue = queue[1:]
                        continue</span>
                }

        }

        <span class="cov0" title="0">return depts, nil</span>

}

// // 这个方法是把全量数据执插入表后，可以自已调用原生API去同步
// func (uc *AccounterUsecase) StartSync(ctx context.Context, taskId, filename string) (err error) {

//         appAccessToken, err := uc.appAuth.GetAccessToken(ctx)
//         if err != nil {
//                 return err
//         }
//         // 查询企业下所有用户
//         alluser, err := uc.wps.GetCompAllUsers(ctx, appAccessToken.AccessToken, wps.GetCompAllUsersRequest{
//                 Recursive: true,
//                 PageSize:  50,
//                 WithTotal: true,
//                 Status:    []string{"active", "notactive", "disabled"},
//         })
//         if err != nil {
//                 return err
//         }
//         log.Infof("alluser: %v", alluser)
//         // 批量删除用户(除了admin)
//         var allUsers []string
//         for _, user := range alluser.Data.Items {
//                 if user.ID == "1" {
//                         continue
//                 }
//                 allUsers = append(allUsers, user.ID)
//         }
//         ////////////////////// 存在授权问题
//         deluserRes, err := uc.wps.PostBatchDeleteUser(ctx, appAccessToken.AccessToken, wps.PostBatchDeleteUserRequest{
//                 UserIDs: allUsers,
//         })
//         if err != nil {
//                 return err
//         }
//         log.Infof("deluserRes: %v", deluserRes)

//         //查询根部门
//         rootDept, err := uc.wps.GetDepartmentRoot(ctx, appAccessToken.AccessToken, wps.GetDepartmentRootRequest{})
//         if err != nil {
//                 return err
//         }
//         log.Infof("rootDept: %v", rootDept)

//         // 2. 查询部门下的子部门(要递归)
//         allDepts, err := uc.wps.GetDeptChildren(ctx, appAccessToken.AccessToken, wps.GetDeptChildrenRequest{
//                 DeptID: rootDept.Data.ID,
//         })
//         if err != nil {
//                 return err
//         }
//         log.Infof("children: %v", allDepts)

//         //删除部门除了根部门
//         var alldeptes []string
//         for _, dept := range allDepts.Data.Items {
//                 if dept.ID == rootDept.Data.ID {
//                         continue
//                 }
//                 alldeptes = append(alldeptes, dept.ID)
//         }

//         // 批量删除部门(接口有授权问题)
//         uc.wps.PostBatchDeleteDept(ctx, appAccessToken.AccessToken, wps.PostBatchDeleteDeptRequest{
//                 DeptIDs: alldeptes,
//         })

//         // 1. 创建部门(接口有授权问题)
//         uc.wps.PostCreateDept(ctx, appAccessToken.AccessToken, wps.PostCreateDeptRequest{
//                 ExDeptID: "test01",
//                 Name:     "test01_dep",
//                 ParentID: "1",
//                 Source:   "sync",
//                 Order:    99,
//         })

//         uc.wps.PostCreateUser(ctx, appAccessToken.AccessToken, wps.PostCreateUserRequest{
//                 ExUserID:  "test01_user",
//                 Email:     "test01@163.com",
//                 UserName:  "test01",
//                 LoginName: "13888888888",
//                 Phone:     "13888888888",
//                 DeptIDs:   []string{"1"},
//                 Source:    "sync",
//                 WorkPlace: "bj",
//         })
//         ////////////////////////////////////////////////////////////////
//         // 2. 创建部门存在的 &gt; 更新部门
//         uc.wps.PostUpdateDept(ctx, taskId, wps.PostUpdateDeptRequest{
//                 ExDeptID: "10000000000000000000000000000000",
//                 Name:     "测试部门",
//         })

//         // 3. 全量的的 减去 创建的， 再减去更新的， 就是删除的
//         uc.wps.PostBatchDeleteDept(ctx, taskId, wps.PostBatchDeleteDeptRequest{
//                 DeptIDs: []string{"10000000000000000000000000000000"},
//         })

//         // 这里的用户包含所在部门
//         uc.wps.PostCreateUser(ctx, taskId, wps.PostCreateUserRequest{
//                 UserName: "测试用户",
//         })

//         // 2. 更新用户
//         uc.wps.PostUpdateUser(ctx, taskId, wps.PostUpdateUserRequest{
//                 ExUserID: "10000000000000000000000000000000",
//                 UserName: "测试部门",
//         })

//         // 3. 更新用户
//         uc.wps.PostUpdateUser(ctx, taskId, wps.PostUpdateUserRequest{
//                 ExUserID: "10000000000000000000000000000000",
//                 UserName: "测试用户",
//         })

//         // 全量用户

//         uc.wps.PostBatchUserByPage(ctx, taskId, wps.PostBatchUserByPageRequest{
//                 PageSize: 100,
//                 PageNum:  1,
//         })

//         // 5. 全量的的 减去 创建的， 再减去更新的， 就是删除的
//         uc.wps.PostBatchDeleteUser(ctx, taskId, wps.PostBatchDeleteUserRequest{
//                 UserIDs: []string{"10000000000000000000000000000000"},
//         })
//         return nil
// }
</pre>
		
		<pre class="file" id="file12" style="display: none">package biz

import (
        "context"
        "errors"
        "fmt"
        v1 "nancalacc/api/account/v1"
        "nancalacc/internal/auth"
        "nancalacc/internal/conf"
        "nancalacc/internal/data/models"
        "nancalacc/internal/dingtalk"
        "nancalacc/internal/wps"
        "os"
        "strconv"
        "sync"
        "time"

        //"github.com/go-kratos/kratos/v2/errors"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/xuri/excelize/v2"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// FullSyncUsecase is a FullSync usecase.
type FullSyncUsecase struct {
        repo         AccounterRepo
        dingTalkRepo dingtalk.Dingtalk
        appAuth      auth.Authenticator
        wps          wps.Wps
        bizConf      *conf.App
        localCache   CacheService
        log          log.Logger
        // 批量处理配置
        batchSize  int
        maxWorkers int
}

// NewFullSyncUsecase new a FullSync usecase.
func NewFullSyncUsecase(repo AccounterRepo, dingTalkRepo dingtalk.Dingtalk, wps wps.Wps, cache CacheService, logger log.Logger) *FullSyncUsecase <span class="cov0" title="0">{
        appAuth := auth.NewWpsAppAuthenticator()
        bizConf := conf.Get().GetApp()

        // 获取批量处理配置，设置默认值
        batchSize := int(bizConf.GetBatchSize())
        if batchSize &lt;= 0 </span><span class="cov0" title="0">{
                batchSize = 500 // 默认批量大小
        }</span>

        <span class="cov0" title="0">maxWorkers := int(bizConf.GetMaxWorkers())
        if maxWorkers &lt;= 0 </span><span class="cov0" title="0">{
                maxWorkers = 3 // 默认并发数
        }</span>

        <span class="cov0" title="0">return &amp;FullSyncUsecase{
                repo:         repo,
                dingTalkRepo: dingTalkRepo,
                appAuth:      appAuth,
                wps:          wps,
                localCache:   cache,
                bizConf:      bizConf,
                log:          logger,
                batchSize:    batchSize,
                maxWorkers:   maxWorkers,
        }</span>
}

func (uc *FullSyncUsecase) CreateSyncAccount(ctx context.Context, req *v1.CreateSyncAccountRequest) (*v1.CreateSyncAccountReply, error) <span class="cov0" title="0">{
        uc.log.Log(log.LevelInfo, "msg", "CreateSyncAccount", "req", req)

        taskId := req.GetTaskName()
        if taskId == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "task name is empty")
        }</span>
        <span class="cov0" title="0">_, ok, err := uc.GetCacheTask(ctx, taskId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                return nil, status.Error(codes.AlreadyExists, "task name "+taskId+" exists")
        }</span>

        <span class="cov0" title="0">err = uc.CreateCacheTask(ctx, taskId, "pending")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">companyCfg, users, depts, deptUsers, err := uc.getFullData(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = uc.UpdateCacheTask(ctx, taskId, "in_progress", 40)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = uc.saveFullData(ctx, companyCfg, users, depts, deptUsers, taskId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = uc.UpdateCacheTask(ctx, taskId, "in_progress", 80)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = uc.notifyFullSync(ctx, taskId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = uc.UpdateCacheTask(ctx, taskId, "completed", 100)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;v1.CreateSyncAccountReply{
                TaskId:     taskId,
                CreateTime: timestamppb.Now(),
        }, nil</span>
}

func (uc *FullSyncUsecase) GetSyncAccount(ctx context.Context, req *v1.GetSyncAccountRequest) (*v1.GetSyncAccountReply, error) <span class="cov0" title="0">{
        uc.log.Log(log.LevelInfo, "msg", "GetSyncAccount", "req", req)

        taskCacheInfo, ok, err := uc.localCache.Get(ctx, req.GetTaskId())
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "GetSyncAccount.Get", "taskId", req.GetTaskId(), "err", err)
                return nil, fmt.Errorf("failed to get task from cache: %w", err)
        }</span>
        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                // 尝试类型断言为 models.Task（值类型）
                taskInfo, ok1 := taskCacheInfo.(models.Task)
                if ok1 </span><span class="cov0" title="0">{
                        return &amp;v1.GetSyncAccountReply{
                                Status:     v1.GetSyncAccountReply_Status(taskInfo.Progress),
                                ActualTime: int64(taskInfo.ActualTime),
                                StartTime:  timestamppb.New(taskInfo.CreatedAt),
                        }, nil
                }</span>

                // 如果值类型断言失败，尝试指针类型断言
                <span class="cov0" title="0">taskInfoPtr, ok2 := taskCacheInfo.(*models.Task)
                if ok2 </span><span class="cov0" title="0">{
                        return &amp;v1.GetSyncAccountReply{
                                Status:     v1.GetSyncAccountReply_Status(taskInfoPtr.Progress),
                                ActualTime: int64(taskInfoPtr.ActualTime),
                                StartTime:  timestamppb.New(taskInfoPtr.CreatedAt),
                        }, nil
                }</span>

                <span class="cov0" title="0">uc.log.Log(log.LevelError, "msg", "GetSyncAccount.type_assertion", "taskId", req.GetTaskId(), "taskInfo_type", fmt.Sprintf("%T", taskCacheInfo))
                return nil, fmt.Errorf("type error: cached value is not models.Task, got %T", taskCacheInfo)</span>
        }

        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "GetSyncAccount.not_found", "taskId", req.GetTaskId())
        return nil, status.Error(codes.NotFound, "task "+req.GetTaskId()+" not found")</span>
}
func (uc *FullSyncUsecase) getFullData(ctx context.Context) (companyCfg *dingtalk.DingtalkCompanyCfg,
        users []*dingtalk.DingtalkDeptUser, depts []*dingtalk.DingtalkDept,
        deptUsers []*dingtalk.DingtalkDeptUserRelation, err error) <span class="cov0" title="0">{
        companyCft := &amp;dingtalk.DingtalkCompanyCfg{
                ThirdCompanyId: uc.bizConf.GetThirdCompanyId(),
                PlatformIds:    uc.bizConf.GetPlatformIds(),
                CompanyId:      uc.bizConf.GetCompanyId(),
        }

        dingTalkAccessToken, err := uc.dingTalkRepo.GetAccessToken(ctx)
        uc.log.Log(log.LevelInfo, "msg", "GetAccessToken", "dingTalkAccessToken", dingTalkAccessToken, "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, err
        }</span>
        <span class="cov0" title="0">accessToken := dingTalkAccessToken.AccessToken

        depts, err = uc.dingTalkRepo.FetchDepartments(ctx, accessToken)
        uc.log.Log(log.LevelInfo, "msg", "FetchDepartments", "depts", depts, "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">var deptIds []int64
        for _, dept := range depts </span><span class="cov0" title="0">{
                deptIds = append(deptIds, dept.DeptID)
        }</span>
        // 1. 从第三方获取用户数据
        <span class="cov0" title="0">users, err = uc.dingTalkRepo.FetchDepartmentUsers(ctx, accessToken, deptIds)

        for _, deptUser := range users </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelInfo, "msg", "FetchDepartmentUsers", "deptUser", deptUser)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, err
        }</span>
        <span class="cov0" title="0">for _, deptUser := range users </span><span class="cov0" title="0">{
                order := make(map[int64]int64, 0)
                if len(deptUser.DeptOrderList) &gt; 0 </span><span class="cov0" title="0">{
                        for _, depIdOrder := range deptUser.DeptOrderList </span><span class="cov0" title="0">{
                                order[depIdOrder.DeptID] = depIdOrder.DeptID
                        }</span>
                }
                <span class="cov0" title="0">for _, depId := range deptUser.DeptIDList </span><span class="cov0" title="0">{

                        reliation := &amp;dingtalk.DingtalkDeptUserRelation{
                                Uid: deptUser.Userid,
                                Did: strconv.FormatInt(depId, 10),
                        }
                        if order, ok := order[depId]; ok </span><span class="cov0" title="0">{
                                reliation.Order = order
                        }</span>
                        <span class="cov0" title="0">deptUsers = append(deptUsers, reliation)</span>
                }

        }
        <span class="cov0" title="0">return companyCft, users, depts, deptUsers, nil</span>
}
func (uc *FullSyncUsecase) notifyFullSync(ctx context.Context, taskId string) (err error) <span class="cov0" title="0">{
        appAccessToken, err := uc.appAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "notifyFullSync.GetAccessToken", "err", err)
                return err
        }</span>
        <span class="cov0" title="0">resp, err := uc.wps.PostEcisaccountsyncAll(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncAllRequest{
                TaskId:         taskId,
                ThirdCompanyId: uc.bizConf.GetThirdCompanyId(),
        })
        uc.log.Log(log.LevelInfo, "msg", "PostEcisaccountsyncAll", "resp", resp, "err", err)
        return err</span>
}
func (uc *FullSyncUsecase) saveFullData(ctx context.Context, companyCfg *dingtalk.DingtalkCompanyCfg, users []*dingtalk.DingtalkDeptUser, depts []*dingtalk.DingtalkDept,
        deptUsers []*dingtalk.DingtalkDeptUserRelation, taskId string) (err error) <span class="cov0" title="0">{
        var wg sync.WaitGroup
        errChan := make(chan error, 4)
        wg.Add(4)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                errChan &lt;- uc.repo.SaveCompanyCfg(ctx, companyCfg)
        }</span>()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                _, err := uc.repo.SaveDepartments(ctx, depts, taskId)
                errChan &lt;- err
        }</span>()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                _, err := uc.repo.SaveUsers(ctx, users, taskId)
                errChan &lt;- err
        }</span>()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                _, err := uc.repo.SaveDepartmentUserRelations(ctx, deptUsers, taskId)
                errChan &lt;- err
        }</span>()
        <span class="cov0" title="0">wg.Wait()
        close(errChan)
        for err := range errChan </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
func (uc *FullSyncUsecase) ParseExecell(ctx context.Context, taskId, filename string) (err error) <span class="cov0" title="0">{
        uc.log.Log(log.LevelInfo, "msg", "ParseExecell", "taskId", taskId, "filename", filename)

        // 更新任务状态为处理中
        if err := uc.UpdateCacheTask(ctx, taskId, "in_progress", 10); err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "ParseExecell", "failed to update task progress", "err", err)
        }</span>

        // 确保在函数结束时清理临时文件
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := os.Remove(filename); err != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelWarn, "msg", "ParseExecell", "failed to remove temp file", "filename", filename, "err", err)
                }</span>
        }()

        <span class="cov0" title="0">f, err := excelize.OpenFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "ParseExecell", "failed to open excel file", "err", err)
                if updateErr := uc.UpdateCacheTask(ctx, taskId, "cancelled", 0); updateErr != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "ParseExecell", "failed to update task status", "err", updateErr)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to open excel file: %w", err)</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "ParseExecell", "failed to close excel file", "err", err)
                }</span>
        }()

        // 验证Excel文件格式
        <span class="cov0" title="0">if err := uc.validateExcelFormat(f); err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "ParseExecell", "invalid excel format", "err", err)
                if updateErr := uc.UpdateCacheTask(ctx, taskId, "cancelled", 0); updateErr != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "ParseExecell", "failed to update task status", "err", updateErr)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("invalid excel format: %w", err)</span>
        }

        // 更新进度到20%
        <span class="cov0" title="0">if err := uc.UpdateCacheTask(ctx, taskId, "in_progress", 20); err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "ParseExecell", "failed to update task progress", "err", err)
        }</span>

        // 并发处理工作表
        <span class="cov0" title="0">errChan := make(chan error, 3)
        var wg sync.WaitGroup

        sheets := f.GetSheetList()
        processSheet := map[string]bool{
                "user":            true,
                "department":      true,
                "department_user": true,
        }

        // 统计需要处理的工作表数量
        sheetCount := 0
        for _, sheet := range sheets </span><span class="cov0" title="0">{
                if processSheet[sheet] </span><span class="cov0" title="0">{
                        sheetCount++
                }</span>
        }

        <span class="cov0" title="0">if sheetCount == 0 </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelWarn, "msg", "ParseExecell", "no valid sheets found")
                if updateErr := uc.UpdateCacheTask(ctx, taskId, "cancelled", 0); updateErr != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "ParseExecell", "failed to update task status", "err", updateErr)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("no valid sheets found in excel file")</span>
        }

        // 并发处理每个工作表
        <span class="cov0" title="0">for _, sheet := range sheets </span><span class="cov0" title="0">{
                if !processSheet[sheet] </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">wg.Add(1)
                go func(sheetName string) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        if err := uc.processSheet(ctx, taskId, f, sheetName); err != nil </span><span class="cov0" title="0">{
                                uc.log.Log(log.LevelError, "msg", "ParseExecell", "failed to process sheet", "sheet", sheetName, "err", err)
                                errChan &lt;- fmt.Errorf("failed to process sheet %s: %w", sheetName, err)
                        }</span>
                }(sheet)
        }

        // 等待所有工作表处理完成
        <span class="cov0" title="0">wg.Wait()
        close(errChan)

        // 检查是否有错误
        for err := range errChan </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if updateErr := uc.UpdateCacheTask(ctx, taskId, "cancelled", 0); updateErr != nil </span><span class="cov0" title="0">{
                                uc.log.Log(log.LevelError, "msg", "ParseExecell", "failed to update task status", "err", updateErr)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }

        // 更新进度到80%
        <span class="cov0" title="0">if err := uc.UpdateCacheTask(ctx, taskId, "in_progress", 80); err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "ParseExecell", "failed to update task progress", "err", err)
        }</span>
        // 通知下游服务
        <span class="cov0" title="0">err = uc.notifyFullSync(ctx, taskId)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "ParseExecell", "failed to notify downstream service", "err", err)
                if updateErr := uc.UpdateCacheTask(ctx, taskId, "cancelled", 0); updateErr != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "ParseExecell", "failed to update task status", "err", updateErr)
                }</span>
        }

        // 更新任务状态为完成
        <span class="cov0" title="0">if err := uc.UpdateCacheTask(ctx, taskId, "completed", 100); err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "ParseExecell", "failed to update task progress", "err", err)
        }</span>

        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "ParseExecell", "completed successfully", "taskId", taskId)
        return nil</span>
}

// validateExcelFormat 验证Excel文件格式
func (uc *FullSyncUsecase) validateExcelFormat(f *excelize.File) error <span class="cov0" title="0">{
        sheets := f.GetSheetList()
        requiredSheets := map[string]bool{
                "user":            true,
                "department":      true,
                "department_user": true,
        }

        foundSheets := 0
        for _, sheet := range sheets </span><span class="cov0" title="0">{
                if requiredSheets[sheet] </span><span class="cov0" title="0">{
                        foundSheets++
                }</span>
        }

        <span class="cov0" title="0">if foundSheets == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no required sheets found. Required: user, department, department_user")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// processSheet 处理单个工作表
func (uc *FullSyncUsecase) processSheet(ctx context.Context, taskId string, f *excelize.File, sheetName string) error <span class="cov0" title="0">{
        uc.log.Log(log.LevelInfo, "msg", "processSheet", "taskId", taskId, "sheet", sheetName)

        rows, err := f.Rows(sheetName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows for sheet %s: %w", sheetName, err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // 跳过标题行
        rows.Next()

        switch sheetName </span>{
        case "user":<span class="cov0" title="0">
                return uc.transUser(ctx, taskId, rows)</span>
        case "department":<span class="cov0" title="0">
                return uc.transDept(ctx, taskId, rows)</span>
        case "department_user":<span class="cov0" title="0">
                return uc.transUserDept(ctx, taskId, rows)</span>
        default:<span class="cov0" title="0">
                uc.log.Log(log.LevelWarn, "msg", "processSheet", "unknown sheet", "sheet", sheetName)
                return nil</span>
        }
}

func (uc *FullSyncUsecase) transUser(ctx context.Context, taskId string, rows *excelize.Rows) (err error) <span class="cov0" title="0">{
        uc.log.Log(log.LevelInfo, "msg", "transUser", "taskId", taskId)

        thirdCompanyId := uc.bizConf.GetThirdCompanyId()
        platformIds := uc.bizConf.GetPlatformIds()
        // 使用配置的批量大小
        users := make([]*models.TbLasUser, 0, uc.batchSize)
        now := time.Now()
        processedCount := 0
        errorCount := 0

        for rows.Next() </span><span class="cov0" title="0">{
                row, err := rows.Columns()
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "transUser", "failed to get row columns", "err", err)
                        errorCount++
                        continue</span>
                }

                // 数据验证
                <span class="cov0" title="0">if len(row) &lt; 3 </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelWarn, "msg", "transUser", "invalid row data", "row", row, "expected_columns", 3)
                        errorCount++
                        continue</span>
                }

                // 验证必填字段
                <span class="cov0" title="0">if row[0] == "" || row[1] == "" || row[2] == "" </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelWarn, "msg", "transUser", "missing required fields", "row", row)
                        errorCount++
                        continue</span>
                }

                <span class="cov0" title="0">users = append(users, &amp;models.TbLasUser{
                        TaskID:           taskId,
                        ThirdCompanyID:   thirdCompanyId,
                        PlatformID:       platformIds,
                        Uid:              row[0],
                        Account:          row[1],
                        NickName:         row[2],
                        EmploymentStatus: "active",
                        Source:           "sync",
                        Ctime:            now,
                        Mtime:            now,
                        CheckType:        1,
                })

                processedCount++

                // 批量保存
                if len(users) &gt;= uc.batchSize </span><span class="cov0" title="0">{
                        if _, err := uc.repo.BatchSaveUsers(ctx, users); err != nil </span><span class="cov0" title="0">{
                                uc.log.Log(log.LevelError, "msg", "transUser", "failed to batch save users", "err", err)
                                return fmt.Errorf("failed to batch save users: %w", err)
                        }</span>
                        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "transUser", "batch saved", "count", len(users))
                        users = users[:0]</span> // 清空切片（保留底层数组，避免重新分配）
                }
        }

        // 保存剩余数据
        <span class="cov0" title="0">if len(users) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := uc.repo.BatchSaveUsers(ctx, users); err != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "transUser", "failed to save remaining users", "err", err)
                        return fmt.Errorf("failed to save remaining users: %w", err)
                }</span>
                <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "transUser", "final batch saved", "count", len(users))</span>
        }

        <span class="cov0" title="0">if err := rows.Error(); err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "transUser", "rows error", "err", err)
                return fmt.Errorf("rows error: %w", err)
        }</span>

        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "transUser", "completed", "processed", processedCount, "errors", errorCount)
        return nil</span>
}
func (uc *FullSyncUsecase) transDept(ctx context.Context, taskId string, rows *excelize.Rows) (err error) <span class="cov0" title="0">{
        uc.log.Log(log.LevelInfo, "msg", "transDept", "taskId", taskId)

        thirdCompanyId := uc.bizConf.GetThirdCompanyId()
        platformIds := uc.bizConf.GetPlatformIds()
        // 使用配置的批量大小
        depts := make([]*models.TbLasDepartment, 0, uc.batchSize)
        now := time.Now()
        processedCount := 0
        errorCount := 0

        for rows.Next() </span><span class="cov0" title="0">{
                row, err := rows.Columns()
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "transDept", "failed to get row columns", "err", err)
                        errorCount++
                        continue</span>
                }

                // 数据验证
                <span class="cov0" title="0">if len(row) &lt; 3 </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelWarn, "msg", "transDept", "invalid row data", "row", row, "expected_columns", 3)
                        errorCount++
                        continue</span>
                }

                // 验证必填字段
                <span class="cov0" title="0">if row[0] == "" || row[2] == "" </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelWarn, "msg", "transDept", "missing required fields", "row", row)
                        errorCount++
                        continue</span>
                }

                <span class="cov0" title="0">depts = append(depts, &amp;models.TbLasDepartment{
                        TaskID:         taskId,
                        ThirdCompanyID: thirdCompanyId,
                        PlatformID:     platformIds,
                        Did:            row[0],
                        Pid:            row[1],
                        Name:           row[2],
                        Source:         "sync",
                        Ctime:          now,
                        Mtime:          now,
                        CheckType:      1,
                })

                processedCount++

                // 批量保存
                if len(depts) &gt;= uc.batchSize </span><span class="cov0" title="0">{
                        if _, err := uc.repo.BatchSaveDepts(ctx, depts); err != nil </span><span class="cov0" title="0">{
                                uc.log.Log(log.LevelError, "msg", "transDept", "failed to batch save departments", "err", err)
                                return fmt.Errorf("failed to batch save departments: %w", err)
                        }</span>
                        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "transDept", "batch saved", "count", len(depts))
                        depts = depts[:0]</span> // 清空切片
                }
        }

        // 保存剩余数据
        <span class="cov0" title="0">if len(depts) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := uc.repo.BatchSaveDepts(ctx, depts); err != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "transDept", "failed to save remaining departments", "err", err)
                        return fmt.Errorf("failed to save remaining departments: %w", err)
                }</span>
                <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "transDept", "final batch saved", "count", len(depts))</span>
        }

        <span class="cov0" title="0">if err := rows.Error(); err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "transDept", "rows error", "err", err)
                return fmt.Errorf("rows error: %w", err)
        }</span>

        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "transDept", "completed", "processed", processedCount, "errors", errorCount)
        return nil</span>
}
func (uc *FullSyncUsecase) transUserDept(ctx context.Context, taskId string, rows *excelize.Rows) (err error) <span class="cov0" title="0">{
        uc.log.Log(log.LevelInfo, "msg", "transUserDept", "taskId", taskId)

        thirdCompanyId := uc.bizConf.GetThirdCompanyId()
        platformIds := uc.bizConf.GetPlatformIds()
        // 使用配置的批量大小
        deptusers := make([]*models.TbLasDepartmentUser, 0, uc.batchSize)
        now := time.Now()
        processedCount := 0
        errorCount := 0

        for rows.Next() </span><span class="cov0" title="0">{
                row, err := rows.Columns()
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "transUserDept", "failed to get row columns", "err", err)
                        errorCount++
                        continue</span>
                }

                // 数据验证
                <span class="cov0" title="0">if len(row) &lt; 2 </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelWarn, "msg", "transUserDept", "invalid row data", "row", row, "expected_columns", 2)
                        errorCount++
                        continue</span>
                }

                // 验证必填字段
                <span class="cov0" title="0">if row[0] == "" || row[1] == "" </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelWarn, "msg", "transUserDept", "missing required fields", "row", row)
                        errorCount++
                        continue</span>
                }

                <span class="cov0" title="0">deptusers = append(deptusers, &amp;models.TbLasDepartmentUser{
                        TaskID:         taskId,
                        ThirdCompanyID: thirdCompanyId,
                        PlatformID:     platformIds,
                        Uid:            row[0],
                        Did:            row[1],
                        Ctime:          now,
                        CheckType:      1,
                })

                processedCount++

                for _, deptuser := range deptusers </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelInfo, "msg", "transUserDeptXXXXX", "deptuser", deptuser)
                }</span>
                // 批量保存
                <span class="cov0" title="0">if len(deptusers) &gt;= uc.batchSize </span><span class="cov0" title="0">{
                        if _, err := uc.repo.BatchSaveDeptUsers(ctx, deptusers); err != nil </span><span class="cov0" title="0">{
                                uc.log.Log(log.LevelError, "msg", "transUserDept", "failed to batch save department users", "err", err)
                                return fmt.Errorf("failed to batch save department users: %w", err)
                        }</span>
                        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "transUserDept", "batch saved", "count", len(deptusers))
                        deptusers = deptusers[:0]</span> // 清空切片（保留底层数组，避免重新分配）
                }
        }

        // 保存剩余数据
        <span class="cov0" title="0">if len(deptusers) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := uc.repo.BatchSaveDeptUsers(ctx, deptusers); err != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "transUserDept", "failed to save remaining department users", "err", err)
                        return fmt.Errorf("failed to save remaining department users: %w", err)
                }</span>
                <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "transUserDept", "final batch saved", "count", len(deptusers))</span>
        }

        <span class="cov0" title="0">if err := rows.Error(); err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "transUserDept", "rows error", "err", err)
                return fmt.Errorf("rows error: %w", err)
        }</span>

        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "transUserDept", "completed", "processed", processedCount, "errors", errorCount)
        return nil</span>
}

func (uc *FullSyncUsecase) CleanSyncAccount(ctx context.Context, taskName string, tags []string) error <span class="cov0" title="0">{

        appAccessToken, err := uc.appAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if taskName == "phone" </span><span class="cov0" title="0">{
                users, err := uc.wps.GetCompAllUsers(ctx, appAccessToken.AccessToken, wps.GetCompAllUsersRequest{
                        Recursive: true,
                        PageSize:  50,
                        WithTotal: true,
                        Status:    []string{"active", "notactive", "disabled"},
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var deleteUsers []*dingtalk.DingtalkDeptUser
                for _, user := range users.Data.Items </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelInfo, "msg", "Items", "user", user)

                        for _, phone := range tags </span><span class="cov0" title="0">{
                                if user.Phone == phone || user.LoginName == phone </span><span class="cov0" title="0">{
                                        deleteUser := &amp;dingtalk.DingtalkDeptUser{
                                                Userid: user.ExUserID,
                                                Mobile: user.Phone,
                                                Name:   user.UserName,
                                                Email:  user.Email,
                                        }

                                        for _, dep := range user.Depts </span><span class="cov0" title="0">{
                                                depId, _ := strconv.ParseInt(dep.DeptID, 10, 64)
                                                deleteUser.DeptIDList = append(deleteUser.DeptIDList, depId)
                                        }</span>
                                        <span class="cov0" title="0">deleteUsers = append(deleteUsers, deleteUser)</span>

                                }
                        }

                }
                <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "deleteUsers", "deleteUsers", deleteUsers)
                for i, user := range deleteUsers </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelInfo, "msg", "deleteUsers", "i", i, "user", user)
                }</span>

                <span class="cov0" title="0">err = uc.repo.SaveIncrementUsers(ctx, nil, deleteUsers, nil)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "OrgDeptCreate.SaveIncrementDepartments", "err", err)
                        return err
                }</span>

                <span class="cov0" title="0">res, err := uc.wps.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
                        ThirdCompanyId: uc.bizConf.GetThirdCompanyId(),
                })

                uc.log.Log(log.LevelInfo, "msg", "UserLeaveOrg.CallEcisaccountsyncIncrement", "res", res, "err", err)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if res.Code != "200" </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "UserLeaveOrg.CallEcisaccountsyncIncrement", "res", res, "err", err)
                        return fmt.Errorf("code %s not 200", res.Code)
                }</span>
        }

        <span class="cov0" title="0">if taskName == "dept" </span><span class="cov0" title="0">{
                //查询根部门
                rootDept, err := uc.wps.GetDepartmentRoot(ctx, appAccessToken.AccessToken, wps.GetDepartmentRootRequest{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "rootDept", "rootDept", rootDept)

                // 2. 查询部门下的子部门(要递归)
                allDepts, err := uc.wps.GetDeptChildren(ctx, appAccessToken.AccessToken, wps.GetDeptChildrenRequest{
                        DeptID:    rootDept.Data.ID,
                        Recursive: true,
                        PageSize:  50,
                        WithTotal: true,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "children", "allDepts", allDepts)

                var deleteDepts []*dingtalk.DingtalkDept
                //删除部门除了根部门
                for _, dept := range allDepts.Data.Items </span><span class="cov0" title="0">{
                        if dept.ID == rootDept.Data.ID </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">deptId, _ := strconv.ParseInt(dept.ExDeptID, 10, 64)

                        deptDetail, err := uc.wps.BatchPostDepartments(ctx, appAccessToken.AccessToken, wps.BatchPostDepartmentsRequest{
                                DeptIDs: []string{dept.ParentID},
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">parentId, _ := strconv.ParseInt(deptDetail.Data.Items[0].ExDeptID, 10, 64)

                        for _, tag := range tags </span><span class="cov0" title="0">{

                                if tag == dept.Name </span><span class="cov0" title="0">{
                                        // 这里要找父级节点的extid
                                        detp := &amp;dingtalk.DingtalkDept{
                                                DeptID:   deptId,
                                                ParentID: parentId,
                                                Order:    int64(dept.Order),
                                                Name:     dept.Name,
                                        }
                                        deleteDepts = append(deleteDepts, detp)

                                }</span>
                        }

                }

                <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "deleteDepts", "deleteDepts", deleteDepts)
                for i, dept := range deleteDepts </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelInfo, "msg", "deleteDepts", "i", i, "dept", dept)
                }</span>

                <span class="cov0" title="0">err = uc.repo.SaveIncrementDepartments(ctx, nil, deleteDepts, nil)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "OrgDeptCreate.SaveIncrementDepartments", "err", err)
                        return err
                }</span>

                <span class="cov0" title="0">res, err := uc.wps.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
                        ThirdCompanyId: uc.bizConf.GetThirdCompanyId(),
                })

                uc.log.Log(log.LevelInfo, "msg", "UserLeaveOrg.CallEcisaccountsyncIncrement", "res", res, "err", err)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if res.Code != "200" </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "UserLeaveOrg.CallEcisaccountsyncIncrement", "res", res, "err", err)
                        return fmt.Errorf("code %s not 200", res.Code)
                }</span>

        }

        <span class="cov0" title="0">return nil</span>

}

func (uc *FullSyncUsecase) GetCacheTask(ctx context.Context, taskName string) (models.Task, bool, error) <span class="cov0" title="0">{

        var task models.Task
        taskInfo, ok, err := uc.localCache.Get(ctx, taskName)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "GetCacheTask.Get", "taskName", taskName, "err", err)
                return task, false, fmt.Errorf("failed to get task from cache: %w", err)
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelInfo, "msg", "GetCacheTask.not_found", "taskName", taskName)
                return task, false, nil
        }</span>

        <span class="cov0" title="0">task, ok1 := taskInfo.(models.Task)
        if !ok1 </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "GetCacheTask.type_assertion", "taskName", taskName, "taskInfo_type", fmt.Sprintf("%T", taskInfo))
                return task, false, fmt.Errorf("type error: cached value is not models.Task, got %T", taskInfo)
        }</span>
        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "GetCacheTask.success", "taskName", taskName, "task", task)
        return task, true, nil</span>
}

func (uc *FullSyncUsecase) CreateCacheTask(ctx context.Context, taskName, status string) error <span class="cov0" title="0">{

        now := time.Now()
        // 使用时间戳作为任务 ID，确保唯一性
        taskId := uint(now.Unix())

        taskInfo := models.Task{
                ID:          taskId,
                Title:       taskName,
                Description: fmt.Sprintf("Task: %s", taskName),
                Status:      status,
                CreatorID:   1, // 可以后续改进为实际的用户 ID
                CreatedAt:   now,
                UpdatedAt:   now,
                DueDate:     now.Add(24 * time.Hour), // 设置默认截止时间为24小时后
                StartDate:   now,
                Progress:    0, // 初始进度为0
                ActualTime:  0,
        }
        uc.log.Log(log.LevelInfo, "msg", "CreateCacheTask", "taskInfo", taskInfo, "taskName", taskName, "status", status)

        err := uc.localCache.Set(ctx, taskName, taskInfo, 300*time.Minute)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "CreateCacheTask.Set", "taskName", taskName, "err", err)
                return fmt.Errorf("failed to create cache task: %w", err)
        }</span>

        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "CreateCacheTask.success", "taskName", taskName, "taskId", taskId)
        return nil</span>
}

// updateTaskProgress 更新任务进度
func (uc *FullSyncUsecase) UpdateCacheTask(ctx context.Context, taskId, status string, progress int) error <span class="cov0" title="0">{
        // 暂时使用日志记录，实际实现可以根据需要更新缓存或数据库
        uc.log.Log(log.LevelInfo, "msg", "updateCacheTask", "taskId", taskId, "status", status, "progress", progress)

        // var task models.Task
        taskInfo, ok, err := uc.localCache.Get(ctx, taskId)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "UpdateCacheTask.Get", "taskId", taskId, "err", err)
                return fmt.Errorf("failed to get task from cache: %w", err)
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelWarn, "msg", "UpdateCacheTask.Get", "taskId", taskId, "err", "task not found in cache")
                return errors.New("task not found")
        }</span>

        <span class="cov0" title="0">task, ok1 := taskInfo.(models.Task)
        if !ok1 </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "UpdateCacheTask.type_assertion", "taskId", taskId, "taskInfo_type", fmt.Sprintf("%T", taskInfo))
                return errors.New("type error: cached value is not models.Task")
        }</span>
        // 更新任务信息
        <span class="cov0" title="0">task.Status = status
        task.Progress = int8(progress)
        task.UpdatedAt = time.Now()
        task.ActualTime = int(time.Since(task.CreatedAt).Minutes())

        // 设置更新后的任务到缓存
        err = uc.localCache.Set(ctx, taskId, task, 300*time.Minute)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "UpdateCacheTask.Set", "taskId", taskId, "err", err)
                return fmt.Errorf("failed to set cache: %w", err)
        }</span>

        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "UpdateCacheTask.success", "taskId", taskId, "status", status, "progress", progress)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package biz

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "nancalacc/internal/auth"
        "nancalacc/internal/conf"
        "nancalacc/internal/dingtalk"
        "nancalacc/internal/pkg/utils"
        "nancalacc/internal/wps"
        "strconv"

        //"github.com/go-kratos/kratos/v2/errors"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/open-dingtalk/dingtalk-stream-sdk-go/clientV2"
)

// GreeterUsecase is a Greeter usecase.
type IncrementalSyncUsecase struct {
        repo         AccounterRepo
        dingTalkRepo dingtalk.Dingtalk
        bizConf      *conf.App
        wpsAppAuth   auth.Authenticator
        wps          wps.Wps
        log          log.Logger
}

// NewGreeterUsecase new a Greeter usecase.
func NewIncrementalSyncUsecase(repo AccounterRepo, dingTalkRepo dingtalk.Dingtalk, wps wps.Wps, logger log.Logger) *IncrementalSyncUsecase <span class="cov0" title="0">{
        wpsAppAuth := auth.NewWpsAppAuthenticator()
        bizConf := conf.Get().GetApp()
        return &amp;IncrementalSyncUsecase{
                repo: repo, dingTalkRepo: dingTalkRepo, bizConf: bizConf,
                wpsAppAuth: wpsAppAuth,
                wps:        wps,
                log:        logger}
}</span>

// OrgDeptAdd 部门新增
func (uc *IncrementalSyncUsecase) OrgDeptCreate(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) error <span class="cov0" title="0">{

        thirdCompanyId := uc.bizConf.GetThirdCompanyId()
        uc.log.Log(log.LevelInfo, "msg", "OrgDeptCreate", "data", event.Data)

        if event.Data == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">depIds, err := uc.getDeptidsFromDingTalkEvent(event)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(depIds) == 0 </span><span class="cov0" title="0">{
                log.Info("OrgDeptCreate len(depIds) eq 0")
                return nil
        }</span>

        <span class="cov0" title="0">dingTalkAccessToken, err := uc.dingTalkRepo.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">accessToken := dingTalkAccessToken.AccessToken

        uc.log.Log(log.LevelInfo, "msg", "FetchDeptDetails", "accessToken", accessToken, "depIds", depIds)
        depts, err := uc.dingTalkRepo.FetchDeptDetails(ctx, accessToken, depIds)
        uc.log.Log(log.LevelInfo, "msg", "FetchDeptDetails", "accessToken", accessToken, "depIds", depIds, "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = uc.repo.SaveIncrementDepartments(ctx, depts, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "SaveIncrementDepartments", "err", err)
                return err
        }</span>

        <span class="cov0" title="0">appAccessToken, err := uc.wpsAppAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">res, err := uc.wps.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
                ThirdCompanyId: thirdCompanyId,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if res.Code != "200" </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "PostEcisaccountsyncIncrement", "res", res, "err", err)
                return fmt.Errorf("code %s not 200", res.Code)
        }</span>
        <span class="cov0" title="0">return nil</span>

}

// OrgDeptRemove 部门删除
func (uc *IncrementalSyncUsecase) OrgDeptRemove(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) error <span class="cov0" title="0">{
        uc.log.Log(log.LevelInfo, "msg", "OrgDeptRemove", "data", event.Data)

        thirdCompanyId := uc.bizConf.GetThirdCompanyId()
        if event.Data == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 1. 已删除的部门ID列表
        <span class="cov0" title="0">depIds, err := uc.getDeptidsFromDingTalkEvent(event)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(depIds) == 0 </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelWarn, "msg", "OrgDeptRemove", "len(depIds) eq 0")
                return nil
        }</span>

        <span class="cov0" title="0">var depIdstr []string
        for _, depId := range depIds </span><span class="cov0" title="0">{
                depIdstr = append(depIdstr, strconv.FormatInt(depId, 10))

        }</span>

        <span class="cov0" title="0">if len(depIdstr) == 0 </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelWarn, "msg", "OrgDeptRemove", "len(depIdstr) eq 0")
                return errors.New("OrgDeptRemove len(depIdstr) eq 0")
        }</span>

        <span class="cov0" title="0">appAccessToken, err := uc.wpsAppAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">token := appAccessToken.AccessToken

        // 2. 查询部门ID
        depInfos, err := uc.wps.PostBatchDepartmentsByExDepIds(ctx, token, wps.PostBatchDepartmentsByExDepIdsRequest{
                ExDeptIDs: depIdstr,
        })

        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "PostBatchDepartmentsByExDepIds", "err", err)
                return err
        }</span>
        <span class="cov0" title="0">var deptIDs []string
        tempDeptIDs := make(map[string]int64)
        for _, depInfo := range depInfos.Data.Items </span><span class="cov0" title="0">{
                deptIDs = append(deptIDs, depInfo.ParentID)
        }</span>

        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "OrgDeptRemove", "deptIDs", deptIDs)

        if len(deptIDs) == 0 </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelWarn, "msg", "OrgDeptRemove", "len(deptIDs) eq 0")
                return errors.New("OrgDeptRemove len(deptIDs) eq 0")
        }</span>
        <span class="cov0" title="0">parentDeptInfos, err := uc.wps.BatchPostDepartments(ctx, token, wps.BatchPostDepartmentsRequest{
                DeptIDs: deptIDs,
        })
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "BatchPostDepartments", "err", err)
                return err
        }</span>

        <span class="cov0" title="0">for _, pdis := range parentDeptInfos.Data.Items </span><span class="cov0" title="0">{
                extpareId, err := strconv.ParseInt(pdis.ExDeptID, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "ParseInt", "pdis.ExDeptID", pdis.ExDeptID, "err", err)
                }</span>
                <span class="cov0" title="0">tempDeptIDs[pdis.ID] = extpareId</span>
        }

        <span class="cov0" title="0">var depts []*dingtalk.DingtalkDept

        for _, depInfo := range depInfos.Data.Items </span><span class="cov0" title="0">{

                dingtalkID, err := strconv.ParseInt(depInfo.ExDeptID, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">parentID, ok := tempDeptIDs[depInfo.ParentID]
                if !ok </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelError, "msg", "OrgDeptRemove", "not found parentID for DeptID", dingtalkID)
                        continue</span>
                }
                <span class="cov0" title="0">detp := &amp;dingtalk.DingtalkDept{
                        DeptID:   dingtalkID,
                        ParentID: parentID,
                        Order:    int64(depInfo.Order),
                        Name:     depInfo.Name,
                }

                depts = append(depts, detp)</span>

        }

        <span class="cov0" title="0">err = uc.repo.SaveIncrementDepartments(ctx, nil, depts, nil)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "SaveIncrementDepartments", "err", err)
                return err
        }</span>

        <span class="cov0" title="0">res, err := uc.wps.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
                ThirdCompanyId: thirdCompanyId,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if res.Code != "200" </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "PostEcisaccountsyncIncrement", "res", res, "err", err)
                return fmt.Errorf("code %s not 200", res.Code)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// OrgDeptModify 部门修改
func (uc *IncrementalSyncUsecase) OrgDeptModify(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) error <span class="cov0" title="0">{

        uc.log.Log(log.LevelInfo, "msg", "OrgDeptModify", "data", event.Data)

        thirdCompanyId := uc.bizConf.GetThirdCompanyId()
        if event.Data == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("event.Data is nil")
        }</span>

        <span class="cov0" title="0">depIds, err := uc.getDeptidsFromDingTalkEvent(event)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dingTalkAccessToken, err := uc.dingTalkRepo.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">accessToken := dingTalkAccessToken.AccessToken

        uc.log.Log(log.LevelInfo, "msg", "FetchDeptDetails", "accessToken", accessToken, "depIds", depIds)
        depts, err := uc.dingTalkRepo.FetchDeptDetails(ctx, accessToken, depIds)
        uc.log.Log(log.LevelInfo, "msg", "FetchDeptDetails", "accessToken", accessToken, "depIds", depIds, "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = uc.repo.SaveIncrementDepartments(ctx, nil, nil, depts)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "SaveIncrementDepartments", "err", err)
                return err
        }</span>

        <span class="cov0" title="0">appAccessToken, err := uc.wpsAppAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">res, err := uc.wps.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
                ThirdCompanyId: thirdCompanyId,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if res.Code != "200" </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "PostEcisaccountsyncIncrement", "res", res, "err", err)
                return fmt.Errorf("code %s not 200", res.Code)
        }</span>
        <span class="cov0" title="0">return nil</span>

}

// UserAddOrg 用户加入部门
// 1. 加用户
// 2. 加关系
func (uc *IncrementalSyncUsecase) UserAddOrg(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) error <span class="cov0" title="0">{

        uc.log.Log(log.LevelInfo, "msg", "UserAddOrg", "data", event.Data)

        thirdCompanyId := uc.bizConf.GetThirdCompanyId()
        if event.Data == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">userIds, err := uc.getUseridsFromDingTalkEvent(event)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dingTalkAccessToken, err := uc.dingTalkRepo.GetAccessToken(ctx)
        uc.log.Log(log.LevelInfo, "msg", "GetAccessToken", "dingTalkAccessToken", dingTalkAccessToken, "userIds", userIds, "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">accessToken := dingTalkAccessToken.AccessToken

        uc.log.Log(log.LevelInfo, "msg", "GetUserDetail", "userIds", userIds)
        users, err := uc.dingTalkRepo.FetchUserDetail(ctx, accessToken, userIds)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = uc.repo.SaveIncrementUsers(ctx, users, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">relations := generateUserDeptRelations(users)

        err = uc.repo.SaveIncrementDepartmentUserRelations(ctx, relations, nil, nil)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">appAccessToken, err := uc.wpsAppAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">res, err := uc.wps.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
                ThirdCompanyId: thirdCompanyId,
        })

        log.Infof("UserAddOrg.CallEcisaccountsyncIncrement res: %v, err: %v", res, err)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if res.Code != "200" </span><span class="cov0" title="0">{
                log.Errorf("code %v, not '200'", res.Code)
                return fmt.Errorf("code %s not 200", res.Code)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UserLeaveOrg 用户退出部门
// 1. 减用户
// 2. 减关系 //未自测
func (uc *IncrementalSyncUsecase) UserLeaveOrg(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) error <span class="cov0" title="0">{

        thirdCompanyId := uc.bizConf.GetThirdCompanyId()
        uc.log.Log(log.LevelInfo, "msg", "UserLeaveOrg", "data", event.Data)
        if event.Data == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">userIds, err := uc.getUseridsFromDingTalkEvent(event)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">appAccessToken, err := uc.wpsAppAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">wpsUsers, err := uc.FindWpsUser(ctx, userIds)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(wpsUsers) == 0 </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelWarn, "msg", "UserLeaveOrg", "wpsUsers is empty, userIds", userIds)
                return fmt.Errorf("wpsUsers is empty")
        }</span>
        <span class="cov0" title="0">err = uc.repo.SaveIncrementUsers(ctx, nil, wpsUsers, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">relations := generateUserDeptRelations(wpsUsers)

        err = uc.repo.SaveIncrementDepartmentUserRelations(ctx, nil, relations, nil)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">res, err := uc.wps.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
                ThirdCompanyId: thirdCompanyId,
        })

        uc.log.Log(log.LevelInfo, "msg", "CallEcisaccountsyncIncrement", "res", res, "err", err)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if res.Code != "200" </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "CallEcisaccountsyncIncrement", "res", res, "err", err)
                return fmt.Errorf("code %s not 200", res.Code)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (uc *IncrementalSyncUsecase) FindWpsUser(ctx context.Context, userids []string) ([]*dingtalk.DingtalkDeptUser, error) <span class="cov0" title="0">{
        uc.log.Log(log.LevelInfo, "msg", "FindWpsUser", "req", "userids", userids)
        var users []*dingtalk.DingtalkDeptUser
        appAccessToken, err := uc.wpsAppAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, userId := range userids </span><span class="cov0" title="0">{
                wpsUserInfo, err := uc.wps.PostBatchUsersByExDepIds(ctx, appAccessToken.AccessToken, wps.PostBatchUsersByExDepIdsRequest{
                        ExUserIDs: []string{userId},
                        Status:    []string{wps.UserStatusActive, wps.UserStatusNoActive, wps.UserStatusDisabled},
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if len(wpsUserInfo.Data.Items) == 0 </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelWarn, "msg", "FindWpsUser", "wpsUserInfo.Data.Items is empty, userId", userId)
                        continue</span>
                }

                <span class="cov0" title="0">wpsUser := wpsUserInfo.Data.Items[0]
                wpsUserid := wpsUser.ID

                wpsDeptInfo, err := uc.wps.GetUserDeptsByUserId(ctx, appAccessToken.AccessToken, wps.GetUserDeptsByUserIdRequest{
                        UserID: wpsUserid,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if len(wpsDeptInfo.Data.Items) == 0 </span><span class="cov0" title="0">{
                        uc.log.Log(log.LevelWarn, "msg", "FindWpsUser", "wpsDeptInfo.Data.Items is empty, userId", userId)
                        continue</span>
                }
                <span class="cov0" title="0">user := &amp;dingtalk.DingtalkDeptUser{
                        Userid: wpsUser.ExUserId,
                        Name:   wpsUser.UserName,
                        Email:  wpsUser.Email,
                        Mobile: wpsUser.Phone,
                }
                for _, item := range wpsDeptInfo.Data.Items </span><span class="cov0" title="0">{
                        deptId, err := strconv.ParseInt(item.ExDeptID, 10, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">user.DeptIDList = append(user.DeptIDList, deptId)</span>
                }
                <span class="cov0" title="0">users = append(users, user)</span>
        }
        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "FindWpsUser", "res", "users", users)
        if len(users) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wpsUsers is empty")
        }</span>
        <span class="cov0" title="0">for _, user := range users </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelInfo, "msg", "FindWpsUser", "res", "user", user)
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}
func (uc *IncrementalSyncUsecase) FindDingTalkUser(ctx context.Context, userids []string) ([]*dingtalk.DingtalkDeptUser, error) <span class="cov0" title="0">{
        uc.log.Log(log.LevelInfo, "msg", "FindDingTalkUser", "req", "userids", userids)

        dingTalkAccessToken, err := uc.dingTalkRepo.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">accessToken := dingTalkAccessToken.AccessToken

        users, err := uc.dingTalkRepo.FetchUserDetail(ctx, accessToken, userids)
        uc.log.Log(log.LevelInfo, "msg", "FindDingTalkUser", "res", "users", users, "err", err)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

// UserModifyOrg 用户信息变更（有部门变正在实现）
func (uc *IncrementalSyncUsecase) UserModifyOrg(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) error <span class="cov0" title="0">{

        thirdCompanyId := uc.bizConf.GetThirdCompanyId()
        uc.log.Log(log.LevelInfo, "msg", "UserModifyOrg", "data", event.Data)
        diffUserInfo, _ := uc.getUseInfoFromDingTalkEvent(event)
        diffUserMap := make(map[string]*dingtalk.DingtalkDeptUser, len(diffUserInfo))
        if len(diffUserInfo) &gt; 0 </span><span class="cov0" title="0">{
                for _, diffUser := range diffUserInfo </span><span class="cov0" title="0">{
                        diffUserMap[diffUser.Userid] = diffUser
                        uc.log.Log(log.LevelInfo, "msg", "UserModifyOrg", "diffUser", diffUser)
                }</span>
        }

        <span class="cov0" title="0">userIds, err := uc.getUseridsFromDingTalkEvent(event)

        userIds = utils.RemoveDuplicates(userIds)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">wpsUsersMap := make(map[string]*dingtalk.DingtalkDeptUser)
        wpsUsers, err := uc.FindWpsUser(ctx, userIds)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(wpsUsers) &gt; 0 </span><span class="cov0" title="0">{
                for _, user := range wpsUsers </span><span class="cov0" title="0">{
                        wpsUsersMap[user.Userid] = user
                }</span>
        }

        <span class="cov0" title="0">for _, u := range wpsUsers </span><span class="cov0" title="0">{
                log.Infof("UserModifyOrg wpsuser: %+v", u)

                for _, deptId := range u.DeptIDList </span><span class="cov0" title="0">{
                        log.Infof("UserModifyOrg wpsuser deptId: %+v", deptId)
                }</span>
        }

        <span class="cov0" title="0">dingtalkUsers, err := uc.FindDingTalkUser(ctx, userIds)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "UserModifyOrg", "userIds.size", len(userIds))
        uc.log.Log(log.LevelInfo, "msg", "UserModifyOrg", "wpsUsers.size", len(wpsUsers))
        uc.log.Log(log.LevelInfo, "msg", "UserModifyOrg", "dingtalkUsers.size", len(dingtalkUsers))
        var modfiyUserBaseInfo []*dingtalk.DingtalkDeptUser
        var delRelation []*dingtalk.DingtalkDeptUserRelation
        var addRelation []*dingtalk.DingtalkDeptUserRelation
        var updRelation []*dingtalk.DingtalkDeptUserRelation

        for _, dingtalkUser := range dingtalkUsers </span><span class="cov0" title="0">{ //4个
                var delDepts []int64
                var addDepts []int64
                var updDepts []int64
                finalUser := dingtalkUser
                dingtalkUseridDeptidMap := make(map[string]int64)
                for _, deptId := range dingtalkUser.DeptIDList </span><span class="cov0" title="0">{
                        key := dingtalkUser.Userid + "#" + strconv.FormatInt(deptId, 10)
                        dingtalkUseridDeptidMap[key] = deptId
                }</span>
                <span class="cov0" title="0">if wpsUser, ok := wpsUsersMap[dingtalkUser.Userid]; ok </span><span class="cov0" title="0">{ //先找到用户

                        for _, deptId := range wpsUser.DeptIDList </span><span class="cov0" title="0">{
                                key1 := wpsUser.Userid + "#" + strconv.FormatInt(deptId, 10)

                                if _, ok := dingtalkUseridDeptidMap[key1]; ok </span><span class="cov0" title="0">{
                                        //部门修改
                                        updDepts = append(updDepts, deptId)
                                        uc.log.Log(log.LevelInfo, "msg", "UserModifyOrg", "部门关系修改", "user.Userid#deptId", key1)
                                        delete(dingtalkUseridDeptidMap, key1)
                                }</span> else<span class="cov0" title="0"> {
                                        //部门删除
                                        uc.log.Log(log.LevelInfo, "msg", "UserModifyOrg", "部门关系删除", "user.Userid#deptId", key1)
                                        delDepts = append(delDepts, deptId)

                                }</span>
                        }

                }
                <span class="cov0" title="0">if len(dingtalkUseridDeptidMap) &gt; 0 </span><span class="cov0" title="0">{
                        for k, deptId := range dingtalkUseridDeptidMap </span><span class="cov0" title="0">{
                                uc.log.Log(log.LevelInfo, "msg", "UserModifyOrg", "部门关系增加", "user.Userid#deptId", k)
                                addDepts = append(addDepts, deptId)
                        }</span>

                }

                <span class="cov0" title="0">if len(addDepts) &gt; 0 </span><span class="cov0" title="0">{
                        adduser := finalUser
                        adduser.DeptIDList = addDepts
                        addRelation = append(addRelation, generateUserDeptRelations([]*dingtalk.DingtalkDeptUser{adduser})...)

                }</span>
                <span class="cov0" title="0">if len(delDepts) &gt; 0 </span><span class="cov0" title="0">{
                        deluser := finalUser
                        deluser.DeptIDList = delDepts
                        delRelation = append(delRelation, generateUserDeptRelations([]*dingtalk.DingtalkDeptUser{deluser})...)
                }</span>
                <span class="cov0" title="0">if len(updDepts) &gt; 0 </span><span class="cov0" title="0">{
                        upduser := finalUser
                        upduser.DeptIDList = updDepts
                        updRelation = append(updRelation, generateUserDeptRelations([]*dingtalk.DingtalkDeptUser{upduser})...)
                }</span>

                <span class="cov0" title="0">if _, ok := diffUserMap[finalUser.Userid]; ok </span><span class="cov0" title="0">{
                        modfiyUserBaseInfo = append(modfiyUserBaseInfo, finalUser)
                }</span>
        }
        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "UserModifyOrg", "部门关系新增", "addRelation", addRelation)
        for i, item := range addRelation </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelInfo, "msg", "UserModifyOrg", "部门关系新增", "i", i, "item", item)
        }</span>
        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "UserModifyOrg", "部门关系删除", "delRelation", delRelation)
        for i, item := range delRelation </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelInfo, "msg", "UserModifyOrg", "部门关系删除", "i", i, "item", item)
        }</span>

        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "UserModifyOrg", "部门关系修改", "updRelation", updRelation)
        for i, item := range updRelation </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelInfo, "msg", "UserModifyOrg", "部门关系修改", "i", i, "item", item)
        }</span>

        <span class="cov0" title="0">uc.log.Log(log.LevelInfo, "msg", "UserModifyOrg", "基础信息变更", "modfiyUserBaseInfo", modfiyUserBaseInfo)
        for i, item := range modfiyUserBaseInfo </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelInfo, "msg", "UserModifyOrg", "基础信息变更", "i", i, "item", item)
        }</span>
        <span class="cov0" title="0">if len(modfiyUserBaseInfo) &gt; 0 </span><span class="cov0" title="0">{
                err = uc.repo.SaveIncrementUsers(ctx, nil, nil, modfiyUserBaseInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if len(addRelation)+len(delRelation)+len(updRelation) &gt; 0 </span><span class="cov0" title="0">{
                err = uc.repo.SaveIncrementDepartmentUserRelations(ctx, addRelation, delRelation, updRelation)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">log.Infof("UserModifyOrg.CallEcisaccountsyncIncrement test %s", event.Data)
        //return nil
        appAccessToken, err := uc.wpsAppAuth.GetAccessToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">res, err := uc.wps.PostEcisaccountsyncIncrement(ctx, appAccessToken.AccessToken, &amp;wps.EcisaccountsyncIncrementRequest{
                ThirdCompanyId: thirdCompanyId,
        })

        log.Infof("UserModifyOrg.CallEcisaccountsyncIncrement res: %v, err: %v", res, err)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if res.Code != "200" </span><span class="cov0" title="0">{
                log.Errorf("code %v, not '200'", res.Code)
                return fmt.Errorf("code %s not 200", res.Code)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func generateUserDeptRelations(deptUsers []*dingtalk.DingtalkDeptUser) []*dingtalk.DingtalkDeptUserRelation <span class="cov0" title="0">{
        var deptUserRelations []*dingtalk.DingtalkDeptUserRelation
        for _, deptUser := range deptUsers </span><span class="cov0" title="0">{

                order := make(map[int64]int64, 0)
                if len(deptUser.DeptOrderList) &gt; 0 </span><span class="cov0" title="0">{
                        for _, depIdOrder := range deptUser.DeptOrderList </span><span class="cov0" title="0">{
                                order[depIdOrder.DeptID] = depIdOrder.DeptID
                        }</span>
                }

                <span class="cov0" title="0">for _, depId := range deptUser.DeptIDList </span><span class="cov0" title="0">{
                        relation := &amp;dingtalk.DingtalkDeptUserRelation{
                                Uid: deptUser.Userid,
                                Did: strconv.FormatInt(depId, 10),
                                // Order: order,
                        }
                        if order, ok := order[depId]; ok </span><span class="cov0" title="0">{
                                relation.Order = order
                        }</span>
                        <span class="cov0" title="0">deptUserRelations = append(deptUserRelations, relation)</span>
                }

        }

        <span class="cov0" title="0">return deptUserRelations</span>
}

func (uc *IncrementalSyncUsecase) getDeptidsFromDingTalkEvent(event *clientV2.GenericOpenDingTalkEvent) ([]int64, error) <span class="cov0" title="0">{
        uc.log.Log(log.LevelInfo, "msg", "getDeptidsFromDingTalkEvent", "event.Data", event.Data)

        if event.Data == nil </span><span class="cov0" title="0">{
                return nil, errors.New("getDeptidsFromDingTalkEvent event.Data is nil")
        }</span>
        <span class="cov0" title="0">datamap := event.Data
        var depIds []int64

        deptId, exists := datamap["deptId"]

        if !exists </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "getDeptidsFromDingTalkEvent", "not deptId", deptId, "exists", exists)
                return nil, errors.New("getDeptidsFromDingTalkEvent not deptId")
        }</span>

        <span class="cov0" title="0">deptIdSlice, ok := deptId.([]interface{})

        if !ok </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "getDeptidsFromDingTalkEvent", "deptId not []interface{}", deptId, "ok", ok)
                return nil, errors.New("deptId not []interface{}")
        }</span>

        <span class="cov0" title="0">for _, item := range deptIdSlice </span><span class="cov0" title="0">{
                if f, ok := item.(float64); ok </span><span class="cov0" title="0">{
                        depIds = append(depIds, int64(f))
                }</span> else<span class="cov0" title="0"> {
                        uc.log.Log(log.LevelError, "msg", "getDeptidsFromDingTalkEvent", "deptId not float64", item)
                        return nil, errors.New("deptId not float64")
                }</span>
        }
        <span class="cov0" title="0">return depIds, nil</span>
}

func (uc *IncrementalSyncUsecase) getUseridsFromDingTalkEvent(event *clientV2.GenericOpenDingTalkEvent) ([]string, error) <span class="cov0" title="0">{
        uc.log.Log(log.LevelInfo, "msg", "getUseridsFromDingTalkEvent", "event.Data", event.Data)
        if event.Data == nil </span><span class="cov0" title="0">{
                return nil, errors.New("getUseridsFromDingTalkEvent event.Data is nil")
        }</span>
        <span class="cov0" title="0">datamap := event.Data
        var userIds []string

        userId, exists := datamap["userId"]

        if !exists </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "getUseridsFromDingTalkEvent", "not userId", userId, "exists", exists)
                return nil, errors.New("getUseridsFromDingTalkEvent not userId")
        }</span>

        <span class="cov0" title="0">userIdSlice, ok := userId.([]interface{})

        if !ok </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "getUseridsFromDingTalkEvent", "userId not []interface{}", userId, "ok", ok)
                return nil, errors.New("userId not []interface{}")
        }</span>

        <span class="cov0" title="0">for _, item := range userIdSlice </span><span class="cov0" title="0">{
                if f, ok := item.(string); ok </span><span class="cov0" title="0">{
                        userIds = append(userIds, f)
                }</span> else<span class="cov0" title="0"> {
                        uc.log.Log(log.LevelError, "msg", "getUseridsFromDingTalkEvent", "userId not string", item)
                        return nil, errors.New("userId not string")
                }</span>
        }
        <span class="cov0" title="0">return userIds, nil</span>
}

// map[
//
//        diffInfo:[
//                map[
//                        curr:map[email:ian@googla.om hiredDate:2025-08-07 jobNumber:20 name:Ianmodity remark:me telephone: workPlace:北京]
//                        prev:map[email:ian@googla.om hiredDate:2025-08-07 jobNumber:20 name:Ian remark:me telephone: workPlace:北京]
//                        userid:03301410433273270
//                ]
//        ]
//        eventId:ebb4c3f1284e45f680ac50ec55b5c5d8
//        optStaffId:manager331
//        timeStamp:1754553836642
//        userId:[03301410433273270]
//
// ]
func (uc *IncrementalSyncUsecase) getUseInfoFromDingTalkEvent(event *clientV2.GenericOpenDingTalkEvent) ([]*dingtalk.DingtalkDeptUser, error) <span class="cov0" title="0">{
        uc.log.Log(log.LevelInfo, "msg", "getUseInfoFromDingTalkEvent", "event.Data", event.Data)
        data := event.Data

        var userInfos []*dingtalk.DingtalkDeptUser
        jsonData, err := json.Marshal(data)
        uc.log.Log(log.LevelInfo, "msg", "getUseInfoFromDingTalkEvent", "Marshal", "jsonData", jsonData, "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshal error: %v", err)
        }</span>

        <span class="cov0" title="0">var modifyInfo dingtalk.UserModifyOrgEventData
        err = json.Unmarshal(jsonData, &amp;modifyInfo)
        uc.log.Log(log.LevelInfo, "msg", "getUseInfoFromDingTalkEvent", "Unmarshal", "err", err, "modifyInfo", modifyInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unmarshal error: %v", err)
        }</span>
        <span class="cov0" title="0">for _, modifyInfo := range modifyInfo.DiffInfo </span><span class="cov0" title="0">{
                userInfo := &amp;dingtalk.DingtalkDeptUser{
                        Userid:    modifyInfo.Userid,
                        Name:      modifyInfo.Curr.Name,
                        Email:     modifyInfo.Curr.Email,
                        WorkPlace: modifyInfo.Curr.WorkPlace,
                        JobNumber: modifyInfo.Curr.JobNumber,
                        Mobile:    modifyInfo.Curr.Telephone,
                        Remark:    modifyInfo.Curr.Remark,
                }
                userInfos = append(userInfos, userInfo)
        }</span>

        <span class="cov0" title="0">return userInfos, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package biz

import (
        "context"
        "errors"
        v1 "nancalacc/api/account/v1"
        "nancalacc/internal/dingtalk"

        "github.com/go-kratos/kratos/v2/log"
)

// GreeterUsecase is a Greeter usecase.
type Oauth2Usecase struct {
        dingTalkRepo dingtalk.Dingtalk
        log          log.Logger
}

// NewGreeterUsecase new a Greeter usecase.
func NewOauth2Usecase(dingTalkRepo dingtalk.Dingtalk, logger log.Logger) *Oauth2Usecase <span class="cov0" title="0">{
        return &amp;Oauth2Usecase{dingTalkRepo: dingTalkRepo, log: logger}
}</span>

func (uc *Oauth2Usecase) GetUserInfo(ctx context.Context, req *v1.GetUserInfoRequest) (*v1.GetUserInfoResponse, error) <span class="cov0" title="0">{

        uc.log.Log(log.LevelInfo, "msg", "GetUserInfo", "req", req)

        accessToken := req.GetAccessToken()
        if accessToken == "" </span><span class="cov0" title="0">{
                return nil, errors.New("access_token is empty")
        }</span>
        <span class="cov0" title="0">var userId string
        userInfo, err := uc.dingTalkRepo.GetUserInfo(ctx, accessToken, "me")
        uc.log.Log(log.LevelInfo, "msg", "GetUserInfo.dingTalkRepo.GetUserInfo", "userInfo", userInfo, "err", err)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "GetUserInfo.dingTalkRepo.GetUserInfo", "userInfo", userInfo, "err", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">token, err := uc.dingTalkRepo.GetAccessToken(ctx)
        uc.log.Log(log.LevelInfo, "msg", "GetUserInfo.dingTalkRepo.GetAccessToken", "token", token, "err", err)
        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "GetUserInfo.dingTalkRepo.GetAccessToken", "token", token, "err", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">userId, err = uc.dingTalkRepo.GetUseridByUnionid(ctx, token.AccessToken, userInfo.UnionId)
        log.Infof("GetUserInfo.GetUseridByUnionid: userId: %v, err: %v", userId, err)

        if err != nil </span><span class="cov0" title="0">{
                uc.log.Log(log.LevelError, "msg", "GetUserInfo.GetUseridByUnionid", "userId", userId, "err", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;v1.GetUserInfoResponse{
                UnionId: userInfo.UnionId,
                UserId:  userId,
                Name:    userInfo.Nick,
                Email:   userInfo.Email,
                Avatar:  userInfo.AvatarUrl,
        }, nil</span>
}
func (uc *Oauth2Usecase) GetAccessToken(ctx context.Context, req *v1.GetAccessTokenRequest) (*v1.GetAccessTokenResponse, error) <span class="cov0" title="0">{

        uc.log.Log(log.LevelInfo, "msg", "GetAccessToken", "req", req)

        code := req.GetCode()
        if code == "" </span><span class="cov0" title="0">{
                return nil, errors.New("code is empty")
        }</span>
        <span class="cov0" title="0">tokenRes, err := uc.dingTalkRepo.GetUserAccessToken(ctx, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;v1.GetAccessTokenResponse{
                AccessToken:  tokenRes.AccessToken,
                RefreshToken: tokenRes.RefreshToken,
                ExpiresIn:    int64(tokenRes.ExpireIn),
                //RefreshToken: tokenRes.RefreshToken,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v5.29.3
// source: conf/conf.proto

package conf

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        durationpb "google.golang.org/protobuf/types/known/durationpb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Bootstrap struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Server        *Server                `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
        Data          *Data                  `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
        App           *App                   `protobuf:"bytes,3,opt,name=app,proto3" json:"app,omitempty"`
        Auth          *Auth                  `protobuf:"bytes,4,opt,name=auth,proto3" json:"auth,omitempty"`
        Otel          *OpenTelemetry         `protobuf:"bytes,5,opt,name=otel,proto3" json:"otel,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Bootstrap) Reset() <span class="cov0" title="0">{
        *x = Bootstrap{}
        mi := &amp;file_conf_conf_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Bootstrap) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Bootstrap) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Bootstrap) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Bootstrap.ProtoReflect.Descriptor instead.
func (*Bootstrap) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Bootstrap) GetServer() *Server <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Server
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Bootstrap) GetData() *Data <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Data
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Bootstrap) GetApp() *App <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.App
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Bootstrap) GetAuth() *Auth <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Auth
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Bootstrap) GetOtel() *OpenTelemetry <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Otel
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Server struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Http          *Server_HTTP           `protobuf:"bytes,1,opt,name=http,proto3" json:"http,omitempty"`
        Grpc          *Server_GRPC           `protobuf:"bytes,2,opt,name=grpc,proto3" json:"grpc,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Server) Reset() <span class="cov0" title="0">{
        *x = Server{}
        mi := &amp;file_conf_conf_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Server) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Server) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Server) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Server.ProtoReflect.Descriptor instead.
func (*Server) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{1}
}</span>

func (x *Server) GetHttp() *Server_HTTP <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Http
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Server) GetGrpc() *Server_GRPC <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Grpc
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Data struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Database      *Data_Database         `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
        DatabaseSync  *Data_DatabaseSync     `protobuf:"bytes,2,opt,name=database_sync,json=databaseSync,proto3" json:"database_sync,omitempty"`
        Redis         *Data_Redis            `protobuf:"bytes,3,opt,name=redis,proto3" json:"redis,omitempty"`
        Etcd          *Data_Etcd             `protobuf:"bytes,4,opt,name=etcd,proto3" json:"etcd,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Data) Reset() <span class="cov0" title="0">{
        *x = Data{}
        mi := &amp;file_conf_conf_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Data) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Data) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Data) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Data.ProtoReflect.Descriptor instead.
func (*Data) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{2}
}</span>

func (x *Data) GetDatabase() *Data_Database <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Database
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Data) GetDatabaseSync() *Data_DatabaseSync <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DatabaseSync
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Data) GetRedis() *Data_Redis <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Redis
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Data) GetEtcd() *Data_Etcd <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Etcd
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type App struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        Id             string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name           string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Version        string                 `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
        Env            string                 `protobuf:"bytes,4,opt,name=env,proto3" json:"env,omitempty"`
        AppPackage     string                 `protobuf:"bytes,5,opt,name=app_package,json=appPackage,proto3" json:"app_package,omitempty"`
        AppId          string                 `protobuf:"bytes,6,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
        AppSecret      string                 `protobuf:"bytes,7,opt,name=app_secret,json=appSecret,proto3" json:"app_secret,omitempty"`
        ThirdCompanyId string                 `protobuf:"bytes,8,opt,name=third_company_id,json=thirdCompanyId,proto3" json:"third_company_id,omitempty"`
        PlatformIds    string                 `protobuf:"bytes,9,opt,name=platform_ids,json=platformIds,proto3" json:"platform_ids,omitempty"`
        CompanyId      string                 `protobuf:"bytes,10,opt,name=company_id,json=companyId,proto3" json:"company_id,omitempty"`
        AccessKey      string                 `protobuf:"bytes,11,opt,name=access_key,json=accessKey,proto3" json:"access_key,omitempty"`
        SecretKey      string                 `protobuf:"bytes,12,opt,name=secret_key,json=secretKey,proto3" json:"secret_key,omitempty"`
        // 批量处理配置
        BatchSize     int32  `protobuf:"varint,13,opt,name=batch_size,json=batchSize,proto3" json:"batch_size,omitempty"`    // 批量大小，默认500
        MaxWorkers    int32  `protobuf:"varint,14,opt,name=max_workers,json=maxWorkers,proto3" json:"max_workers,omitempty"` // 最大并发工作数，默认3
        LogLevel      string `protobuf:"bytes,15,opt,name=log_level,json=logLevel,proto3" json:"log_level,omitempty"`        // 日志级别
        Logout        string `protobuf:"bytes,16,opt,name=logout,proto3" json:"logout,omitempty"`                            // 日志输出
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *App) Reset() <span class="cov0" title="0">{
        *x = App{}
        mi := &amp;file_conf_conf_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *App) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*App) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *App) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use App.ProtoReflect.Descriptor instead.
func (*App) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{3}
}</span>

func (x *App) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Version
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetEnv() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Env
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetAppPackage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AppPackage
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetAppId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AppId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetAppSecret() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AppSecret
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetThirdCompanyId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ThirdCompanyId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetPlatformIds() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PlatformIds
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetCompanyId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CompanyId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetAccessKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetSecretKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SecretKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetBatchSize() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BatchSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *App) GetMaxWorkers() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxWorkers
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *App) GetLogLevel() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LogLevel
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *App) GetLogout() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Logout
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// OpenTelemetry 统一配置
type OpenTelemetry struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        Enabled        bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
        ServiceName    string                 `protobuf:"bytes,2,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
        ServiceVersion string                 `protobuf:"bytes,3,opt,name=service_version,json=serviceVersion,proto3" json:"service_version,omitempty"`
        Environment    string                 `protobuf:"bytes,4,opt,name=environment,proto3" json:"environment,omitempty"`
        // 追踪配置
        Traces *TracesConfig `protobuf:"bytes,5,opt,name=traces,proto3" json:"traces,omitempty"`
        // 指标配置
        Metrics *MetricsConfig `protobuf:"bytes,6,opt,name=metrics,proto3" json:"metrics,omitempty"`
        // 日志配置
        Logs          *LogsConfig `protobuf:"bytes,7,opt,name=logs,proto3" json:"logs,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *OpenTelemetry) Reset() <span class="cov0" title="0">{
        *x = OpenTelemetry{}
        mi := &amp;file_conf_conf_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *OpenTelemetry) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OpenTelemetry) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OpenTelemetry) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OpenTelemetry.ProtoReflect.Descriptor instead.
func (*OpenTelemetry) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{4}
}</span>

func (x *OpenTelemetry) GetEnabled() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enabled
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *OpenTelemetry) GetServiceName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ServiceName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *OpenTelemetry) GetServiceVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ServiceVersion
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *OpenTelemetry) GetEnvironment() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Environment
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *OpenTelemetry) GetTraces() *TracesConfig <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Traces
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *OpenTelemetry) GetMetrics() *MetricsConfig <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metrics
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *OpenTelemetry) GetLogs() *LogsConfig <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Logs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// 日志配置
type LogsConfig struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        Enabled        bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
        Level          string                 `protobuf:"bytes,2,opt,name=level,proto3" json:"level,omitempty"`
        Format         string                 `protobuf:"bytes,3,opt,name=format,proto3" json:"format,omitempty"`
        Output         string                 `protobuf:"bytes,4,opt,name=output,proto3" json:"output,omitempty"`
        FilePath       string                 `protobuf:"bytes,5,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
        MaxSize        int32                  `protobuf:"varint,6,opt,name=max_size,json=maxSize,proto3" json:"max_size,omitempty"`
        MaxBackups     int32                  `protobuf:"varint,7,opt,name=max_backups,json=maxBackups,proto3" json:"max_backups,omitempty"`
        MaxAge         int32                  `protobuf:"varint,8,opt,name=max_age,json=maxAge,proto3" json:"max_age,omitempty"`
        Compress       bool                   `protobuf:"varint,9,opt,name=compress,proto3" json:"compress,omitempty"`
        Caller         bool                   `protobuf:"varint,10,opt,name=caller,proto3" json:"caller,omitempty"`
        Stacktrace     bool                   `protobuf:"varint,11,opt,name=stacktrace,proto3" json:"stacktrace,omitempty"`
        EscapeNewlines bool                   `protobuf:"varint,12,opt,name=escape_newlines,json=escapeNewlines,proto3" json:"escape_newlines,omitempty"`
        Gorm           *GormLog               `protobuf:"bytes,13,opt,name=gorm,proto3" json:"gorm,omitempty"`
        Loki           *LokiConfig            `protobuf:"bytes,14,opt,name=loki,proto3" json:"loki,omitempty"`
        // Zap配置
        UseZap               bool   `protobuf:"varint,15,opt,name=use_zap,json=useZap,proto3" json:"use_zap,omitempty"`                                             // 是否使用zap logger
        ZapDevelopment       bool   `protobuf:"varint,16,opt,name=zap_development,json=zapDevelopment,proto3" json:"zap_development,omitempty"`                     // 是否为开发模式
        ZapDisableCaller     bool   `protobuf:"varint,17,opt,name=zap_disable_caller,json=zapDisableCaller,proto3" json:"zap_disable_caller,omitempty"`             // 是否禁用调用者信息
        ZapDisableStacktrace bool   `protobuf:"varint,18,opt,name=zap_disable_stacktrace,json=zapDisableStacktrace,proto3" json:"zap_disable_stacktrace,omitempty"` // 是否禁用堆栈跟踪
        ZapEncoding          string `protobuf:"bytes,19,opt,name=zap_encoding,json=zapEncoding,proto3" json:"zap_encoding,omitempty"`                               // 编码格式: json, console
        ZapTimeKey           string `protobuf:"bytes,20,opt,name=zap_time_key,json=zapTimeKey,proto3" json:"zap_time_key,omitempty"`                                // 时间字段名
        ZapLevelKey          string `protobuf:"bytes,21,opt,name=zap_level_key,json=zapLevelKey,proto3" json:"zap_level_key,omitempty"`                             // 级别字段名
        ZapNameKey           string `protobuf:"bytes,22,opt,name=zap_name_key,json=zapNameKey,proto3" json:"zap_name_key,omitempty"`                                // 名称字段名
        ZapCallerKey         string `protobuf:"bytes,23,opt,name=zap_caller_key,json=zapCallerKey,proto3" json:"zap_caller_key,omitempty"`                          // 调用者字段名
        ZapFunctionKey       string `protobuf:"bytes,24,opt,name=zap_function_key,json=zapFunctionKey,proto3" json:"zap_function_key,omitempty"`                    // 函数字段名
        ZapMessageKey        string `protobuf:"bytes,25,opt,name=zap_message_key,json=zapMessageKey,proto3" json:"zap_message_key,omitempty"`                       // 消息字段名
        ZapStacktraceKey     string `protobuf:"bytes,26,opt,name=zap_stacktrace_key,json=zapStacktraceKey,proto3" json:"zap_stacktrace_key,omitempty"`              // 堆栈跟踪字段名
        unknownFields        protoimpl.UnknownFields
        sizeCache            protoimpl.SizeCache
}

func (x *LogsConfig) Reset() <span class="cov0" title="0">{
        *x = LogsConfig{}
        mi := &amp;file_conf_conf_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LogsConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogsConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogsConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogsConfig.ProtoReflect.Descriptor instead.
func (*LogsConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{5}
}</span>

func (x *LogsConfig) GetEnabled() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enabled
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *LogsConfig) GetLevel() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Level
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogsConfig) GetFormat() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Format
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogsConfig) GetOutput() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Output
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogsConfig) GetFilePath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FilePath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogsConfig) GetMaxSize() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *LogsConfig) GetMaxBackups() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxBackups
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *LogsConfig) GetMaxAge() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxAge
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *LogsConfig) GetCompress() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Compress
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *LogsConfig) GetCaller() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Caller
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *LogsConfig) GetStacktrace() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Stacktrace
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *LogsConfig) GetEscapeNewlines() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EscapeNewlines
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *LogsConfig) GetGorm() *GormLog <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Gorm
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *LogsConfig) GetLoki() *LokiConfig <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Loki
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *LogsConfig) GetUseZap() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UseZap
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *LogsConfig) GetZapDevelopment() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ZapDevelopment
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *LogsConfig) GetZapDisableCaller() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ZapDisableCaller
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *LogsConfig) GetZapDisableStacktrace() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ZapDisableStacktrace
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *LogsConfig) GetZapEncoding() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ZapEncoding
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogsConfig) GetZapTimeKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ZapTimeKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogsConfig) GetZapLevelKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ZapLevelKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogsConfig) GetZapNameKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ZapNameKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogsConfig) GetZapCallerKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ZapCallerKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogsConfig) GetZapFunctionKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ZapFunctionKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogsConfig) GetZapMessageKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ZapMessageKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LogsConfig) GetZapStacktraceKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ZapStacktraceKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Loki配置
type LokiConfig struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Enabled       bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
        Endpoint      string                 `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LokiConfig) Reset() <span class="cov0" title="0">{
        *x = LokiConfig{}
        mi := &amp;file_conf_conf_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LokiConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LokiConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LokiConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LokiConfig.ProtoReflect.Descriptor instead.
func (*LokiConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{6}
}</span>

func (x *LokiConfig) GetEnabled() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enabled
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *LokiConfig) GetEndpoint() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Endpoint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GORM日志配置
type GormLog struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        SlowThreshold string                 `protobuf:"bytes,1,opt,name=slow_threshold,json=slowThreshold,proto3" json:"slow_threshold,omitempty"`
        LogLevel      string                 `protobuf:"bytes,2,opt,name=log_level,json=logLevel,proto3" json:"log_level,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GormLog) Reset() <span class="cov0" title="0">{
        *x = GormLog{}
        mi := &amp;file_conf_conf_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GormLog) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GormLog) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GormLog) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GormLog.ProtoReflect.Descriptor instead.
func (*GormLog) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{7}
}</span>

func (x *GormLog) GetSlowThreshold() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SlowThreshold
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GormLog) GetLogLevel() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LogLevel
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// 追踪配置
type TracesConfig struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        Enabled         bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
        VerboseLogging  bool                   `protobuf:"varint,2,opt,name=verbose_logging,json=verboseLogging,proto3" json:"verbose_logging,omitempty"`
        LogRequestSize  bool                   `protobuf:"varint,3,opt,name=log_request_size,json=logRequestSize,proto3" json:"log_request_size,omitempty"`
        LogResponseSize bool                   `protobuf:"varint,4,opt,name=log_response_size,json=logResponseSize,proto3" json:"log_response_size,omitempty"`
        LogHeaders      bool                   `protobuf:"varint,5,opt,name=log_headers,json=logHeaders,proto3" json:"log_headers,omitempty"`
        LogQueryParams  bool                   `protobuf:"varint,6,opt,name=log_query_params,json=logQueryParams,proto3" json:"log_query_params,omitempty"`
        Jaeger          *JaegerConfig          `protobuf:"bytes,7,opt,name=jaeger,proto3" json:"jaeger,omitempty"`
        Otlp            *OtlpConfig            `protobuf:"bytes,8,opt,name=otlp,proto3" json:"otlp,omitempty"`
        Prometheus      *PrometheusConfig      `protobuf:"bytes,9,opt,name=prometheus,proto3" json:"prometheus,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *TracesConfig) Reset() <span class="cov0" title="0">{
        *x = TracesConfig{}
        mi := &amp;file_conf_conf_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TracesConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TracesConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TracesConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TracesConfig.ProtoReflect.Descriptor instead.
func (*TracesConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{8}
}</span>

func (x *TracesConfig) GetEnabled() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enabled
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TracesConfig) GetVerboseLogging() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VerboseLogging
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TracesConfig) GetLogRequestSize() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LogRequestSize
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TracesConfig) GetLogResponseSize() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LogResponseSize
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TracesConfig) GetLogHeaders() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LogHeaders
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TracesConfig) GetLogQueryParams() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LogQueryParams
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TracesConfig) GetJaeger() *JaegerConfig <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Jaeger
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TracesConfig) GetOtlp() *OtlpConfig <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Otlp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TracesConfig) GetPrometheus() *PrometheusConfig <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Prometheus
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// 指标配置
type MetricsConfig struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Enabled       bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
        Prometheus    *PrometheusConfig      `protobuf:"bytes,2,opt,name=prometheus,proto3" json:"prometheus,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *MetricsConfig) Reset() <span class="cov0" title="0">{
        *x = MetricsConfig{}
        mi := &amp;file_conf_conf_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *MetricsConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MetricsConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MetricsConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MetricsConfig.ProtoReflect.Descriptor instead.
func (*MetricsConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{9}
}</span>

func (x *MetricsConfig) GetEnabled() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enabled
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *MetricsConfig) GetPrometheus() *PrometheusConfig <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Prometheus
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Jaeger配置
type JaegerConfig struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Enabled       bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
        Endpoint      string                 `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *JaegerConfig) Reset() <span class="cov0" title="0">{
        *x = JaegerConfig{}
        mi := &amp;file_conf_conf_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *JaegerConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*JaegerConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *JaegerConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use JaegerConfig.ProtoReflect.Descriptor instead.
func (*JaegerConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{10}
}</span>

func (x *JaegerConfig) GetEnabled() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enabled
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *JaegerConfig) GetEndpoint() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Endpoint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// OTLP配置
type OtlpConfig struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Enabled       bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
        Endpoint      string                 `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
        Timeout       int32                  `protobuf:"varint,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *OtlpConfig) Reset() <span class="cov0" title="0">{
        *x = OtlpConfig{}
        mi := &amp;file_conf_conf_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *OtlpConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OtlpConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OtlpConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OtlpConfig.ProtoReflect.Descriptor instead.
func (*OtlpConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{11}
}</span>

func (x *OtlpConfig) GetEnabled() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enabled
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *OtlpConfig) GetEndpoint() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Endpoint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *OtlpConfig) GetTimeout() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timeout
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Prometheus配置
type PrometheusConfig struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Enabled       bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
        Endpoint      string                 `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
        Interval      string                 `protobuf:"bytes,3,opt,name=interval,proto3" json:"interval,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PrometheusConfig) Reset() <span class="cov0" title="0">{
        *x = PrometheusConfig{}
        mi := &amp;file_conf_conf_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PrometheusConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PrometheusConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PrometheusConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PrometheusConfig.ProtoReflect.Descriptor instead.
func (*PrometheusConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{12}
}</span>

func (x *PrometheusConfig) GetEnabled() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enabled
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *PrometheusConfig) GetEndpoint() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Endpoint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PrometheusConfig) GetInterval() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Interval
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Auth struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Wpsapp        *Auth_Wpsapp           `protobuf:"bytes,1,opt,name=wpsapp,proto3" json:"wpsapp,omitempty"`
        Dingtalk      *Auth_Dingtalk         `protobuf:"bytes,2,opt,name=dingtalk,proto3" json:"dingtalk,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Auth) Reset() <span class="cov0" title="0">{
        *x = Auth{}
        mi := &amp;file_conf_conf_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Auth) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Auth) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Auth) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Auth.ProtoReflect.Descriptor instead.
func (*Auth) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{13}
}</span>

func (x *Auth) GetWpsapp() *Auth_Wpsapp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Wpsapp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Auth) GetDingtalk() *Auth_Dingtalk <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Dingtalk
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Server_HTTP struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Network       string                 `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
        Addr          string                 `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
        Timeout       *durationpb.Duration   `protobuf:"bytes,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Server_HTTP) Reset() <span class="cov0" title="0">{
        *x = Server_HTTP{}
        mi := &amp;file_conf_conf_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Server_HTTP) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Server_HTTP) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Server_HTTP) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Server_HTTP.ProtoReflect.Descriptor instead.
func (*Server_HTTP) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{1, 0}
}</span>

func (x *Server_HTTP) GetNetwork() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Network
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Server_HTTP) GetAddr() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Addr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Server_HTTP) GetTimeout() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timeout
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Server_GRPC struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Network       string                 `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
        Addr          string                 `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
        Timeout       *durationpb.Duration   `protobuf:"bytes,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Server_GRPC) Reset() <span class="cov0" title="0">{
        *x = Server_GRPC{}
        mi := &amp;file_conf_conf_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Server_GRPC) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Server_GRPC) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Server_GRPC) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Server_GRPC.ProtoReflect.Descriptor instead.
func (*Server_GRPC) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{1, 1}
}</span>

func (x *Server_GRPC) GetNetwork() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Network
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Server_GRPC) GetAddr() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Addr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Server_GRPC) GetTimeout() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timeout
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Data_Database struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        Driver          string                 `protobuf:"bytes,1,opt,name=driver,proto3" json:"driver,omitempty"`
        Source          string                 `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
        MaxOpenConns    int32                  `protobuf:"varint,3,opt,name=max_open_conns,json=maxOpenConns,proto3" json:"max_open_conns,omitempty"`
        MaxIdleConns    int32                  `protobuf:"varint,4,opt,name=max_idle_conns,json=maxIdleConns,proto3" json:"max_idle_conns,omitempty"`
        ConnMaxLifetime string                 `protobuf:"bytes,5,opt,name=conn_max_lifetime,json=connMaxLifetime,proto3" json:"conn_max_lifetime,omitempty"`
        Tag             string                 `protobuf:"bytes,6,opt,name=tag,proto3" json:"tag,omitempty"`
        SourceKey       string                 `protobuf:"bytes,7,opt,name=source_key,json=sourceKey,proto3" json:"source_key,omitempty"`
        Env             string                 `protobuf:"bytes,8,opt,name=env,proto3" json:"env,omitempty"`
        Enable          bool                   `protobuf:"varint,9,opt,name=enable,proto3" json:"enable,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *Data_Database) Reset() <span class="cov0" title="0">{
        *x = Data_Database{}
        mi := &amp;file_conf_conf_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Data_Database) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Data_Database) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Data_Database) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Data_Database.ProtoReflect.Descriptor instead.
func (*Data_Database) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{2, 0}
}</span>

func (x *Data_Database) GetDriver() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Driver
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetSource() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Source
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetMaxOpenConns() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxOpenConns
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_Database) GetMaxIdleConns() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxIdleConns
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_Database) GetConnMaxLifetime() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConnMaxLifetime
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetTag() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetSourceKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SourceKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetEnv() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Env
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetEnable() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enable
        }</span>
        <span class="cov0" title="0">return false</span>
}

type Data_DatabaseSync struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        Driver          string                 `protobuf:"bytes,1,opt,name=driver,proto3" json:"driver,omitempty"`
        Source          string                 `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
        MaxOpenConns    int32                  `protobuf:"varint,3,opt,name=max_open_conns,json=maxOpenConns,proto3" json:"max_open_conns,omitempty"`
        MaxIdleConns    int32                  `protobuf:"varint,4,opt,name=max_idle_conns,json=maxIdleConns,proto3" json:"max_idle_conns,omitempty"`
        ConnMaxLifetime string                 `protobuf:"bytes,5,opt,name=conn_max_lifetime,json=connMaxLifetime,proto3" json:"conn_max_lifetime,omitempty"`
        Tag             string                 `protobuf:"bytes,6,opt,name=tag,proto3" json:"tag,omitempty"`
        SourceKey       string                 `protobuf:"bytes,7,opt,name=source_key,json=sourceKey,proto3" json:"source_key,omitempty"`
        Env             string                 `protobuf:"bytes,8,opt,name=env,proto3" json:"env,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *Data_DatabaseSync) Reset() <span class="cov0" title="0">{
        *x = Data_DatabaseSync{}
        mi := &amp;file_conf_conf_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Data_DatabaseSync) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Data_DatabaseSync) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Data_DatabaseSync) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Data_DatabaseSync.ProtoReflect.Descriptor instead.
func (*Data_DatabaseSync) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{2, 1}
}</span>

func (x *Data_DatabaseSync) GetDriver() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Driver
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_DatabaseSync) GetSource() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Source
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_DatabaseSync) GetMaxOpenConns() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxOpenConns
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_DatabaseSync) GetMaxIdleConns() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxIdleConns
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_DatabaseSync) GetConnMaxLifetime() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConnMaxLifetime
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_DatabaseSync) GetTag() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_DatabaseSync) GetSourceKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SourceKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_DatabaseSync) GetEnv() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Env
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Data_Redis struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Network       string                 `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
        Addr          string                 `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
        Password      string                 `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
        Db            int32                  `protobuf:"varint,4,opt,name=db,proto3" json:"db,omitempty"`
        Enable        bool                   `protobuf:"varint,5,opt,name=enable,proto3" json:"enable,omitempty"`
        ReadTimeout   *durationpb.Duration   `protobuf:"bytes,6,opt,name=read_timeout,json=readTimeout,proto3" json:"read_timeout,omitempty"`
        WriteTimeout  *durationpb.Duration   `protobuf:"bytes,7,opt,name=write_timeout,json=writeTimeout,proto3" json:"write_timeout,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Data_Redis) Reset() <span class="cov0" title="0">{
        *x = Data_Redis{}
        mi := &amp;file_conf_conf_proto_msgTypes[18]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Data_Redis) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Data_Redis) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Data_Redis) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[18]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Data_Redis.ProtoReflect.Descriptor instead.
func (*Data_Redis) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{2, 2}
}</span>

func (x *Data_Redis) GetNetwork() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Network
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Redis) GetAddr() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Addr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Redis) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Redis) GetDb() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Db
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_Redis) GetEnable() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enable
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Data_Redis) GetReadTimeout() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReadTimeout
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Data_Redis) GetWriteTimeout() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.WriteTimeout
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Data_Etcd struct {
        state             protoimpl.MessageState `protogen:"open.v1"`
        Endpoints         []string               `protobuf:"bytes,1,rep,name=endpoints,proto3" json:"endpoints,omitempty"`
        DialTimeout       string                 `protobuf:"bytes,2,opt,name=dial_timeout,json=dialTimeout,proto3" json:"dial_timeout,omitempty"`
        ConfigPrefix      string                 `protobuf:"bytes,3,opt,name=config_prefix,json=configPrefix,proto3" json:"config_prefix,omitempty"`
        EnableConfigWatch bool                   `protobuf:"varint,4,opt,name=enable_config_watch,json=enableConfigWatch,proto3" json:"enable_config_watch,omitempty"`
        Enable            bool                   `protobuf:"varint,5,opt,name=enable,proto3" json:"enable,omitempty"`
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *Data_Etcd) Reset() <span class="cov0" title="0">{
        *x = Data_Etcd{}
        mi := &amp;file_conf_conf_proto_msgTypes[19]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Data_Etcd) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Data_Etcd) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Data_Etcd) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[19]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Data_Etcd.ProtoReflect.Descriptor instead.
func (*Data_Etcd) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{2, 3}
}</span>

func (x *Data_Etcd) GetEndpoints() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Endpoints
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Data_Etcd) GetDialTimeout() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DialTimeout
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Etcd) GetConfigPrefix() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConfigPrefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Etcd) GetEnableConfigWatch() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EnableConfigWatch
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Data_Etcd) GetEnable() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enable
        }</span>
        <span class="cov0" title="0">return false</span>
}

type Auth_Wpsapp struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ClientId      string                 `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
        ClientSecret  string                 `protobuf:"bytes,2,opt,name=client_secret,json=clientSecret,proto3" json:"client_secret,omitempty"`
        AuthUrl       string                 `protobuf:"bytes,3,opt,name=auth_url,json=authUrl,proto3" json:"auth_url,omitempty"`
        AuthPath      string                 `protobuf:"bytes,4,opt,name=auth_path,json=authPath,proto3" json:"auth_path,omitempty"`
        GrantType     string                 `protobuf:"bytes,5,opt,name=grant_type,json=grantType,proto3" json:"grant_type,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Auth_Wpsapp) Reset() <span class="cov0" title="0">{
        *x = Auth_Wpsapp{}
        mi := &amp;file_conf_conf_proto_msgTypes[20]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Auth_Wpsapp) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Auth_Wpsapp) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Auth_Wpsapp) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[20]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Auth_Wpsapp.ProtoReflect.Descriptor instead.
func (*Auth_Wpsapp) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{13, 0}
}</span>

func (x *Auth_Wpsapp) GetClientId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ClientId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth_Wpsapp) GetClientSecret() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ClientSecret
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth_Wpsapp) GetAuthUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth_Wpsapp) GetAuthPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthPath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth_Wpsapp) GetGrantType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GrantType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Auth_Dingtalk struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Endpoint      string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
        AppKey        string                 `protobuf:"bytes,2,opt,name=app_key,json=appKey,proto3" json:"app_key,omitempty"`
        AppSecret     string                 `protobuf:"bytes,3,opt,name=app_secret,json=appSecret,proto3" json:"app_secret,omitempty"`
        Timeout       string                 `protobuf:"bytes,4,opt,name=timeout,proto3" json:"timeout,omitempty"`
        MaxConcurrent int64                  `protobuf:"varint,5,opt,name=maxConcurrent,proto3" json:"maxConcurrent,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Auth_Dingtalk) Reset() <span class="cov0" title="0">{
        *x = Auth_Dingtalk{}
        mi := &amp;file_conf_conf_proto_msgTypes[21]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Auth_Dingtalk) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Auth_Dingtalk) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Auth_Dingtalk) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_conf_conf_proto_msgTypes[21]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Auth_Dingtalk.ProtoReflect.Descriptor instead.
func (*Auth_Dingtalk) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_conf_conf_proto_rawDescGZIP(), []int{13, 1}
}</span>

func (x *Auth_Dingtalk) GetEndpoint() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Endpoint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth_Dingtalk) GetAppKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AppKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth_Dingtalk) GetAppSecret() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AppSecret
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth_Dingtalk) GetTimeout() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timeout
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth_Dingtalk) GetMaxConcurrent() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxConcurrent
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_conf_conf_proto protoreflect.FileDescriptor

const file_conf_conf_proto_rawDesc = "" +
        "\n" +
        "\x0fconf/conf.proto\x12\n" +
        "kratos.api\x1a\x1egoogle/protobuf/duration.proto\"\xd5\x01\n" +
        "\tBootstrap\x12*\n" +
        "\x06server\x18\x01 \x01(\v2\x12.kratos.api.ServerR\x06server\x12$\n" +
        "\x04data\x18\x02 \x01(\v2\x10.kratos.api.DataR\x04data\x12!\n" +
        "\x03app\x18\x03 \x01(\v2\x0f.kratos.api.AppR\x03app\x12$\n" +
        "\x04auth\x18\x04 \x01(\v2\x10.kratos.api.AuthR\x04auth\x12-\n" +
        "\x04otel\x18\x05 \x01(\v2\x19.kratos.api.OpenTelemetryR\x04otel\"\xb8\x02\n" +
        "\x06Server\x12+\n" +
        "\x04http\x18\x01 \x01(\v2\x17.kratos.api.Server.HTTPR\x04http\x12+\n" +
        "\x04grpc\x18\x02 \x01(\v2\x17.kratos.api.Server.GRPCR\x04grpc\x1ai\n" +
        "\x04HTTP\x12\x18\n" +
        "\anetwork\x18\x01 \x01(\tR\anetwork\x12\x12\n" +
        "\x04addr\x18\x02 \x01(\tR\x04addr\x123\n" +
        "\atimeout\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\atimeout\x1ai\n" +
        "\x04GRPC\x12\x18\n" +
        "\anetwork\x18\x01 \x01(\tR\anetwork\x12\x12\n" +
        "\x04addr\x18\x02 \x01(\tR\x04addr\x123\n" +
        "\atimeout\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\atimeout\"\x97\t\n" +
        "\x04Data\x125\n" +
        "\bdatabase\x18\x01 \x01(\v2\x19.kratos.api.Data.DatabaseR\bdatabase\x12B\n" +
        "\rdatabase_sync\x18\x02 \x01(\v2\x1d.kratos.api.Data.DatabaseSyncR\fdatabaseSync\x12,\n" +
        "\x05redis\x18\x03 \x01(\v2\x16.kratos.api.Data.RedisR\x05redis\x12)\n" +
        "\x04etcd\x18\x04 \x01(\v2\x15.kratos.api.Data.EtcdR\x04etcd\x1a\x8d\x02\n" +
        "\bDatabase\x12\x16\n" +
        "\x06driver\x18\x01 \x01(\tR\x06driver\x12\x16\n" +
        "\x06source\x18\x02 \x01(\tR\x06source\x12$\n" +
        "\x0emax_open_conns\x18\x03 \x01(\x05R\fmaxOpenConns\x12$\n" +
        "\x0emax_idle_conns\x18\x04 \x01(\x05R\fmaxIdleConns\x12*\n" +
        "\x11conn_max_lifetime\x18\x05 \x01(\tR\x0fconnMaxLifetime\x12\x10\n" +
        "\x03tag\x18\x06 \x01(\tR\x03tag\x12\x1d\n" +
        "\n" +
        "source_key\x18\a \x01(\tR\tsourceKey\x12\x10\n" +
        "\x03env\x18\b \x01(\tR\x03env\x12\x16\n" +
        "\x06enable\x18\t \x01(\bR\x06enable\x1a\xf9\x01\n" +
        "\fDatabaseSync\x12\x16\n" +
        "\x06driver\x18\x01 \x01(\tR\x06driver\x12\x16\n" +
        "\x06source\x18\x02 \x01(\tR\x06source\x12$\n" +
        "\x0emax_open_conns\x18\x03 \x01(\x05R\fmaxOpenConns\x12$\n" +
        "\x0emax_idle_conns\x18\x04 \x01(\x05R\fmaxIdleConns\x12*\n" +
        "\x11conn_max_lifetime\x18\x05 \x01(\tR\x0fconnMaxLifetime\x12\x10\n" +
        "\x03tag\x18\x06 \x01(\tR\x03tag\x12\x1d\n" +
        "\n" +
        "source_key\x18\a \x01(\tR\tsourceKey\x12\x10\n" +
        "\x03env\x18\b \x01(\tR\x03env\x1a\xf7\x01\n" +
        "\x05Redis\x12\x18\n" +
        "\anetwork\x18\x01 \x01(\tR\anetwork\x12\x12\n" +
        "\x04addr\x18\x02 \x01(\tR\x04addr\x12\x1a\n" +
        "\bpassword\x18\x03 \x01(\tR\bpassword\x12\x0e\n" +
        "\x02db\x18\x04 \x01(\x05R\x02db\x12\x16\n" +
        "\x06enable\x18\x05 \x01(\bR\x06enable\x12&lt;\n" +
        "\fread_timeout\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\vreadTimeout\x12&gt;\n" +
        "\rwrite_timeout\x18\a \x01(\v2\x19.google.protobuf.DurationR\fwriteTimeout\x1a\xb4\x01\n" +
        "\x04Etcd\x12\x1c\n" +
        "\tendpoints\x18\x01 \x03(\tR\tendpoints\x12!\n" +
        "\fdial_timeout\x18\x02 \x01(\tR\vdialTimeout\x12#\n" +
        "\rconfig_prefix\x18\x03 \x01(\tR\fconfigPrefix\x12.\n" +
        "\x13enable_config_watch\x18\x04 \x01(\bR\x11enableConfigWatch\x12\x16\n" +
        "\x06enable\x18\x05 \x01(\bR\x06enable\"\xcb\x03\n" +
        "\x03App\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
        "\x04name\x18\x02 \x01(\tR\x04name\x12\x18\n" +
        "\aversion\x18\x03 \x01(\tR\aversion\x12\x10\n" +
        "\x03env\x18\x04 \x01(\tR\x03env\x12\x1f\n" +
        "\vapp_package\x18\x05 \x01(\tR\n" +
        "appPackage\x12\x15\n" +
        "\x06app_id\x18\x06 \x01(\tR\x05appId\x12\x1d\n" +
        "\n" +
        "app_secret\x18\a \x01(\tR\tappSecret\x12(\n" +
        "\x10third_company_id\x18\b \x01(\tR\x0ethirdCompanyId\x12!\n" +
        "\fplatform_ids\x18\t \x01(\tR\vplatformIds\x12\x1d\n" +
        "\n" +
        "company_id\x18\n" +
        " \x01(\tR\tcompanyId\x12\x1d\n" +
        "\n" +
        "access_key\x18\v \x01(\tR\taccessKey\x12\x1d\n" +
        "\n" +
        "secret_key\x18\f \x01(\tR\tsecretKey\x12\x1d\n" +
        "\n" +
        "batch_size\x18\r \x01(\x05R\tbatchSize\x12\x1f\n" +
        "\vmax_workers\x18\x0e \x01(\x05R\n" +
        "maxWorkers\x12\x1b\n" +
        "\tlog_level\x18\x0f \x01(\tR\blogLevel\x12\x16\n" +
        "\x06logout\x18\x10 \x01(\tR\x06logout\"\xaa\x02\n" +
        "\rOpenTelemetry\x12\x18\n" +
        "\aenabled\x18\x01 \x01(\bR\aenabled\x12!\n" +
        "\fservice_name\x18\x02 \x01(\tR\vserviceName\x12'\n" +
        "\x0fservice_version\x18\x03 \x01(\tR\x0eserviceVersion\x12 \n" +
        "\venvironment\x18\x04 \x01(\tR\venvironment\x120\n" +
        "\x06traces\x18\x05 \x01(\v2\x18.kratos.api.TracesConfigR\x06traces\x123\n" +
        "\ametrics\x18\x06 \x01(\v2\x19.kratos.api.MetricsConfigR\ametrics\x12*\n" +
        "\x04logs\x18\a \x01(\v2\x16.kratos.api.LogsConfigR\x04logs\"\x87\a\n" +
        "\n" +
        "LogsConfig\x12\x18\n" +
        "\aenabled\x18\x01 \x01(\bR\aenabled\x12\x14\n" +
        "\x05level\x18\x02 \x01(\tR\x05level\x12\x16\n" +
        "\x06format\x18\x03 \x01(\tR\x06format\x12\x16\n" +
        "\x06output\x18\x04 \x01(\tR\x06output\x12\x1b\n" +
        "\tfile_path\x18\x05 \x01(\tR\bfilePath\x12\x19\n" +
        "\bmax_size\x18\x06 \x01(\x05R\amaxSize\x12\x1f\n" +
        "\vmax_backups\x18\a \x01(\x05R\n" +
        "maxBackups\x12\x17\n" +
        "\amax_age\x18\b \x01(\x05R\x06maxAge\x12\x1a\n" +
        "\bcompress\x18\t \x01(\bR\bcompress\x12\x16\n" +
        "\x06caller\x18\n" +
        " \x01(\bR\x06caller\x12\x1e\n" +
        "\n" +
        "stacktrace\x18\v \x01(\bR\n" +
        "stacktrace\x12'\n" +
        "\x0fescape_newlines\x18\f \x01(\bR\x0eescapeNewlines\x12'\n" +
        "\x04gorm\x18\r \x01(\v2\x13.kratos.api.GormLogR\x04gorm\x12*\n" +
        "\x04loki\x18\x0e \x01(\v2\x16.kratos.api.LokiConfigR\x04loki\x12\x17\n" +
        "\ause_zap\x18\x0f \x01(\bR\x06useZap\x12'\n" +
        "\x0fzap_development\x18\x10 \x01(\bR\x0ezapDevelopment\x12,\n" +
        "\x12zap_disable_caller\x18\x11 \x01(\bR\x10zapDisableCaller\x124\n" +
        "\x16zap_disable_stacktrace\x18\x12 \x01(\bR\x14zapDisableStacktrace\x12!\n" +
        "\fzap_encoding\x18\x13 \x01(\tR\vzapEncoding\x12 \n" +
        "\fzap_time_key\x18\x14 \x01(\tR\n" +
        "zapTimeKey\x12\"\n" +
        "\rzap_level_key\x18\x15 \x01(\tR\vzapLevelKey\x12 \n" +
        "\fzap_name_key\x18\x16 \x01(\tR\n" +
        "zapNameKey\x12$\n" +
        "\x0ezap_caller_key\x18\x17 \x01(\tR\fzapCallerKey\x12(\n" +
        "\x10zap_function_key\x18\x18 \x01(\tR\x0ezapFunctionKey\x12&amp;\n" +
        "\x0fzap_message_key\x18\x19 \x01(\tR\rzapMessageKey\x12,\n" +
        "\x12zap_stacktrace_key\x18\x1a \x01(\tR\x10zapStacktraceKey\"B\n" +
        "\n" +
        "LokiConfig\x12\x18\n" +
        "\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1a\n" +
        "\bendpoint\x18\x02 \x01(\tR\bendpoint\"M\n" +
        "\aGormLog\x12%\n" +
        "\x0eslow_threshold\x18\x01 \x01(\tR\rslowThreshold\x12\x1b\n" +
        "\tlog_level\x18\x02 \x01(\tR\blogLevel\"\x8e\x03\n" +
        "\fTracesConfig\x12\x18\n" +
        "\aenabled\x18\x01 \x01(\bR\aenabled\x12'\n" +
        "\x0fverbose_logging\x18\x02 \x01(\bR\x0everboseLogging\x12(\n" +
        "\x10log_request_size\x18\x03 \x01(\bR\x0elogRequestSize\x12*\n" +
        "\x11log_response_size\x18\x04 \x01(\bR\x0flogResponseSize\x12\x1f\n" +
        "\vlog_headers\x18\x05 \x01(\bR\n" +
        "logHeaders\x12(\n" +
        "\x10log_query_params\x18\x06 \x01(\bR\x0elogQueryParams\x120\n" +
        "\x06jaeger\x18\a \x01(\v2\x18.kratos.api.JaegerConfigR\x06jaeger\x12*\n" +
        "\x04otlp\x18\b \x01(\v2\x16.kratos.api.OtlpConfigR\x04otlp\x12&lt;\n" +
        "\n" +
        "prometheus\x18\t \x01(\v2\x1c.kratos.api.PrometheusConfigR\n" +
        "prometheus\"g\n" +
        "\rMetricsConfig\x12\x18\n" +
        "\aenabled\x18\x01 \x01(\bR\aenabled\x12&lt;\n" +
        "\n" +
        "prometheus\x18\x02 \x01(\v2\x1c.kratos.api.PrometheusConfigR\n" +
        "prometheus\"D\n" +
        "\fJaegerConfig\x12\x18\n" +
        "\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1a\n" +
        "\bendpoint\x18\x02 \x01(\tR\bendpoint\"\\\n" +
        "\n" +
        "OtlpConfig\x12\x18\n" +
        "\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1a\n" +
        "\bendpoint\x18\x02 \x01(\tR\bendpoint\x12\x18\n" +
        "\atimeout\x18\x03 \x01(\x05R\atimeout\"d\n" +
        "\x10PrometheusConfig\x12\x18\n" +
        "\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1a\n" +
        "\bendpoint\x18\x02 \x01(\tR\bendpoint\x12\x1a\n" +
        "\binterval\x18\x03 \x01(\tR\binterval\"\xb3\x03\n" +
        "\x04Auth\x12/\n" +
        "\x06wpsapp\x18\x01 \x01(\v2\x17.kratos.api.Auth.WpsappR\x06wpsapp\x125\n" +
        "\bdingtalk\x18\x02 \x01(\v2\x19.kratos.api.Auth.DingtalkR\bdingtalk\x1a\xa1\x01\n" +
        "\x06Wpsapp\x12\x1b\n" +
        "\tclient_id\x18\x01 \x01(\tR\bclientId\x12#\n" +
        "\rclient_secret\x18\x02 \x01(\tR\fclientSecret\x12\x19\n" +
        "\bauth_url\x18\x03 \x01(\tR\aauthUrl\x12\x1b\n" +
        "\tauth_path\x18\x04 \x01(\tR\bauthPath\x12\x1d\n" +
        "\n" +
        "grant_type\x18\x05 \x01(\tR\tgrantType\x1a\x9e\x01\n" +
        "\bDingtalk\x12\x1a\n" +
        "\bendpoint\x18\x01 \x01(\tR\bendpoint\x12\x17\n" +
        "\aapp_key\x18\x02 \x01(\tR\x06appKey\x12\x1d\n" +
        "\n" +
        "app_secret\x18\x03 \x01(\tR\tappSecret\x12\x18\n" +
        "\atimeout\x18\x04 \x01(\tR\atimeout\x12$\n" +
        "\rmaxConcurrent\x18\x05 \x01(\x03R\rmaxConcurrentB\x1eZ\x1cnancalacc/internal/conf;confb\x06proto3"

var (
        file_conf_conf_proto_rawDescOnce sync.Once
        file_conf_conf_proto_rawDescData []byte
)

func file_conf_conf_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_conf_conf_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_conf_conf_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_conf_conf_proto_rawDesc), len(file_conf_conf_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_conf_conf_proto_rawDescData</span>
}

var file_conf_conf_proto_msgTypes = make([]protoimpl.MessageInfo, 22)
var file_conf_conf_proto_goTypes = []any{
        (*Bootstrap)(nil),           // 0: kratos.api.Bootstrap
        (*Server)(nil),              // 1: kratos.api.Server
        (*Data)(nil),                // 2: kratos.api.Data
        (*App)(nil),                 // 3: kratos.api.App
        (*OpenTelemetry)(nil),       // 4: kratos.api.OpenTelemetry
        (*LogsConfig)(nil),          // 5: kratos.api.LogsConfig
        (*LokiConfig)(nil),          // 6: kratos.api.LokiConfig
        (*GormLog)(nil),             // 7: kratos.api.GormLog
        (*TracesConfig)(nil),        // 8: kratos.api.TracesConfig
        (*MetricsConfig)(nil),       // 9: kratos.api.MetricsConfig
        (*JaegerConfig)(nil),        // 10: kratos.api.JaegerConfig
        (*OtlpConfig)(nil),          // 11: kratos.api.OtlpConfig
        (*PrometheusConfig)(nil),    // 12: kratos.api.PrometheusConfig
        (*Auth)(nil),                // 13: kratos.api.Auth
        (*Server_HTTP)(nil),         // 14: kratos.api.Server.HTTP
        (*Server_GRPC)(nil),         // 15: kratos.api.Server.GRPC
        (*Data_Database)(nil),       // 16: kratos.api.Data.Database
        (*Data_DatabaseSync)(nil),   // 17: kratos.api.Data.DatabaseSync
        (*Data_Redis)(nil),          // 18: kratos.api.Data.Redis
        (*Data_Etcd)(nil),           // 19: kratos.api.Data.Etcd
        (*Auth_Wpsapp)(nil),         // 20: kratos.api.Auth.Wpsapp
        (*Auth_Dingtalk)(nil),       // 21: kratos.api.Auth.Dingtalk
        (*durationpb.Duration)(nil), // 22: google.protobuf.Duration
}
var file_conf_conf_proto_depIdxs = []int32{
        1,  // 0: kratos.api.Bootstrap.server:type_name -&gt; kratos.api.Server
        2,  // 1: kratos.api.Bootstrap.data:type_name -&gt; kratos.api.Data
        3,  // 2: kratos.api.Bootstrap.app:type_name -&gt; kratos.api.App
        13, // 3: kratos.api.Bootstrap.auth:type_name -&gt; kratos.api.Auth
        4,  // 4: kratos.api.Bootstrap.otel:type_name -&gt; kratos.api.OpenTelemetry
        14, // 5: kratos.api.Server.http:type_name -&gt; kratos.api.Server.HTTP
        15, // 6: kratos.api.Server.grpc:type_name -&gt; kratos.api.Server.GRPC
        16, // 7: kratos.api.Data.database:type_name -&gt; kratos.api.Data.Database
        17, // 8: kratos.api.Data.database_sync:type_name -&gt; kratos.api.Data.DatabaseSync
        18, // 9: kratos.api.Data.redis:type_name -&gt; kratos.api.Data.Redis
        19, // 10: kratos.api.Data.etcd:type_name -&gt; kratos.api.Data.Etcd
        8,  // 11: kratos.api.OpenTelemetry.traces:type_name -&gt; kratos.api.TracesConfig
        9,  // 12: kratos.api.OpenTelemetry.metrics:type_name -&gt; kratos.api.MetricsConfig
        5,  // 13: kratos.api.OpenTelemetry.logs:type_name -&gt; kratos.api.LogsConfig
        7,  // 14: kratos.api.LogsConfig.gorm:type_name -&gt; kratos.api.GormLog
        6,  // 15: kratos.api.LogsConfig.loki:type_name -&gt; kratos.api.LokiConfig
        10, // 16: kratos.api.TracesConfig.jaeger:type_name -&gt; kratos.api.JaegerConfig
        11, // 17: kratos.api.TracesConfig.otlp:type_name -&gt; kratos.api.OtlpConfig
        12, // 18: kratos.api.TracesConfig.prometheus:type_name -&gt; kratos.api.PrometheusConfig
        12, // 19: kratos.api.MetricsConfig.prometheus:type_name -&gt; kratos.api.PrometheusConfig
        20, // 20: kratos.api.Auth.wpsapp:type_name -&gt; kratos.api.Auth.Wpsapp
        21, // 21: kratos.api.Auth.dingtalk:type_name -&gt; kratos.api.Auth.Dingtalk
        22, // 22: kratos.api.Server.HTTP.timeout:type_name -&gt; google.protobuf.Duration
        22, // 23: kratos.api.Server.GRPC.timeout:type_name -&gt; google.protobuf.Duration
        22, // 24: kratos.api.Data.Redis.read_timeout:type_name -&gt; google.protobuf.Duration
        22, // 25: kratos.api.Data.Redis.write_timeout:type_name -&gt; google.protobuf.Duration
        26, // [26:26] is the sub-list for method output_type
        26, // [26:26] is the sub-list for method input_type
        26, // [26:26] is the sub-list for extension type_name
        26, // [26:26] is the sub-list for extension extendee
        0,  // [0:26] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_conf_conf_proto_init() }</span>
func file_conf_conf_proto_init() <span class="cov0" title="0">{
        if File_conf_conf_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_conf_conf_proto_rawDesc), len(file_conf_conf_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   22,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_conf_conf_proto_goTypes,
                DependencyIndexes: file_conf_conf_proto_depIdxs,
                MessageInfos:      file_conf_conf_proto_msgTypes,
        }.Build()
        File_conf_conf_proto = out.File
        file_conf_conf_proto_goTypes = nil
        file_conf_conf_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package conf

import (
        "fmt"
        "os"
        "sync"

        "github.com/go-kratos/kratos/v2/config"
        "github.com/go-kratos/kratos/v2/config/env"
        "github.com/go-kratos/kratos/v2/log"
)

var (
        envConfig config.Config
        onceEnv   sync.Once
        logger    log.Logger
)

// InitEnvConfig 初始化环境变量配置
func InitEnvConfig(l log.Logger) <span class="cov0" title="0">{
        logger = l
}</span>

// GetEnv 获取环境变量值，支持默认值
func GetEnv(key string) (string, error) <span class="cov0" title="0">{
        // 首先尝试从系统环境变量获取
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value, nil
        }</span>

        // 如果系统环境变量不存在，尝试从配置的环境变量源获取
        <span class="cov0" title="0">onceEnv.Do(func() </span><span class="cov0" title="0">{
                envSource := env.NewSource()
                envConfig = config.New(
                        config.WithSource(envSource),
                )
                if err := envConfig.Load(); err != nil </span><span class="cov0" title="0">{
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(log.LevelError, "failed to load env config", "error", err)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        })

        <span class="cov0" title="0">if envConfig == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("environment variable %s not found", key)
        }</span>

        <span class="cov0" title="0">value := envConfig.Value(key)
        if value == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("environment variable %s not found", key)
        }</span>

        <span class="cov0" title="0">str, err := value.String()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get string value for %s: %w", key, err)
        }</span>
        <span class="cov0" title="0">return str, nil</span>
}

// GetEnvWithDefault 获取环境变量值，如果不存在则返回默认值
func GetEnvWithDefault(key, defaultValue string) string <span class="cov0" title="0">{
        value, err := GetEnv(key)
        if err != nil </span><span class="cov0" title="0">{
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(log.LevelWarn, "environment variable not found, using default",
                                "key", key, "default", defaultValue, "error", err)
                }</span>
                <span class="cov0" title="0">return defaultValue</span>
        }
        <span class="cov0" title="0">return value</span>
}

// MustGetEnv 获取环境变量值，如果不存在则panic
func MustGetEnv(key string) string <span class="cov0" title="0">{
        value, err := GetEnv(key)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("required environment variable %s not found: %v", key, err))</span>
        }
        <span class="cov0" title="0">return value</span>
}

// ValidateRequiredEnvVars 验证必需的环境变量是否存在
func ValidateRequiredEnvVars(requiredKeys []string) error <span class="cov0" title="0">{
        var missingKeys []string

        for _, key := range requiredKeys </span><span class="cov0" title="0">{
                if _, err := GetEnv(key); err != nil </span><span class="cov0" title="0">{
                        missingKeys = append(missingKeys, key)
                }</span>
        }

        <span class="cov0" title="0">if len(missingKeys) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing required environment variables: %v", missingKeys)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package conf

import (
        "fmt"
        "log"
)

// ExampleUsage 展示如何正确使用配置系统
func ExampleUsage() <span class="cov0" title="0">{
        // 1. 加载应用配置（使用conf.Load()）
        // 这会加载配置文件和环境变量（KRATOS_前缀）
        bootstrap, err := Load("configs/config.yaml")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>

        // 2. 获取应用配置
        <span class="cov0" title="0">fmt.Printf("Server HTTP Address: %s\n", bootstrap.Server.Http.Addr)
        fmt.Printf("Database Source: %s\n", bootstrap.Data.Database.Source)

        // 3. 获取运行时环境变量（使用envvars.go）
        // 这些变量不需要映射到配置结构，只需要在运行时获取

        // 获取加密盐值
        salt, err := GetEnv("ENCRYPTION_SALT")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: ENCRYPTION_SALT not found: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Encryption Salt: %s\n", salt)
        }</span>

        // 获取带默认值的环境变量
        <span class="cov0" title="0">appUID := GetEnvWithDefault("APP_UID", "nancalacc-default")
        fmt.Printf("App UID: %s\n", appUID)

        // 获取普通环境变量
        dbSource, err := GetEnv("DATABASE_SOURCE")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: DATABASE_SOURCE not found: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Database Source: %s\n", dbSource)
        }</span>

        // 4. 验证必需的环境变量
        <span class="cov0" title="0">requiredVars := []string{"ENCRYPTION_SALT", "APP_SECRET"}
        if err := ValidateRequiredEnvVars(requiredVars); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Missing required environment variables: %v", err)
        }</span>
}

// 环境变量使用指南：
//
// 1. 应用配置（使用conf.Load()）：
//    - 服务器配置、数据库配置等
//    - 只从配置文件加载，不支持环境变量覆盖
//    - 例如：configs/config.yaml
//
// 2. 运行时环境变量（使用envvars.go）：
//    - 加密密钥、API密钥等敏感信息
//    - 不需要映射到配置结构
//    - 例如：ENCRYPTION_SALT=my-secret-salt
//
// 3. 环境变量优先级：
//    - 系统环境变量 &gt; 配置文件
//
// 4. 最佳实践：
//    - 敏感信息使用环境变量
//    - 应用配置使用配置文件
//    - 开发环境使用默认值
//    - 生产环境使用必需变量验证
</pre>
		
		<pre class="file" id="file18" style="display: none">package conf

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "path/filepath"
        "strings"
        "sync"
        "time"

        etcdConfig "github.com/go-kratos/kratos/contrib/config/etcd/v2"
        "gopkg.in/yaml.v3"

        "github.com/go-kratos/kratos/v2/config"
        "github.com/go-kratos/kratos/v2/config/env"
        "github.com/go-kratos/kratos/v2/config/file"
        "github.com/go-kratos/kratos/v2/log"
        "github.com/google/go-cmp/cmp"
        clientv3 "go.etcd.io/etcd/client/v3"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/testing/protocmp"
)

var (
        globalConf  *Bootstrap
        confLock    sync.RWMutex
        once        sync.Once
        etcdClient  *clientv3.Client // 全局ETCD客户端
        etcdSource  config.Source    // 全局ETCD配置源
        cancelWatch context.CancelFunc
)

// Load loads the configuration from file and etcd.
func Load(configPath string) (*Bootstrap, error) <span class="cov0" title="0">{
        var loadErr error
        once.Do(func() </span><span class="cov0" title="0">{
                // 1. 首先加载文件配置
                fileConf, err := loadFileConfig(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        loadErr = err
                        return
                }</span>

                // 2. 如果配置了ETCD，尝试加载ETCD配置
                <span class="cov0" title="0">if fileConf.Data != nil &amp;&amp; fileConf.Data.Etcd != nil &amp;&amp; fileConf.Data.Etcd.Enable &amp;&amp; len(fileConf.Data.Etcd.Endpoints) &gt; 0 </span><span class="cov0" title="0">{
                        etcdConf, cli, src, err := loadEtcdConfig(fileConf)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Warnf("Failed to load etcd config: %v, using file config only", err)
                                setGlobalConfig(fileConf)
                                return
                        }</span>

                        // 保存ETCD客户端和source
                        <span class="cov0" title="0">etcdClient = cli
                        etcdSource = src

                        // 3. 合并配置(ETCD配置优先)
                        merged := mergeConfigs(fileConf, etcdConf)
                        setGlobalConfig(merged)

                        // 4. 如果启用配置监听，启动监听协程
                        if fileConf.Data.Etcd.EnableConfigWatch </span><span class="cov0" title="0">{
                                ctx, cancel := context.WithCancel(context.Background())
                                cancelWatch = cancel
                                go watchEtcdConfigChanges(ctx, src, merged)
                        }</span>
                } else<span class="cov0" title="0"> {
                        setGlobalConfig(fileConf)
                }</span>
        })

        <span class="cov0" title="0">if loadErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load configuration: %w", loadErr)
        }</span>

        <span class="cov0" title="0">return Get(), nil</span>
}

// Close 释放资源
func Close() <span class="cov0" title="0">{
        if cancelWatch != nil </span><span class="cov0" title="0">{
                cancelWatch()
        }</span>
        <span class="cov0" title="0">if etcdClient != nil </span><span class="cov0" title="0">{
                etcdClient.Close()
        }</span>
}

// loadFileConfig 从文件加载配置
func loadFileConfig(configPath string) (*Bootstrap, error) <span class="cov0" title="0">{
        fmt.Printf("load file config: %s\n", configPath)
        fileSource := file.NewSource(configPath)
        fileConf := config.New(
                config.WithSource(
                        fileSource,
                        env.NewSource("KRATOS_"), // 支持环境变量覆盖
                ),
        )

        if err := fileConf.Load(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load file config: %w", err)
        }</span>

        <span class="cov0" title="0">var bc Bootstrap
        if err := fileConf.Scan(&amp;bc); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to scan file config: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;bc, nil</span>
}

// loadEtcdConfig 从ETCD加载配置，返回配置、客户端和source
func loadEtcdConfig(baseConf *Bootstrap) (*Bootstrap, *clientv3.Client, config.Source, error) <span class="cov0" title="0">{
        fmt.Printf("load etcd config: %+vv\n", baseConf.Data.Etcd)
        // 1. 创建ETCD客户端
        cli, err := clientv3.New(clientv3.Config{
                Endpoints:   baseConf.Data.Etcd.Endpoints,
                DialTimeout: parseDurationToTime(baseConf.Data.Etcd.DialTimeout),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("create etcd client failed: %w", err)
        }</span>
        // 2. 创建ETCD配置源
        <span class="cov0" title="0">source, err := etcdConfig.New(cli,
                etcdConfig.WithPath(baseConf.Data.Etcd.ConfigPrefix),
                etcdConfig.WithPrefix(true),
        )
        if err != nil </span><span class="cov0" title="0">{
                cli.Close() // 创建失败时关闭客户端
                return nil, nil, nil, fmt.Errorf("create etcd config source failed: %w", err)
        }</span>

        // 3. 加载配置
        <span class="cov0" title="0">conf := config.New(config.WithSource(source))
        if err := conf.Load(); err != nil </span><span class="cov0" title="0">{
                cli.Close() // 加载失败时关闭客户端
                return nil, nil, nil, fmt.Errorf("load etcd config failed: %w", err)
        }</span>

        <span class="cov0" title="0">var etcdBc Bootstrap
        if err := conf.Scan(&amp;etcdBc); err != nil </span><span class="cov0" title="0">{
                cli.Close() // 解析失败时关闭客户端
                return nil, nil, nil, fmt.Errorf("scan etcd config failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;etcdBc, cli, source, nil</span>
}

// watchEtcdConfigChanges 监听ETCD配置变更
func watchEtcdConfigChanges(ctx context.Context, source config.Source, baseConf *Bootstrap) <span class="cov0" title="0">{
        log.Info("watchEtcdConfigChanges watcher start")

        defer log.Info("[TEST] ETCD watcher exit")
        watcher, err := source.Watch()
        log.Infof("watcher: %+v, err: %+v", watcher, err)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to create config watcher: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer watcher.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Info("Config watcher stopped by context")
                        return</span>
                default:<span class="cov0" title="0">
                        log.Debug("Waiting for next config change...")
                        values, err := watcher.Next()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("watchEtcdConfigChanges watcher err: %+v", err)
                                if errors.Is(err, context.Canceled) </span><span class="cov0" title="0">{
                                        log.Info("Config watcher stopped normally")
                                        return
                                }</span>
                                <span class="cov0" title="0">log.Errorf("Failed to watch next config: %v", err)
                                // select {
                                // case &lt;-time.After(5 * time.Second): // 带退避的重试
                                // case &lt;-ctx.Done():
                                //         return
                                // }
                                continue</span>
                        }
                        <span class="cov0" title="0">log.Debugf("[TEST] 收到变更事件:\nKey: %s\nValue: %s\nVersion: %d",
                                string(values[0].Key),
                                string(values[0].Value), 100)
                        var etcdBc Bootstrap
                        if err := unmarshalKeyValues(values, &amp;etcdBc); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("Failed to scan changed config: %v", err)
                                continue</span>
                        }

                        // 合并配置并原子更新
                        <span class="cov0" title="0">merged := mergeConfigs(baseConf, &amp;etcdBc)
                        setGlobalConfig(merged)
                        log.Info("Configuration updated from etcd")
                        log.Infof("Global config updated changes: %s", diffConfigs(baseConf, &amp;etcdBc))</span> // 变更差异日志
                }
        }
}

func diffConfigs(old, new *Bootstrap) string <span class="cov0" title="0">{
        return cmp.Diff(old, new, protocmp.Transform())
}</span>

// etcdctl put /configs/app.json '{"server":{"port":8080}}'
func unmarshalKeyValues(kvs []*config.KeyValue, target interface{}) error <span class="cov0" title="0">{
        if len(kvs) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("empty config values")
        }</span>
        <span class="cov0" title="0">ext := filepath.Ext(kvs[0].Key)        // 获取后缀如 ".json"
        format := strings.TrimPrefix(ext, ".") // 去掉点

        if len(format) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported format: %s", format)
        }</span>
        // format := strings.ToLower(kvs[0].Format)
        <span class="cov0" title="0">data := kvs[0].Value
        switch format </span>{
        case "json":<span class="cov0" title="0">
                if err := json.Unmarshal(data, target); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("json unmarshal failed: %w", err)
                }</span>
        case "yaml":<span class="cov0" title="0">
                if err := yaml.Unmarshal(data, target); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("yaml unmarshal failed: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported format: %s", format)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// setGlobalConfig 线程安全地设置全局配置
func setGlobalConfig(conf *Bootstrap) <span class="cov0" title="0">{
        confLock.Lock()
        defer confLock.Unlock()
        globalConf = conf
}</span>

// Get 线程安全地获取全局配置
func Get() *Bootstrap <span class="cov0" title="0">{
        confLock.RLock()
        defer confLock.RUnlock()
        return globalConf
}</span>

// parseDurationToTime 将字符串持续时间转换为time.Duration
func parseDurationToTime(durStr string) time.Duration <span class="cov0" title="0">{
        if durStr == "" </span><span class="cov0" title="0">{
                return 5 * time.Second // 默认超时时间
        }</span>
        <span class="cov0" title="0">d, err := time.ParseDuration(durStr)
        if err != nil </span><span class="cov0" title="0">{
                return 5 * time.Second // 默认超时时间
        }</span>
        <span class="cov0" title="0">return d</span>
}

// mergeConfigs merges two configurations with etcdConfig taking precedence
func mergeConfigs(fileConfig, etcdConfig *Bootstrap) *Bootstrap <span class="cov0" title="0">{
        // Create a deep copy of the file config
        merged := proto.Clone(fileConfig).(*Bootstrap)

        // Merge logic for each section
        if etcdConfig.Server != nil </span><span class="cov0" title="0">{
                if merged.Server == nil </span><span class="cov0" title="0">{
                        merged.Server = &amp;Server{}
                }</span>
                <span class="cov0" title="0">mergeServer(merged.Server, etcdConfig.Server)</span>
        }

        <span class="cov0" title="0">if etcdConfig.Data != nil </span><span class="cov0" title="0">{
                if merged.Data == nil </span><span class="cov0" title="0">{
                        merged.Data = &amp;Data{}
                }</span>
                <span class="cov0" title="0">mergeData(merged.Data, etcdConfig.Data)</span>
        }

        <span class="cov0" title="0">if etcdConfig.App != nil </span><span class="cov0" title="0">{
                if merged.App == nil </span><span class="cov0" title="0">{
                        merged.App = &amp;App{}
                }</span>
                <span class="cov0" title="0">mergeApp(merged.App, etcdConfig.App)</span>
        }

        <span class="cov0" title="0">return merged</span>
}

// Helper functions to merge each configuration section
func mergeServer(dst, src *Server) <span class="cov0" title="0">{
        if src.Http != nil </span><span class="cov0" title="0">{
                if dst.Http == nil </span><span class="cov0" title="0">{
                        dst.Http = &amp;Server_HTTP{}
                }</span>
                <span class="cov0" title="0">if src.Http.Network != "" </span><span class="cov0" title="0">{
                        dst.Http.Network = src.Http.Network
                }</span>
                <span class="cov0" title="0">if src.Http.Addr != "" </span><span class="cov0" title="0">{
                        dst.Http.Addr = src.Http.Addr
                }</span>
                <span class="cov0" title="0">if src.Http.Timeout != nil </span><span class="cov0" title="0">{
                        dst.Http.Timeout = src.Http.Timeout
                }</span>
        }
        <span class="cov0" title="0">if src.Grpc != nil </span><span class="cov0" title="0">{
                if dst.Grpc == nil </span><span class="cov0" title="0">{
                        dst.Grpc = &amp;Server_GRPC{}
                }</span>
                <span class="cov0" title="0">if src.Grpc.Network != "" </span><span class="cov0" title="0">{
                        dst.Grpc.Network = src.Grpc.Network
                }</span>
                <span class="cov0" title="0">if src.Grpc.Addr != "" </span><span class="cov0" title="0">{
                        dst.Grpc.Addr = src.Grpc.Addr
                }</span>
                <span class="cov0" title="0">if src.Grpc.Timeout != nil </span><span class="cov0" title="0">{
                        dst.Grpc.Timeout = src.Grpc.Timeout
                }</span>
        }
}

func mergeData(dst, src *Data) <span class="cov0" title="0">{
        if src.Database != nil </span><span class="cov0" title="0">{
                if dst.Database == nil </span><span class="cov0" title="0">{
                        dst.Database = &amp;Data_Database{}
                }</span>
                <span class="cov0" title="0">if src.Database.Driver != "" </span><span class="cov0" title="0">{
                        dst.Database.Driver = src.Database.Driver
                }</span>
                <span class="cov0" title="0">if src.Database.Source != "" </span><span class="cov0" title="0">{
                        dst.Database.Source = src.Database.Source
                }</span>
                <span class="cov0" title="0">if src.Database.Tag != "" </span><span class="cov0" title="0">{
                        dst.Database.Tag = src.Database.Tag
                }</span>
        }
        <span class="cov0" title="0">if src.DatabaseSync != nil </span><span class="cov0" title="0">{
                if dst.DatabaseSync == nil </span><span class="cov0" title="0">{
                        dst.DatabaseSync = &amp;Data_DatabaseSync{}
                }</span>
                <span class="cov0" title="0">if src.DatabaseSync.Driver != "" </span><span class="cov0" title="0">{
                        dst.DatabaseSync.Driver = src.DatabaseSync.Driver
                }</span>
                <span class="cov0" title="0">if src.DatabaseSync.Source != "" </span><span class="cov0" title="0">{
                        dst.DatabaseSync.Source = src.DatabaseSync.Source
                }</span>
                <span class="cov0" title="0">if src.DatabaseSync.Tag != "" </span><span class="cov0" title="0">{
                        dst.DatabaseSync.Tag = src.DatabaseSync.Tag
                }</span>
                <span class="cov0" title="0">if src.DatabaseSync.MaxOpenConns != 0 </span><span class="cov0" title="0">{
                        dst.DatabaseSync.MaxOpenConns = src.DatabaseSync.MaxOpenConns
                }</span>
                <span class="cov0" title="0">if src.DatabaseSync.MaxIdleConns != 0 </span><span class="cov0" title="0">{
                        dst.DatabaseSync.MaxIdleConns = src.DatabaseSync.MaxIdleConns
                }</span>
                <span class="cov0" title="0">if src.DatabaseSync.SourceKey != "" </span><span class="cov0" title="0">{
                        dst.DatabaseSync.SourceKey = src.DatabaseSync.SourceKey
                }</span>
        }
        <span class="cov0" title="0">if src.Redis != nil </span><span class="cov0" title="0">{
                if dst.Redis == nil </span><span class="cov0" title="0">{
                        dst.Redis = &amp;Data_Redis{}
                }</span>
                <span class="cov0" title="0">if src.Redis.Network != "" </span><span class="cov0" title="0">{
                        dst.Redis.Network = src.Redis.Network
                }</span>
                <span class="cov0" title="0">if src.Redis.Addr != "" </span><span class="cov0" title="0">{
                        dst.Redis.Addr = src.Redis.Addr
                }</span>
                <span class="cov0" title="0">if src.Redis.Password != "" </span><span class="cov0" title="0">{
                        dst.Redis.Password = src.Redis.Password
                }</span>
                <span class="cov0" title="0">if src.Redis.Db != 0 </span><span class="cov0" title="0">{
                        dst.Redis.Db = src.Redis.Db
                }</span>
                <span class="cov0" title="0">if src.Redis.ReadTimeout != nil </span><span class="cov0" title="0">{
                        dst.Redis.ReadTimeout = src.Redis.ReadTimeout
                }</span>
                <span class="cov0" title="0">if src.Redis.WriteTimeout != nil </span><span class="cov0" title="0">{
                        dst.Redis.WriteTimeout = src.Redis.WriteTimeout
                }</span>
        }
        <span class="cov0" title="0">if src.Etcd != nil </span><span class="cov0" title="0">{
                if dst.Etcd == nil </span><span class="cov0" title="0">{
                        dst.Etcd = &amp;Data_Etcd{}
                }</span>
                <span class="cov0" title="0">if len(src.Etcd.Endpoints) &gt; 0 </span><span class="cov0" title="0">{
                        dst.Etcd.Endpoints = src.Etcd.Endpoints
                }</span>
                <span class="cov0" title="0">if src.Etcd.DialTimeout != "" </span><span class="cov0" title="0">{
                        dst.Etcd.DialTimeout = src.Etcd.DialTimeout
                }</span>
                <span class="cov0" title="0">if src.Etcd.ConfigPrefix != "" </span><span class="cov0" title="0">{
                        dst.Etcd.ConfigPrefix = src.Etcd.ConfigPrefix
                }</span>
                <span class="cov0" title="0">dst.Etcd.EnableConfigWatch = src.Etcd.EnableConfigWatch</span>
        }
}

func mergeApp(dst, src *App) <span class="cov0" title="0">{
        if src.Id != "" </span><span class="cov0" title="0">{
                dst.Id = src.Id
        }</span>
        <span class="cov0" title="0">if src.Name != "" </span><span class="cov0" title="0">{
                dst.Name = src.Name
        }</span>
        <span class="cov0" title="0">if src.Version != "" </span><span class="cov0" title="0">{
                dst.Version = src.Version
        }</span>
        <span class="cov0" title="0">if src.Env != "" </span><span class="cov0" title="0">{
                dst.Env = src.Env
        }</span>
        // LogLevel and LogOut are now in OpenTelemetry.Logs
        <span class="cov0" title="0">if src.AppPackage != "" </span><span class="cov0" title="0">{
                dst.AppPackage = src.AppPackage
        }</span>
        <span class="cov0" title="0">if src.AppId != "" </span><span class="cov0" title="0">{
                dst.AppId = src.AppId
        }</span>
        <span class="cov0" title="0">if src.AppSecret != "" </span><span class="cov0" title="0">{
                dst.AppSecret = src.AppSecret
        }</span>
        <span class="cov0" title="0">if src.ThirdCompanyId != "" </span><span class="cov0" title="0">{
                dst.ThirdCompanyId = src.ThirdCompanyId
        }</span>
        <span class="cov0" title="0">if src.PlatformIds != "" </span><span class="cov0" title="0">{
                dst.PlatformIds = src.PlatformIds
        }</span>
        <span class="cov0" title="0">if src.CompanyId != "" </span><span class="cov0" title="0">{
                dst.CompanyId = src.CompanyId
        }</span>
        <span class="cov0" title="0">if src.AccessKey != "" </span><span class="cov0" title="0">{
                dst.AccessKey = src.AccessKey
        }</span>
        <span class="cov0" title="0">if src.SecretKey != "" </span><span class="cov0" title="0">{
                dst.SecretKey = src.SecretKey
        }</span>
}

func mergeAuth(dst, src *Auth) <span class="cov0" title="0">{
        if src.Wpsapp != nil </span><span class="cov0" title="0">{
                if dst.Wpsapp == nil </span><span class="cov0" title="0">{
                        dst.Wpsapp = &amp;Auth_Wpsapp{}
                }</span>
                <span class="cov0" title="0">if src.Wpsapp.ClientId != "" </span><span class="cov0" title="0">{
                        dst.Wpsapp.ClientId = src.Wpsapp.ClientId
                }</span>
                <span class="cov0" title="0">if src.Wpsapp.ClientSecret != "" </span><span class="cov0" title="0">{
                        dst.Wpsapp.ClientSecret = src.Wpsapp.ClientSecret
                }</span>
                <span class="cov0" title="0">if src.Wpsapp.AuthUrl != "" </span><span class="cov0" title="0">{
                        dst.Wpsapp.AuthUrl = src.Wpsapp.AuthUrl
                }</span>
                <span class="cov0" title="0">if src.Wpsapp.AuthPath != "" </span><span class="cov0" title="0">{
                        dst.Wpsapp.AuthPath = src.Wpsapp.AuthPath
                }</span>
        }
        <span class="cov0" title="0">if src.Dingtalk != nil </span><span class="cov0" title="0">{
                if dst.Dingtalk == nil </span><span class="cov0" title="0">{
                        dst.Dingtalk = &amp;Auth_Dingtalk{}
                }</span>
                <span class="cov0" title="0">if src.Dingtalk.Endpoint != "" </span><span class="cov0" title="0">{
                        dst.Dingtalk.Endpoint = src.Dingtalk.Endpoint
                }</span>
                <span class="cov0" title="0">if src.Dingtalk.AppKey != "" </span><span class="cov0" title="0">{
                        dst.Dingtalk.AppKey = src.Dingtalk.AppKey
                }</span>
                <span class="cov0" title="0">if src.Dingtalk.AppSecret != "" </span><span class="cov0" title="0">{
                        dst.Dingtalk.AppSecret = src.Dingtalk.AppSecret
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package conf

import (
        "fmt"
        "net"
        "net/url"
        "time"

        "github.com/go-kratos/kratos/v2/log"
)

// ConfigValidator 配置验证器
type ConfigValidator struct {
        logger log.Logger
}

// NewConfigValidator 创建新的配置验证器
func NewConfigValidator(l log.Logger) *ConfigValidator <span class="cov0" title="0">{
        return &amp;ConfigValidator{
                logger: l,
        }
}</span>

// ValidateBootstrap 验证Bootstrap配置
func (v *ConfigValidator) ValidateBootstrap(b *Bootstrap) error <span class="cov0" title="0">{
        if err := v.validateServer(b.Server); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("server config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if err := v.validateData(b.Data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("data config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if err := v.validateApp(b.App); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("app config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if err := v.validateAuth(b.Auth); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("auth config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateServer 验证服务器配置
func (v *ConfigValidator) validateServer(s *Server) error <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("server config is nil")
        }</span>

        // 验证HTTP配置
        <span class="cov0" title="0">if s.Http != nil </span><span class="cov0" title="0">{
                if err := v.validateHTTP(s.Http); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("http config validation failed: %w", err)
                }</span>
        }

        // 验证GRPC配置
        <span class="cov0" title="0">if s.Grpc != nil </span><span class="cov0" title="0">{
                if err := v.validateGRPC(s.Grpc); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("grpc config validation failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateHTTP 验证HTTP配置
func (v *ConfigValidator) validateHTTP(h *Server_HTTP) error <span class="cov0" title="0">{
        if h.Addr == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("http addr is empty")
        }</span>

        <span class="cov0" title="0">if _, err := net.ResolveTCPAddr("tcp", h.Addr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid http addr %s: %w", h.Addr, err)
        }</span>

        <span class="cov0" title="0">if h.Timeout != nil </span><span class="cov0" title="0">{
                if h.Timeout.AsDuration() &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("http timeout must be positive")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateGRPC 验证GRPC配置
func (v *ConfigValidator) validateGRPC(g *Server_GRPC) error <span class="cov0" title="0">{
        if g.Addr == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("grpc addr is empty")
        }</span>

        <span class="cov0" title="0">if _, err := net.ResolveTCPAddr("tcp", g.Addr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid grpc addr %s: %w", g.Addr, err)
        }</span>

        <span class="cov0" title="0">if g.Timeout != nil </span><span class="cov0" title="0">{
                if g.Timeout.AsDuration() &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("grpc timeout must be positive")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateData 验证数据配置
func (v *ConfigValidator) validateData(d *Data) error <span class="cov0" title="0">{
        if d == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("data config is nil")
        }</span>

        // 验证数据库配置
        <span class="cov0" title="0">if d.Database != nil </span><span class="cov0" title="0">{
                if err := v.validateDatabase(d.Database); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("database config validation failed: %w", err)
                }</span>
        }

        // 验证同步数据库配置
        <span class="cov0" title="0">if d.DatabaseSync != nil </span><span class="cov0" title="0">{
                if err := v.validateDatabaseSync(d.DatabaseSync); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("database sync config validation failed: %w", err)
                }</span>
        }

        // 验证Redis配置
        <span class="cov0" title="0">if d.Redis != nil </span><span class="cov0" title="0">{
                if err := v.validateRedis(d.Redis); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("redis config validation failed: %w", err)
                }</span>
        }

        // 验证Etcd配置
        <span class="cov0" title="0">if d.Etcd != nil </span><span class="cov0" title="0">{
                if err := v.validateEtcd(d.Etcd); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("etcd config validation failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateDatabase 验证数据库配置
func (v *ConfigValidator) validateDatabase(db *Data_Database) error <span class="cov0" title="0">{
        if db.Driver == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database driver is empty")
        }</span>

        <span class="cov0" title="0">if db.Source == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database source is empty")
        }</span>

        <span class="cov0" title="0">if db.MaxOpenConns &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("database max_open_conns must be positive")
        }</span>

        <span class="cov0" title="0">if db.MaxIdleConns &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("database max_idle_conns must be positive")
        }</span>

        <span class="cov0" title="0">if db.ConnMaxLifetime != "" </span><span class="cov0" title="0">{
                if _, err := time.ParseDuration(db.ConnMaxLifetime); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid database conn_max_lifetime %s: %w", db.ConnMaxLifetime, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateDatabaseSync 验证同步数据库配置
func (v *ConfigValidator) validateDatabaseSync(db *Data_DatabaseSync) error <span class="cov0" title="0">{
        if db.Driver == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database sync driver is empty")
        }</span>

        <span class="cov0" title="0">if db.Source == "" &amp;&amp; db.SourceKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database sync source or source_key must be provided")
        }</span>

        <span class="cov0" title="0">if db.MaxOpenConns &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("database sync max_open_conns must be positive")
        }</span>

        <span class="cov0" title="0">if db.MaxIdleConns &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("database sync max_idle_conns must be positive")
        }</span>

        <span class="cov0" title="0">if db.ConnMaxLifetime != "" </span><span class="cov0" title="0">{
                if _, err := time.ParseDuration(db.ConnMaxLifetime); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid database sync conn_max_lifetime %s: %w", db.ConnMaxLifetime, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateRedis 验证Redis配置
func (v *ConfigValidator) validateRedis(r *Data_Redis) error <span class="cov0" title="0">{
        if r.Addr == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("redis addr is empty")
        }</span>

        <span class="cov0" title="0">if _, err := net.ResolveTCPAddr("tcp", r.Addr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid redis addr %s: %w", r.Addr, err)
        }</span>

        <span class="cov0" title="0">if r.Db &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("redis db must be non-negative")
        }</span>

        <span class="cov0" title="0">if r.ReadTimeout != nil </span><span class="cov0" title="0">{
                if r.ReadTimeout.AsDuration() &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("redis read_timeout must be positive")
                }</span>
        }

        <span class="cov0" title="0">if r.WriteTimeout != nil </span><span class="cov0" title="0">{
                if r.WriteTimeout.AsDuration() &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("redis write_timeout must be positive")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateEtcd 验证Etcd配置
func (v *ConfigValidator) validateEtcd(e *Data_Etcd) error <span class="cov0" title="0">{
        if len(e.Endpoints) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("etcd endpoints is empty")
        }</span>

        <span class="cov0" title="0">for i, endpoint := range e.Endpoints </span><span class="cov0" title="0">{
                if endpoint == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("etcd endpoint[%d] is empty", i)
                }</span>

                <span class="cov0" title="0">if _, err := url.Parse(endpoint); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid etcd endpoint[%d] %s: %w", i, endpoint, err)
                }</span>
        }

        <span class="cov0" title="0">if e.DialTimeout != "" </span><span class="cov0" title="0">{
                if _, err := time.ParseDuration(e.DialTimeout); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid etcd dial_timeout %s: %w", e.DialTimeout, err)
                }</span>
        }

        <span class="cov0" title="0">if e.ConfigPrefix == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("etcd config_prefix is empty")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateApp 验证应用配置
func (v *ConfigValidator) validateApp(a *App) error <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("app config is nil")
        }</span>

        <span class="cov0" title="0">if a.Id == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app id is empty")
        }</span>

        <span class="cov0" title="0">if a.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app name is empty")
        }</span>

        <span class="cov0" title="0">if a.Version == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app version is empty")
        }</span>

        <span class="cov0" title="0">if a.Env == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app env is empty")
        }</span>

        // LogLevel and LogOut are now in OpenTelemetry.Logs

        <span class="cov0" title="0">if a.AppPackage == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app app_package is empty")
        }</span>

        <span class="cov0" title="0">if a.AppId == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app app_id is empty")
        }</span>

        <span class="cov0" title="0">if a.AppSecret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app app_secret is empty")
        }</span>

        <span class="cov0" title="0">if a.ThirdCompanyId == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app third_company_id is empty")
        }</span>

        <span class="cov0" title="0">if a.PlatformIds == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app platform_ids is empty")
        }</span>

        <span class="cov0" title="0">if a.CompanyId == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app company_id is empty")
        }</span>

        <span class="cov0" title="0">if a.AccessKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app access_key is empty")
        }</span>

        <span class="cov0" title="0">if a.SecretKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("app secret_key is empty")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateAuth 验证认证配置
func (v *ConfigValidator) validateAuth(a *Auth) error <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("auth config is nil")
        }</span>

        // 验证WPS应用配置
        <span class="cov0" title="0">if a.Wpsapp != nil </span><span class="cov0" title="0">{
                if err := v.validateWpsapp(a.Wpsapp); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("wpsapp config validation failed: %w", err)
                }</span>
        }

        // 验证钉钉配置
        <span class="cov0" title="0">if a.Dingtalk != nil </span><span class="cov0" title="0">{
                if err := v.validateDingtalk(a.Dingtalk); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("dingtalk config validation failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateWpsapp 验证WPS应用配置
func (v *ConfigValidator) validateWpsapp(w *Auth_Wpsapp) error <span class="cov0" title="0">{
        if w.ClientId == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("wpsapp client_id is empty")
        }</span>

        <span class="cov0" title="0">if w.ClientSecret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("wpsapp client_secret is empty")
        }</span>

        <span class="cov0" title="0">if w.AuthUrl == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("wpsapp auth_url is empty")
        }</span>

        <span class="cov0" title="0">if _, err := url.Parse(w.AuthUrl); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid wpsapp auth_url %s: %w", w.AuthUrl, err)
        }</span>

        <span class="cov0" title="0">if w.AuthPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("wpsapp auth_path is empty")
        }</span>

        <span class="cov0" title="0">if w.GrantType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("wpsapp grant_type is empty")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateDingtalk 验证钉钉配置
func (v *ConfigValidator) validateDingtalk(d *Auth_Dingtalk) error <span class="cov0" title="0">{
        if d.Endpoint == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("dingtalk endpoint is empty")
        }</span>

        <span class="cov0" title="0">if _, err := url.Parse(d.Endpoint); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid dingtalk endpoint %s: %w", d.Endpoint, err)
        }</span>

        <span class="cov0" title="0">if d.AppKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("dingtalk app_key is empty")
        }</span>

        <span class="cov0" title="0">if d.AppSecret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("dingtalk app_secret is empty")
        }</span>

        <span class="cov0" title="0">if d.Timeout != "" </span><span class="cov0" title="0">{
                if _, err := time.ParseDuration(d.Timeout); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid dingtalk timeout %s: %w", d.Timeout, err)
                }</span>
        }

        <span class="cov0" title="0">if d.MaxConcurrent &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("dingtalk maxConcurrent must be positive")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateEnvironment 验证环境变量配置
func (v *ConfigValidator) ValidateEnvironment() error <span class="cov0" title="0">{
        requiredEnvVars := []string{
                "ENCRYPTION_SALT",
        }

        optionalEnvVars := []string{
                "APP_UID",
                "ECIS_ECISACCOUNTSYNC_DB",
        }

        // 验证必需的环境变量
        for _, key := range requiredEnvVars </span><span class="cov0" title="0">{
                if _, err := GetEnv(key); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("required environment variable %s not found: %w", key, err)
                }</span>
        }

        // 记录可选的环境变量状态
        <span class="cov0" title="0">for _, key := range optionalEnvVars </span><span class="cov0" title="0">{
                if value, err := GetEnv(key); err != nil </span><span class="cov0" title="0">{
                        v.logger.Log(log.LevelWarn, "optional environment variable not found", "key", key)
                }</span> else<span class="cov0" title="0"> {
                        v.logger.Log(log.LevelInfo, "environment variable found", "key", key, "has_value", value != "")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package data

import (
        "context"
        "errors"
        "time"

        "nancalacc/internal/biz"
        "nancalacc/internal/conf"
        "nancalacc/internal/data/models"
        "nancalacc/internal/dingtalk"

        //nancalaccLog "nancalacc/internal/log"

        "github.com/go-kratos/kratos/v2/log"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

type accounterRepo struct {
        bizConf *conf.App
        data    *Data
        log     log.Logger
}

// getSyncDB 获取同步数据库连接
func (r *accounterRepo) getSyncDB() (*gorm.DB, error) <span class="cov0" title="0">{
        return r.data.GetSyncDB()
}</span>

var (
        Source  = "sync"
        timeout = 5 * time.Second
)

// NewAccounterRepo .
func NewAccounterRepo(data *Data, logger log.Logger) biz.AccounterRepo <span class="cov0" title="0">{
        return &amp;accounterRepo{
                bizConf: conf.Get().GetApp(),
                data:    data,
                log:     logger,
        }
}</span>

func (r *accounterRepo) SaveUsers(ctx context.Context, users []*dingtalk.DingtalkDeptUser, taskId string) (int, error) <span class="cov0" title="0">{

        r.log.Log(log.LevelInfo, "msg", "SaveUsers", "users_count", len(users), "taskId", taskId)

        if len(users) == 0 </span><span class="cov0" title="0">{
                r.log.Log(log.LevelWarn, "msg", "SaveUsers", "users is empty")
                return 0, nil
        }</span>

        <span class="cov0" title="0">thirdCompanyID := r.bizConf.ThirdCompanyId
        platformID := r.bizConf.PlatformIds
        entities := make([]*models.TbLasUser, 0, len(users))
        invalidUsers := make([]string, 0)

        // 批量验证和转换，收集无效数据
        for _, user := range users </span><span class="cov0" title="0">{
                if err := dingtalk.ValidateDingTalkUser(ctx, user); err != nil </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelWarn, "msg", "invalid user skipped", "user_id", user.Userid, "err", err)
                        invalidUsers = append(invalidUsers, user.Userid)
                        continue</span>
                }
                <span class="cov0" title="0">entity := models.MakeLasUser(user, thirdCompanyID, platformID, Source, taskId)
                entities = append(entities, entity)</span>
        }

        // 记录无效数据统计
        <span class="cov0" title="0">if len(invalidUsers) &gt; 0 </span><span class="cov0" title="0">{
                r.log.Log(log.LevelWarn, "msg", "invalid users found", "count", len(invalidUsers), "invalid_ids", invalidUsers)
        }</span>

        <span class="cov0" title="0">if len(entities) == 0 </span><span class="cov0" title="0">{
                r.log.Log(log.LevelWarn, "msg", "no valid users to save")
                return 0, nil
        }</span>

        <span class="cov0" title="0">db, err := r.data.GetSyncDB()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // 使用 Upsert 操作避免重复键错误
        <span class="cov0" title="0">result := db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "uid"}, {Name: "task_id"}, {Name: "third_company_id"}, {Name: "platform_id"}},
                DoNothing: true,
        }).Create(&amp;entities)

        if result.Error != nil </span><span class="cov0" title="0">{
                r.log.Log(log.LevelError, "msg", "SaveUsers failed", "err", result.Error)
                return 0, result.Error
        }</span>

        <span class="cov0" title="0">r.log.Log(log.LevelInfo, "msg", "SaveUsers completed", "saved_count", int(result.RowsAffected), "total_processed", len(users))
        return int(result.RowsAffected), nil</span>
}

func (r *accounterRepo) SaveDepartments(ctx context.Context, depts []*dingtalk.DingtalkDept, taskId string) (int, error) <span class="cov0" title="0">{

        r.log.Log(log.LevelInfo, "msg", "SaveDepartments", "depts_count", len(depts), "taskId", taskId)

        // 使用传入的 context 并设置超时
        ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        if len(depts) == 0 </span><span class="cov0" title="0">{
                r.log.Log(log.LevelWarn, "msg", "SaveDepartments", "depts is empty")
                return 0, nil
        }</span>

        <span class="cov0" title="0">entities := make([]*models.TbLasDepartment, 0, len(depts)+1) // +1 for root department

        thirdCompanyID := r.bizConf.ThirdCompanyId
        platformID := r.bizConf.PlatformIds
        companyID := r.bizConf.CompanyId

        // 先添加部门实体
        for _, dep := range depts </span><span class="cov0" title="0">{
                entity := models.MakeTbLasDepartment(dep, thirdCompanyID, platformID, companyID, Source, taskId)
                entities = append(entities, entity)
        }</span>

        // 添加根部门
        <span class="cov0" title="0">rootDep := models.MakeTbLasRootDepartment(thirdCompanyID, platformID, companyID, Source, taskId)
        entities = append(entities, rootDep)

        db, err := r.data.GetSyncDB()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // 使用 Upsert 操作，避免重复键错误
        <span class="cov0" title="0">result := db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "did"}, {Name: "task_id"}, {Name: "third_company_id"}, {Name: "platform_id"}},
                DoNothing: true,
        }).Create(&amp;entities)

        if result.Error != nil </span><span class="cov0" title="0">{
                r.log.Log(log.LevelError, "msg", "SaveDepartments failed", "err", result.Error)
                return 0, result.Error
        }</span>

        <span class="cov0" title="0">r.log.Log(log.LevelInfo, "msg", "SaveDepartments completed", "saved_count", int(result.RowsAffected), "total_processed", len(entities))
        return int(result.RowsAffected), nil</span>
}

func (r *accounterRepo) SaveDepartmentUserRelations(ctx context.Context, relations []*dingtalk.DingtalkDeptUserRelation, taskId string) (int, error) <span class="cov0" title="0">{
        r.log.Log(log.LevelInfo, "msg", "SaveDepartmentUserRelations", "relations_count", len(relations), "taskId", taskId)

        // 使用传入的 context 并设置超时
        ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        if len(relations) == 0 </span><span class="cov0" title="0">{
                r.log.Log(log.LevelWarn, "msg", "SaveDepartmentUserRelations", "relations is empty")
                return 0, nil
        }</span>

        <span class="cov0" title="0">entities := make([]*models.TbLasDepartmentUser, 0, len(relations))

        thirdCompanyID := r.bizConf.ThirdCompanyId
        platformID := r.bizConf.PlatformIds

        for _, relation := range relations </span><span class="cov0" title="0">{
                entity := models.MakeTbLasDepartmentUser(relation, thirdCompanyID, platformID, "", Source, taskId)
                entities = append(entities, entity)
        }</span>

        <span class="cov0" title="0">db, err := r.data.GetSyncDB()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">result := db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "did"}, {Name: "uid"}, {Name: "task_id"}, {Name: "third_company_id"}, {Name: "platform_id"}},
                DoNothing: true,
        }).Create(&amp;entities)

        if result.Error != nil </span><span class="cov0" title="0">{
                r.log.Log(log.LevelError, "msg", "SaveDepartmentUserRelations failed", "err", result.Error)
                return 0, result.Error
        }</span>

        <span class="cov0" title="0">r.log.Log(log.LevelInfo, "msg", "SaveDepartmentUserRelations completed", "saved_count", int(result.RowsAffected), "total_processed", len(relations))
        return int(result.RowsAffected), nil</span>
}

func (r *accounterRepo) SaveCompanyCfg(ctx context.Context, input *dingtalk.DingtalkCompanyCfg) error <span class="cov0" title="0">{
        r.log.Log(log.LevelInfo, "msg", "SaveCompanyCfg", "input", input)

        now := time.Now()
        entity := &amp;models.TbCompanyCfg{
                ThirdCompanyId: input.ThirdCompanyId,
                PlatformIds:    input.PlatformIds,
                CompanyId:      input.CompanyId,
                Status:         1,
                Ctime:          now,
                Mtime:          now,
        }

        db, err := r.data.GetSyncDB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = db.WithContext(ctx).Where(models.TbCompanyCfg{
                ThirdCompanyId: input.ThirdCompanyId,
                CompanyId:      input.CompanyId,
        }).FirstOrCreate(entity).Error

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelError, "msg", "SaveCompanyCfg", "company config already exists")
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>

        }

        <span class="cov0" title="0">return nil</span>
}

func (r *accounterRepo) ClearAll(ctx context.Context) error <span class="cov0" title="0">{
        db, err := r.data.GetSyncDB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = db.WithContext(ctx).Exec("truncate table tb_company_cfg").Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = db.WithContext(ctx).Exec("truncate table tb_las_department").Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = db.WithContext(ctx).Exec("truncate table tb_las_department_user").Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = db.WithContext(ctx).Exec("truncate table tb_las_account").Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// user_del/user_update/user_add(update_type). . auto/manual(sync_type)
func (r *accounterRepo) SaveIncrementUsers(ctx context.Context, usersAdd, usersDel, usersUpd []*dingtalk.DingtalkDeptUser) error <span class="cov0" title="0">{
        r.log.Log(log.LevelInfo, "msg", "SaveIncrementUsers", "users_add", len(usersAdd), "users_del", len(usersDel), "users_upd", len(usersUpd))

        inputlen := len(usersAdd) + len(usersDel) + len(usersUpd)
        if inputlen == 0 </span><span class="cov0" title="0">{
                return errors.New("empty input")
        }</span>

        // 使用传入的 context 并设置超时
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        entities := make([]*models.TbLasUserIncrement, 0, inputlen)
        invalidUsers := make([]string, 0)

        thirdCompanyID := r.bizConf.ThirdCompanyId
        platformID := r.bizConf.PlatformIds
        companyID := r.bizConf.CompanyId

        // 批量处理用户数据
        for _, add := range usersAdd </span><span class="cov0" title="0">{
                if err := dingtalk.ValidateDingTalkUser(ctx, add); err != nil </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelWarn, "msg", "invalid user_add skipped", "user_id", add.Userid, "err", err)
                        invalidUsers = append(invalidUsers, add.Userid)
                        continue</span>
                }
                <span class="cov0" title="0">entity := models.MakeLasUserIncrement(add, thirdCompanyID, platformID, companyID, Source, "user_add")
                entities = append(entities, entity)</span>
        }

        <span class="cov0" title="0">for _, del := range usersDel </span><span class="cov0" title="0">{
                if err := dingtalk.ValidateDingTalkUser(ctx, del); err != nil </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelWarn, "msg", "invalid user_del skipped", "user_id", del.Userid, "err", err)
                        invalidUsers = append(invalidUsers, del.Userid)
                        continue</span>
                }
                <span class="cov0" title="0">entity := models.MakeLasUserIncrement(del, thirdCompanyID, platformID, companyID, Source, "user_del")
                entities = append(entities, entity)</span>
        }

        <span class="cov0" title="0">for _, upd := range usersUpd </span><span class="cov0" title="0">{
                if err := dingtalk.ValidateDingTalkUser(ctx, upd); err != nil </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelWarn, "msg", "invalid user_upd skipped", "user_id", upd.Userid, "err", err)
                        invalidUsers = append(invalidUsers, upd.Userid)
                        continue</span>
                }
                <span class="cov0" title="0">entity := models.MakeLasUserIncrement(upd, thirdCompanyID, platformID, companyID, Source, "user_update")
                entities = append(entities, entity)</span>
        }

        // 记录无效数据统计
        <span class="cov0" title="0">if len(invalidUsers) &gt; 0 </span><span class="cov0" title="0">{
                r.log.Log(log.LevelWarn, "msg", "invalid users found", "count", len(invalidUsers), "invalid_ids", invalidUsers)
        }</span>

        <span class="cov0" title="0">if len(entities) == 0 </span><span class="cov0" title="0">{
                r.log.Log(log.LevelWarn, "msg", "no valid users to save")
                return nil
        }</span>

        <span class="cov0" title="0">db, err := r.data.GetSyncDB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 使用 Upsert 操作避免重复键错误
        <span class="cov0" title="0">result := db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "uid"}, {Name: "task_id"}, {Name: "third_company_id"}, {Name: "platform_id"}},
                DoNothing: true,
        }).Create(&amp;entities)

        if result.Error != nil </span><span class="cov0" title="0">{
                r.log.Log(log.LevelError, "msg", "SaveIncrementUsers failed", "err", result.Error)
                return result.Error
        }</span>

        <span class="cov0" title="0">r.log.Log(log.LevelInfo, "msg", "SaveIncrementUsers completed", "saved_count", int(result.RowsAffected), "total_processed", len(entities))
        return nil</span>
}

// dept_del/dept_update/dept_add/dept_move(update_type)
func (r *accounterRepo) SaveIncrementDepartments(ctx context.Context, deptsAdd, deptsDel, deptsUpd []*dingtalk.DingtalkDept) error <span class="cov0" title="0">{
        r.log.Log(log.LevelInfo, "msg", "SaveIncrementDepartments", "depts_add", len(deptsAdd), "depts_del", len(deptsDel), "depts_upd", len(deptsUpd))

        inputlen := len(deptsAdd) + len(deptsDel) + len(deptsUpd)
        if inputlen == 0 </span><span class="cov0" title="0">{
                return errors.New("empty input")
        }</span>

        // 使用传入的 context 并设置超时
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        entities := make([]*models.TbLasDepartmentIncrement, 0, inputlen)
        thirdCompanyID := r.bizConf.ThirdCompanyId
        platformID := r.bizConf.PlatformIds

        // 批量处理部门数据
        for _, add := range deptsAdd </span><span class="cov0" title="0">{
                entity := models.MakeDepartmentIncrement(add, thirdCompanyID, platformID, "", Source, "dept_add")
                entities = append(entities, entity)
        }</span>

        <span class="cov0" title="0">for _, del := range deptsDel </span><span class="cov0" title="0">{
                entity := models.MakeDepartmentIncrement(del, thirdCompanyID, platformID, "", Source, "dept_del")
                entities = append(entities, entity)
        }</span>

        <span class="cov0" title="0">for _, upd := range deptsUpd </span><span class="cov0" title="0">{
                entity := models.MakeDepartmentIncrement(upd, thirdCompanyID, platformID, "", Source, "dept_update")
                entities = append(entities, entity)
        }</span>

        <span class="cov0" title="0">if len(entities) == 0 </span><span class="cov0" title="0">{
                r.log.Log(log.LevelWarn, "msg", "no valid departments to save")
                return nil
        }</span>

        <span class="cov0" title="0">db, err := r.data.GetSyncDB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 使用 Upsert 操作避免重复键错误
        <span class="cov0" title="0">result := db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "did"}, {Name: "task_id"}, {Name: "third_company_id"}, {Name: "platform_id"}},
                DoNothing: true,
        }).Create(&amp;entities)

        if result.Error != nil </span><span class="cov0" title="0">{
                r.log.Log(log.LevelError, "msg", "SaveIncrementDepartments failed", "err", result.Error)
                return result.Error
        }</span>

        <span class="cov0" title="0">r.log.Log(log.LevelInfo, "msg", "SaveIncrementDepartments completed", "saved_count", int(result.RowsAffected), "total_processed", len(entities))
        return nil</span>
}

func (r *accounterRepo) SaveIncrementDepartmentUserRelations(ctx context.Context, relationsAdd, relationsDel, relationsUpd []*dingtalk.DingtalkDeptUserRelation) error <span class="cov0" title="0">{
        r.log.Log(log.LevelInfo, "msg", "SaveIncrementDepartmentUserRelations", "relations_add", len(relationsAdd), "relations_del", len(relationsDel), "relations_upd", len(relationsUpd))

        inputlen := len(relationsAdd) + len(relationsDel) + len(relationsUpd)
        if inputlen == 0 </span><span class="cov0" title="0">{
                return errors.New("empty input")
        }</span>

        <span class="cov0" title="0">entities := make([]*models.TbLasDepartmentUserIncrement, 0, inputlen)

        thirdCompanyID := r.bizConf.ThirdCompanyId
        platformID := r.bizConf.PlatformIds

        // 批量处理部门用户关系数据
        for _, add := range relationsAdd </span><span class="cov0" title="0">{
                entity := models.MmakeTbLasDepartmentUserIncrement(add, thirdCompanyID, platformID, "", Source, "user_dept_add")
                entities = append(entities, entity)
        }</span>

        <span class="cov0" title="0">for _, del := range relationsDel </span><span class="cov0" title="0">{
                entity := models.MmakeTbLasDepartmentUserIncrement(del, thirdCompanyID, platformID, "", Source, "user_dept_del")
                entities = append(entities, entity)
        }</span>

        <span class="cov0" title="0">for _, upd := range relationsUpd </span><span class="cov0" title="0">{
                entity := models.MmakeTbLasDepartmentUserIncrement(upd, thirdCompanyID, platformID, "", Source, "user_dept_update")
                entities = append(entities, entity)
        }</span>

        <span class="cov0" title="0">if len(entities) == 0 </span><span class="cov0" title="0">{
                r.log.Log(log.LevelWarn, "msg", "no valid relations to save")
                return nil
        }</span>

        <span class="cov0" title="0">db, err := r.data.GetSyncDB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 使用 Upsert 操作避免重复键错误
        <span class="cov0" title="0">result := db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "did"}, {Name: "uid"}, {Name: "task_id"}, {Name: "third_company_id"}, {Name: "platform_id"}},
                DoNothing: true,
        }).Create(&amp;entities)

        if result.Error != nil </span><span class="cov0" title="0">{
                r.log.Log(log.LevelError, "msg", "SaveIncrementDepartmentUserRelations failed", "err", result.Error)
                return result.Error
        }</span>

        <span class="cov0" title="0">r.log.Log(log.LevelInfo, "msg", "SaveIncrementDepartmentUserRelations completed", "saved_count", int(result.RowsAffected), "total_processed", len(entities))
        return nil</span>
}
func (r *accounterRepo) BatchSaveUsers(ctx context.Context, users []*models.TbLasUser) (int, error) <span class="cov0" title="0">{

        r.log.Log(log.LevelInfo, "msg", "BatchSaveUsers", "users_count", len(users))

        if len(users) == 0 </span><span class="cov0" title="0">{
                r.log.Log(log.LevelWarn, "msg", "BatchSaveUsers", "users is empty")
                return 0, nil
        }</span>

        // 检查 context 是否已取消
        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                r.log.Log(log.LevelError, "msg", "BatchSaveUsers", "context canceled before database operation", "err", ctx.Err())
                return 0, ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
                // 继续执行
        }

        // 记录 context 的截止时间（如果有的话）
        <span class="cov0" title="0">if deadline, ok := ctx.Deadline(); ok </span><span class="cov0" title="0">{
                r.log.Log(log.LevelInfo, "msg", "BatchSaveUsers", "context deadline", "deadline", deadline, "time_until_deadline", time.Until(deadline))
        }</span>

        <span class="cov0" title="0">db, err := r.data.GetSyncDB()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">result := db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "uid"}, {Name: "task_id"}, {Name: "third_company_id"}, {Name: "platform_id"}},
                DoNothing: true,
        }).Create(users)

        if result.Error != nil </span><span class="cov0" title="0">{
                // 检查是否是 context 相关错误
                if errors.Is(result.Error, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelError, "msg", "BatchSaveUsers", "context deadline exceeded", "err", result.Error)
                }</span> else<span class="cov0" title="0"> if errors.Is(result.Error, context.Canceled) </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelError, "msg", "BatchSaveUsers", "context canceled during database operation", "err", result.Error)
                }</span> else<span class="cov0" title="0"> {
                        r.log.Log(log.LevelError, "msg", "BatchSaveUsers failed", "err", result.Error)
                }</span>
                <span class="cov0" title="0">return 0, result.Error</span>
        }

        <span class="cov0" title="0">r.log.Log(log.LevelInfo, "msg", "BatchSaveUsers completed", "saved_count", int(result.RowsAffected), "total_processed", len(users))
        return int(result.RowsAffected), nil</span>
}
func (r *accounterRepo) BatchSaveDepts(ctx context.Context, depts []*models.TbLasDepartment) (int, error) <span class="cov0" title="0">{

        r.log.Log(log.LevelInfo, "msg", "BatchSaveDepts", "depts_count", len(depts))

        if len(depts) == 0 </span><span class="cov0" title="0">{
                r.log.Log(log.LevelWarn, "msg", "BatchSaveDepts", "depts is empty")
                return 0, nil
        }</span>

        // 检查 context 是否已取消
        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                r.log.Log(log.LevelError, "msg", "BatchSaveDepts", "context canceled before database operation", "err", ctx.Err())
                return 0, ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
                // 继续执行
        }

        // 记录 context 的截止时间（如果有的话）
        <span class="cov0" title="0">if deadline, ok := ctx.Deadline(); ok </span><span class="cov0" title="0">{
                r.log.Log(log.LevelInfo, "msg", "BatchSaveDepts", "context deadline", "deadline", deadline, "time_until_deadline", time.Until(deadline))
        }</span>

        <span class="cov0" title="0">db, err := r.data.GetSyncDB()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // 使用 Upsert 操作避免重复键错误
        <span class="cov0" title="0">result := db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "did"}, {Name: "task_id"}, {Name: "third_company_id"}, {Name: "platform_id"}},
                DoNothing: true,
        }).Create(depts)

        if result.Error != nil </span><span class="cov0" title="0">{
                // 检查是否是 context 相关错误
                if errors.Is(result.Error, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelError, "msg", "BatchSaveDepts", "context deadline exceeded", "err", result.Error)
                }</span> else<span class="cov0" title="0"> if errors.Is(result.Error, context.Canceled) </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelError, "msg", "BatchSaveDepts", "context canceled during database operation", "err", result.Error)
                }</span> else<span class="cov0" title="0"> {
                        r.log.Log(log.LevelError, "msg", "BatchSaveDepts failed", "err", result.Error)
                }</span>
                <span class="cov0" title="0">return 0, result.Error</span>
        }

        <span class="cov0" title="0">r.log.Log(log.LevelInfo, "msg", "BatchSaveDepts completed", "saved_count", int(result.RowsAffected), "total_processed", len(depts))
        return int(result.RowsAffected), nil</span>
}
func (r *accounterRepo) BatchSaveDeptUsers(ctx context.Context, usersdepts []*models.TbLasDepartmentUser) (int, error) <span class="cov0" title="0">{

        r.log.Log(log.LevelInfo, "msg", "BatchSaveDeptUsers", "usersdepts_count", len(usersdepts))

        // 直接使用传入的 ctx，继承父级的超时设置

        if len(usersdepts) == 0 </span><span class="cov0" title="0">{
                r.log.Log(log.LevelWarn, "msg", "BatchSaveDeptUsers", "usersdepts is empty")
                return 0, nil
        }</span>

        // 检查 context 是否已取消
        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                r.log.Log(log.LevelError, "msg", "BatchSaveDeptUsers", "context canceled before database operation", "err", ctx.Err())
                return 0, ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
                // 继续执行
        }

        // 记录 context 的截止时间（如果有的话）
        <span class="cov0" title="0">if deadline, ok := ctx.Deadline(); ok </span><span class="cov0" title="0">{
                r.log.Log(log.LevelInfo, "msg", "BatchSaveDeptUsers", "context deadline", "deadline", deadline, "time_until_deadline", time.Until(deadline))
        }</span>

        <span class="cov0" title="0">db, err := r.data.GetSyncDB()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // 使用 Upsert 操作避免重复键错误
        <span class="cov0" title="0">result := db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "did"}, {Name: "uid"}, {Name: "task_id"}, {Name: "third_company_id"}, {Name: "platform_id"}},
                DoNothing: true,
        }).Create(usersdepts)

        if result.Error != nil </span><span class="cov0" title="0">{
                // 检查是否是 context 相关错误
                if errors.Is(result.Error, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelError, "msg", "BatchSaveDeptUsers", "context deadline exceeded", "err", result.Error)
                }</span> else<span class="cov0" title="0"> if errors.Is(result.Error, context.Canceled) </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelError, "msg", "BatchSaveDeptUsers", "context canceled during database operation", "err", result.Error)
                }</span> else<span class="cov0" title="0"> {
                        r.log.Log(log.LevelError, "msg", "BatchSaveDeptUsers failed", "err", result.Error)
                }</span>
                <span class="cov0" title="0">return 0, result.Error</span>
        }

        <span class="cov0" title="0">r.log.Log(log.LevelInfo, "msg", "BatchSaveDeptUsers completed", "saved_count", int(result.RowsAffected), "total_processed", len(usersdepts))
        return int(result.RowsAffected), nil</span>
}

func (r *accounterRepo) CreateTask(ctx context.Context, taskName string) (int, error) <span class="cov0" title="0">{
        r.log.Log(log.LevelInfo, "msg", "CreateTask", "name", taskName)

        // 使用传入的 context 并设置超时
        ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()
        task := &amp;models.Task{
                Title:         taskName,
                Description:   taskName,
                CreatedAt:     time.Now(),
                Status:        models.TaskStatusPending,
                Progress:      0,
                StartDate:     time.Now(),
                DueDate:       time.Now().Add(time.Minute * 30),
                CompletedAt:   time.Now(),
                CreatorID:     99,
                EstimatedTime: 10,
                ActualTime:    0,
        }

        db, err := r.data.GetMainDB()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">result := db.WithContext(ctx).Where("title=?", taskName).FirstOrCreate(task)

        if result.Error != nil </span><span class="cov0" title="0">{
                // 处理其他错误
                return 0, result.Error
        }</span>

        <span class="cov0" title="0">if result.RowsAffected &gt; 0 </span><span class="cov0" title="0">{
                return 1, nil
        }</span> else<span class="cov0" title="0"> {
                return 0, nil
        }</span>
}

func (r *accounterRepo) UpdateTask(ctx context.Context, taskName, status string) error <span class="cov0" title="0">{

        r.log.Log(log.LevelInfo, "msg", "UpdateTask", "taskName", taskName, "status", status)
        // pending/in_progress/completed/cancelled

        var task models.Task
        db, err := r.data.GetMainDB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := db.Model(&amp;models.Task{}).WithContext(ctx).Where("title=?", taskName).Find(&amp;task).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelError, "msg", "UpdateTask", "查询超时")
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">now := time.Now()
        task.ActualTime = int(now.Sub(task.StartDate).Seconds())
        task.UpdatedAt = now
        task.Status = status
        if status == models.TaskStatusCompleted || status == models.TaskStatusCancelled </span><span class="cov0" title="0">{
                task.CompletedAt = now
        }</span>

        <span class="cov0" title="0">result := db.WithContext(ctx).Updates(task)

        if result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelError, "msg", "UpdateTask", "task already exists")
                }</span> else<span class="cov0" title="0"> {
                        return result.Error
                }</span>

        }

        <span class="cov0" title="0">return nil</span>
}

func (r *accounterRepo) GetTask(ctx context.Context, taskName string) (*models.Task, error) <span class="cov0" title="0">{

        r.log.Log(log.LevelInfo, "msg", "GetTask", "name", taskName)
        task := &amp;models.Task{}
        db, err := r.data.GetMainDB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">result := db.WithContext(ctx).Where("title=?", taskName).Find(task)

        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("notfound")
        }</span>
        <span class="cov0" title="0">return task, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package data

import (
        "context"
        "fmt"
        "sync"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/go-redis/redis/v8"
        "github.com/google/wire"
        "gorm.io/gorm"
)

// ProviderSet is data providers.
var ProviderSet = wire.NewSet(
        NewRedisClient,
        NewAccounterRepo,
        NewLocalCacheService,
        NewDatabaseFactory,     // 数据库工厂
        NewDatabaseInitializer, // 数据库初始化器
        NewDataWithFactory,     // 使用工厂创建数据层
)

// DatabaseType 数据库类型
type DatabaseType string

const (
        MainDBType  DatabaseType = "main"  // 主数据库
        SyncDBType  DatabaseType = "sync"  // 同步数据库
        UserDBType  DatabaseType = "user"  // 用户数据库
        LogDBType   DatabaseType = "log"   // 日志数据库
        CacheDBType DatabaseType = "cache" // 缓存数据库
        SagaDBType  DatabaseType = "saga"  // Saga 分布式事务数据库
)

// DatabaseConfig 数据库配置
type DatabaseConfig struct {
        Type     DatabaseType
        Name     string
        DB       *gorm.DB
        Config   interface{}
        IsActive bool
}

// DatabaseManager 数据库管理器
type DatabaseManager struct {
        databases map[DatabaseType]*DatabaseConfig
        mu        sync.RWMutex
}

// NewDatabaseManager 创建数据库管理器
func NewDatabaseManager() *DatabaseManager <span class="cov0" title="0">{
        return &amp;DatabaseManager{
                databases: make(map[DatabaseType]*DatabaseConfig),
        }
}</span>

// RegisterDatabase 注册数据库
func (dm *DatabaseManager) RegisterDatabase(dbType DatabaseType, name string, db *gorm.DB, config interface{}) <span class="cov0" title="0">{
        dm.mu.Lock()
        defer dm.mu.Unlock()

        dm.databases[dbType] = &amp;DatabaseConfig{
                Type:     dbType,
                Name:     name,
                DB:       db,
                Config:   config,
                IsActive: db != nil,
        }
}</span>

// GetDatabase 获取数据库
func (dm *DatabaseManager) GetDatabase(dbType DatabaseType) (*gorm.DB, error) <span class="cov0" title="0">{
        dm.mu.RLock()
        defer dm.mu.RUnlock()

        if config, exists := dm.databases[dbType]; exists &amp;&amp; config.IsActive </span><span class="cov0" title="0">{
                return config.DB, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("database %s not found or not active", dbType)</span>
}

// GetDatabaseConfig 获取数据库配置
func (dm *DatabaseManager) GetDatabaseConfig(dbType DatabaseType) (*DatabaseConfig, error) <span class="cov0" title="0">{
        dm.mu.RLock()
        defer dm.mu.RUnlock()

        if config, exists := dm.databases[dbType]; exists </span><span class="cov0" title="0">{
                return config, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("database config %s not found", dbType)</span>
}

// ListDatabases 列出所有数据库
func (dm *DatabaseManager) ListDatabases() map[DatabaseType]*DatabaseConfig <span class="cov0" title="0">{
        dm.mu.RLock()
        defer dm.mu.RUnlock()

        result := make(map[DatabaseType]*DatabaseConfig)
        for k, v := range dm.databases </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}

// CloseAll 关闭所有数据库连接
func (dm *DatabaseManager) CloseAll(logger log.Logger) <span class="cov0" title="0">{
        dm.mu.Lock()
        defer dm.mu.Unlock()

        for dbType, config := range dm.databases </span><span class="cov0" title="0">{
                if config.IsActive &amp;&amp; config.DB != nil </span><span class="cov0" title="0">{
                        if sqlDB, err := config.DB.DB(); err == nil </span><span class="cov0" title="0">{
                                if err := sqlDB.Close(); err != nil </span><span class="cov0" title="0">{
                                        logger.Log(log.LevelError, "msg", "failed to close database",
                                                "type", dbType, "name", config.Name, "error", err)
                                }</span> else<span class="cov0" title="0"> {
                                        logger.Log(log.LevelInfo, "msg", "database closed",
                                                "type", dbType, "name", config.Name)
                                }</span>
                        }
                        <span class="cov0" title="0">config.IsActive = false</span>
                }
        }
}

// Data 数据层结构体
type Data struct {
        dbManager *DatabaseManager
        redis     *redis.Client
        logger    log.Logger
        sagaRepo  *SagaRepository
        // 可以添加其他仓库
}

// cleanup 清理资源
func (d *Data) cleanup() <span class="cov0" title="0">{
        // 关闭所有数据库连接
        d.dbManager.CloseAll(d.logger)

        // 关闭 Redis 连接
        if d.redis != nil </span><span class="cov0" title="0">{
                if err := d.redis.Close(); err != nil </span><span class="cov0" title="0">{
                        d.logger.Log(log.LevelError, "msg", "failed to close redis", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        d.logger.Log(log.LevelInfo, "msg", "redis connection closed")
                }</span>
        }

        <span class="cov0" title="0">d.logger.Log(log.LevelInfo, "msg", "all database connections closed")</span>
}

// GetMainDB 获取主数据库
func (d *Data) GetMainDB() (*gorm.DB, error) <span class="cov0" title="0">{
        return d.dbManager.GetDatabase(MainDBType)
}</span>

// GetSyncDB 获取同步数据库
func (d *Data) GetSyncDB() (*gorm.DB, error) <span class="cov0" title="0">{
        return d.dbManager.GetDatabase(SyncDBType)
}</span>

// GetSagaDB 获取 Saga 数据库
func (d *Data) GetSagaDB() (*gorm.DB, error) <span class="cov0" title="0">{
        return d.dbManager.GetDatabase(SagaDBType)
}</span>

// GetSagaRepository 获取 Saga 仓库
func (d *Data) GetSagaRepository() *SagaRepository <span class="cov0" title="0">{
        return d.sagaRepo
}</span>

// GetDatabase 获取指定类型的数据库
func (d *Data) GetDatabase(dbType DatabaseType) (*gorm.DB, error) <span class="cov0" title="0">{
        return d.dbManager.GetDatabase(dbType)
}</span>

// GetRedis 获取 Redis 客户端
func (d *Data) GetRedis() *redis.Client <span class="cov0" title="0">{
        return d.redis
}</span>

// GetDBManager 获取数据库管理器
func (d *Data) GetDBManager() *DatabaseManager <span class="cov0" title="0">{
        return d.dbManager
}</span>

// IsRedisAvailable 检查 Redis 是否可用
func (d *Data) IsRedisAvailable() bool <span class="cov0" title="0">{
        if d.redis == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        _, err := d.redis.Ping(ctx).Result()
        return err == nil</span>
}

// HealthCheck 健康检查
func (d *Data) HealthCheck(ctx context.Context) map[string]interface{} <span class="cov0" title="0">{
        health := make(map[string]interface{})

        // 检查数据库连接
        databases := d.dbManager.ListDatabases()
        for dbType, config := range databases </span><span class="cov0" title="0">{
                if config.IsActive &amp;&amp; config.DB != nil </span><span class="cov0" title="0">{
                        if sqlDB, err := config.DB.DB(); err == nil </span><span class="cov0" title="0">{
                                if err := sqlDB.PingContext(ctx); err == nil </span><span class="cov0" title="0">{
                                        health[string(dbType)] = "healthy"
                                }</span> else<span class="cov0" title="0"> {
                                        health[string(dbType)] = fmt.Sprintf("unhealthy: %v", err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                health[string(dbType)] = "unhealthy: failed to get underlying sql.DB"
                        }</span>
                } else<span class="cov0" title="0"> {
                        health[string(dbType)] = "inactive"
                }</span>
        }

        // 检查 Redis 连接
        <span class="cov0" title="0">if d.redis != nil </span><span class="cov0" title="0">{
                if _, err := d.redis.Ping(ctx).Result(); err == nil </span><span class="cov0" title="0">{
                        health["redis"] = "healthy"
                }</span> else<span class="cov0" title="0"> {
                        health["redis"] = fmt.Sprintf("unhealthy: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                health["redis"] = "inactive"
        }</span>

        <span class="cov0" title="0">return health</span>
}

// 保持向后兼容的方法
func (d *Data) DB() *gorm.DB <span class="cov0" title="0">{
        if db, err := d.GetSyncDB(); err == nil </span><span class="cov0" title="0">{
                return db
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (d *Data) NancalDB() *gorm.DB <span class="cov0" title="0">{
        if db, err := d.GetMainDB(); err == nil </span><span class="cov0" title="0">{
                return db
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package data

import (
        "context"
        "fmt"
        "nancalacc/internal/data/models"

        "github.com/go-kratos/kratos/v2/log"
        "gorm.io/gorm"
)

const (
        pageSize = 1000 // 每页数据量
        // maxResults = 10000 // 最大结果数限制
)

func (r *accounterRepo) BatchGetDeptUsers(ctx context.Context, taskName, thirdCompanyId, platformId string) ([]*models.TbLasDepartmentUser, error) <span class="cov0" title="0">{
        r.log.Log(log.LevelInfo, "msg", "BatchGetDeptUsers", "taskName", taskName, "platformId", platformId)

        var (
                allUsers   = make([]*models.TbLasDepartmentUser, 0, pageSize)
                lastID     uint64
                totalCount int
        )

        db, err := r.data.GetSyncDB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                var pageUsers []*models.TbLasDepartmentUser

                // 优化后的查询条件，按照索引顺序排列
                query := db.WithContext(ctx).
                        Where("task_id = ?", taskName).
                        Where("third_company_id = ?", thirdCompanyId).
                        Where("platform_id = ?", platformId).
                        Where("check_type = ?", 1). // 只查询勾选的记录
                        Order("id ASC")

                if lastID &gt; 0 </span><span class="cov0" title="0">{
                        query = query.Where("id &gt; ?", lastID)
                }</span>

                <span class="cov0" title="0">result := query.Limit(pageSize).Find(&amp;pageUsers)
                if result.Error != nil </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelError, "msg", "BatchGetDeptUsers", "Query failed at lastID", lastID, "err", result.Error)
                        return nil, fmt.Errorf("database error: %w", result.Error)
                }</span>

                <span class="cov0" title="0">if len(pageUsers) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">lastID = uint64(pageUsers[len(pageUsers)-1].ID)
                allUsers = append(allUsers, pageUsers...)
                totalCount += len(pageUsers)

                if len(pageUsers) &lt; pageSize </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if len(allUsers) == 0 </span><span class="cov0" title="0">{
                return nil, gorm.ErrRecordNotFound
        }</span>

        <span class="cov0" title="0">r.log.Log(log.LevelInfo, "msg", "BatchGetDeptUsers", "Fetched", totalCount, "records")
        return allUsers, nil</span>
}

func (r *accounterRepo) BatchGetUsers(ctx context.Context, taskName, thirdCompanyId, platformId string) ([]*models.TbLasUser, error) <span class="cov0" title="0">{
        r.log.Log(log.LevelInfo, "msg", "BatchGetUsers", "taskName", taskName, "platformId", platformId)

        var (
                allUsers   = make([]*models.TbLasUser, 0, pageSize)
                lastID     uint64
                totalCount int
        )

        // 只选择必要字段，减少数据传输量
        selectedFields := []string{
                "id", "task_id", "third_company_id", "platform_id", "uid",
                "def_did", "def_did_order", "account", "nick_name", "email",
                "phone", "employment_status", "check_type",
        }

        db, err := r.data.GetSyncDB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                var pageUsers []*models.TbLasUser

                // 优化后的查询条件，按照索引顺序排列
                query := db.WithContext(ctx).
                        Select(selectedFields).
                        Where("task_id = ?", taskName).
                        Where("third_company_id = ?", thirdCompanyId).
                        Where("platform_id = ?", platformId).
                        //Where("check_type = ?", 1).               // 只查询勾选的记录
                        //Where("employment_status = ?", "active"). // 只查询在职用户
                        Order("id ASC")

                if lastID &gt; 0 </span><span class="cov0" title="0">{
                        query = query.Where("id &gt; ?", lastID)
                }</span>

                <span class="cov0" title="0">result := query.Limit(pageSize).Find(&amp;pageUsers)
                if result.Error != nil </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelError, "msg", "BatchGetUsers", "Query failed at lastID", lastID, "err", result.Error)
                        return nil, fmt.Errorf("database error: %w", result.Error)
                }</span>

                <span class="cov0" title="0">if len(pageUsers) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">lastID = uint64(pageUsers[len(pageUsers)-1].ID)
                allUsers = append(allUsers, pageUsers...)
                totalCount += len(pageUsers)

                if len(pageUsers) &lt; pageSize </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if len(allUsers) == 0 </span><span class="cov0" title="0">{
                return nil, gorm.ErrRecordNotFound
        }</span>

        <span class="cov0" title="0">r.log.Log(log.LevelInfo, "msg", "BatchGetUsers", "Fetched", totalCount, "users")
        return allUsers, nil</span>
}

func (r *accounterRepo) BatchGetDepts(ctx context.Context, taskName, thirdCompanyId, platformId string) ([]*models.TbLasDepartment, error) <span class="cov0" title="0">{
        r.log.Log(log.LevelInfo, "msg", "BatchGetDepts", "taskName", taskName, "platformId", platformId)

        var (
                allDepts   = make([]*models.TbLasDepartment, 0, pageSize)
                lastID     uint64
                totalCount int
        )

        db, err := r.data.GetSyncDB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                var pageDepts []*models.TbLasDepartment

                // 优化后的查询条件，按照索引顺序排列
                query := db.WithContext(ctx).
                        Where("task_id = ?", taskName).
                        Where("third_company_id = ?", thirdCompanyId).
                        Where("platform_id = ?", platformId).
                        Where("check_type = ?", 1). // 只查询勾选的记录
                        Order("id ASC")

                if lastID &gt; 0 </span><span class="cov0" title="0">{
                        query = query.Where("id &gt; ?", lastID)
                }</span>

                <span class="cov0" title="0">result := query.Limit(pageSize).Find(&amp;pageDepts)
                if result.Error != nil </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelError, "msg", "BatchGetDepts", "Query failed at lastID", lastID, "err", result.Error)
                        return nil, fmt.Errorf("database error: %w", result.Error)
                }</span>

                <span class="cov0" title="0">if len(pageDepts) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">lastID = uint64(pageDepts[len(pageDepts)-1].ID)
                allDepts = append(allDepts, pageDepts...)
                totalCount += len(pageDepts)

                if len(pageDepts) &lt; pageSize </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if len(allDepts) == 0 </span><span class="cov0" title="0">{
                return nil, gorm.ErrRecordNotFound
        }</span>

        <span class="cov0" title="0">r.log.Log(log.LevelInfo, "msg", "BatchGetDepts", "Fetched", totalCount, "departments")
        return allDepts, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package data

import (
        "errors"
        "fmt"
        "nancalacc/internal/conf"
        "nancalacc/internal/pkg/cipherutil"
        "strings"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        "gorm.io/driver/mysql"
        "gorm.io/gorm"
)

// DatabaseFactory 数据库连接工厂
type DatabaseFactory struct {
        config     *conf.Data
        logger     log.Logger
        otelConfig *conf.OpenTelemetry // OpenTelemetry配置
}

// NewDatabaseFactory 创建数据库工厂
func NewDatabaseFactory(config *conf.Data, logger log.Logger, otelConfig *conf.OpenTelemetry) *DatabaseFactory <span class="cov0" title="0">{
        return &amp;DatabaseFactory{
                config:     config,
                logger:     logger,
                otelConfig: otelConfig,
        }
}</span>

// CreateDatabase 创建数据库连接
func (df *DatabaseFactory) CreateDatabase(dbType DatabaseType, config *DatabaseConnectionConfig) (*gorm.DB, error) <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                return nil, errors.New("database config is nil")
        }</span>

        // 获取数据库连接字符串
        <span class="cov0" title="0">dsn, err := df.getDSN(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get DSN for %s: %w", dbType, err)
        }</span>

        // 确定GORM日志级别：OpenTelemetry配置优先，数据库配置作为默认值
        <span class="cov0" title="0">var logLevel string
        if df.otelConfig != nil &amp;&amp; df.otelConfig.Logs != nil &amp;&amp; df.otelConfig.Logs.Gorm != nil &amp;&amp; df.otelConfig.Logs.Gorm.LogLevel != "" </span><span class="cov0" title="0">{
                logLevel = df.otelConfig.Logs.Gorm.LogLevel
        }</span> else<span class="cov0" title="0"> if config.LogLevel != "" </span><span class="cov0" title="0">{
                logLevel = config.LogLevel
        }</span> else<span class="cov0" title="0"> {
                logLevel = "info" // 默认日志级别
        }</span>

        // 创建使用OpenTelemetry logger的GORM配置
        <span class="cov0" title="0">gormConfig := &amp;gorm.Config{
                Logger: NewGormLogger(df.logger, logLevel),
        }

        // 打开数据库连接
        db, err := gorm.Open(mysql.Open(dsn), gormConfig)
        if err != nil </span><span class="cov0" title="0">{
                df.logger.Log(log.LevelError, "msg", "failed to open database", "type", dbType, "error", err)
                return nil, fmt.Errorf("failed to open database %s: %w", dbType, err)
        }</span>

        // 配置连接池
        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get underlying sql.DB for %s: %w", dbType, err)
        }</span>

        // 设置连接池参数
        <span class="cov0" title="0">if config.MaxOpenConns &gt; 0 </span><span class="cov0" title="0">{
                sqlDB.SetMaxOpenConns(config.MaxOpenConns)
        }</span>
        <span class="cov0" title="0">if config.MaxIdleConns &gt; 0 </span><span class="cov0" title="0">{
                sqlDB.SetMaxIdleConns(config.MaxIdleConns)
        }</span>
        <span class="cov0" title="0">if config.ConnMaxLifetime &gt; 0 </span><span class="cov0" title="0">{
                sqlDB.SetConnMaxLifetime(config.ConnMaxLifetime)
        }</span>

        <span class="cov0" title="0">df.logger.Log(log.LevelInfo, "msg", "database connection created",
                "type", dbType, "max_open_conns", config.MaxOpenConns,
                "max_idle_conns", config.MaxIdleConns)

        return db, nil</span>
}

// getDSN 获取数据库连接字符串
func (df *DatabaseFactory) getDSN(config *DatabaseConnectionConfig) (string, error) <span class="cov0" title="0">{
        var dsn string

        // 开发环境直接使用配置的连接字符串
        if config.Env == "dev" || config.Env == "development" </span><span class="cov0" title="0">{
                dsn = config.Source
        }</span> else<span class="cov0" title="0"> {
                // 生产环境从环境变量获取加密的连接字符串
                if config.SourceKey == "" </span><span class="cov0" title="0">{
                        return "", errors.New("source_key is required for non-dev environment")
                }</span>

                <span class="cov0" title="0">encryptedDsn, err := conf.GetEnv(config.SourceKey)
                if err != nil </span><span class="cov0" title="0">{
                        df.logger.Log(log.LevelError, "msg", "failed to get environment variable",
                                "key", config.SourceKey, "error", err)
                        return "", fmt.Errorf("failed to get environment variable %s: %w", config.SourceKey, err)
                }</span>

                // 解密连接字符串
                <span class="cov0" title="0">appSecret := conf.Get().GetApp().GetAppSecret()
                dsn, err = cipherutil.DecryptByAes(encryptedDsn, appSecret)
                if err != nil </span><span class="cov0" title="0">{
                        df.logger.Log(log.LevelError, "msg", "failed to decrypt DSN",
                                "key", config.SourceKey, "error", err)
                        return "", fmt.Errorf("failed to decrypt DSN for %s: %w", config.SourceKey, err)
                }</span>

                <span class="cov0" title="0">if len(dsn) == 0 </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("decrypted DSN is empty for %s", config.SourceKey)
                }</span>
        }

        // 确保连接字符串包含必要的参数
        <span class="cov0" title="0">if !strings.Contains(dsn, "parseTime=True") </span><span class="cov0" title="0">{
                if strings.Contains(dsn, "?") </span><span class="cov0" title="0">{
                        dsn += "&amp;parseTime=True"
                }</span> else<span class="cov0" title="0"> {
                        dsn += "?parseTime=True"
                }</span>
        }

        // 添加超时参数
        <span class="cov0" title="0">if !strings.Contains(dsn, "timeout=") </span><span class="cov0" title="0">{
                if strings.Contains(dsn, "?") </span><span class="cov0" title="0">{
                        dsn += "&amp;timeout=15s"
                }</span> else<span class="cov0" title="0"> {
                        dsn += "?timeout=15s"
                }</span>
        }

        // 添加字符集参数
        <span class="cov0" title="0">if !strings.Contains(dsn, "charset=") </span><span class="cov0" title="0">{
                if strings.Contains(dsn, "?") </span><span class="cov0" title="0">{
                        dsn += "&amp;charset=utf8mb4"
                }</span> else<span class="cov0" title="0"> {
                        dsn += "?charset=utf8mb4"
                }</span>
        }

        <span class="cov0" title="0">return dsn, nil</span>
}

// DatabaseConnectionConfig 数据库连接配置
type DatabaseConnectionConfig struct {
        Source          string        // 连接字符串（开发环境使用）
        SourceKey       string        // 环境变量键名（生产环境使用）
        Env             string        // 环境：dev, prod, test
        MaxOpenConns    int           // 最大打开连接数
        MaxIdleConns    int           // 最大空闲连接数
        ConnMaxLifetime time.Duration // 连接最大生命周期
        LogLevel        string        // 日志级别：silent, error, warn, info
        Enable          bool          // 是否启用
}

// NewDatabaseConnectionConfig 创建数据库连接配置
func NewDatabaseConnectionConfig() *DatabaseConnectionConfig <span class="cov0" title="0">{
        return &amp;DatabaseConnectionConfig{
                MaxOpenConns:    20,
                MaxIdleConns:    10,
                ConnMaxLifetime: 6 * time.Hour,
                LogLevel:        "info",
                Enable:          true,
        }
}</span>

// CreateMainDBConfig 创建主数据库配置
func (df *DatabaseFactory) CreateMainDBConfig() *DatabaseConnectionConfig <span class="cov0" title="0">{
        config := NewDatabaseConnectionConfig()

        if df.config.Database != nil </span><span class="cov0" title="0">{
                config.Source = df.config.Database.Source
                config.SourceKey = df.config.Database.SourceKey
                config.Env = df.config.Database.Env
                config.MaxOpenConns = int(df.config.Database.MaxOpenConns)
                config.MaxIdleConns = int(df.config.Database.MaxIdleConns)
                config.Enable = df.config.Database.Enable

                if df.config.Database.ConnMaxLifetime != "" </span><span class="cov0" title="0">{
                        if duration, err := time.ParseDuration(df.config.Database.ConnMaxLifetime); err == nil </span><span class="cov0" title="0">{
                                config.ConnMaxLifetime = duration
                        }</span>
                }
        }

        <span class="cov0" title="0">return config</span>
}

// CreateSyncDBConfig 创建同步数据库配置
func (df *DatabaseFactory) CreateSyncDBConfig() *DatabaseConnectionConfig <span class="cov0" title="0">{
        config := NewDatabaseConnectionConfig()

        if df.config.DatabaseSync != nil </span><span class="cov0" title="0">{
                config.Source = df.config.DatabaseSync.Source
                config.SourceKey = df.config.DatabaseSync.SourceKey
                config.Env = df.config.DatabaseSync.Env
                config.MaxOpenConns = int(df.config.DatabaseSync.MaxOpenConns)
                config.MaxIdleConns = int(df.config.DatabaseSync.MaxIdleConns)

                if df.config.DatabaseSync.ConnMaxLifetime != "" </span><span class="cov0" title="0">{
                        if duration, err := time.ParseDuration(df.config.DatabaseSync.ConnMaxLifetime); err == nil </span><span class="cov0" title="0">{
                                config.ConnMaxLifetime = duration
                        }</span>
                }
        }

        <span class="cov0" title="0">return config</span>
}

// CreateSagaDBConfig 创建 Saga 数据库配置
func (df *DatabaseFactory) CreateSagaDBConfig() *DatabaseConnectionConfig <span class="cov0" title="0">{
        config := NewDatabaseConnectionConfig()

        // 从配置中获取 Saga 数据库配置
        // 注意：这里需要根据实际的配置结构进行调整
        // 如果配置中没有专门的 Saga 数据库配置，可以使用主数据库配置
        if df.config.Database != nil </span><span class="cov0" title="0">{
                config.Source = df.config.Database.Source
                config.SourceKey = df.config.Database.SourceKey
                config.Env = df.config.Database.Env
                config.MaxOpenConns = int(df.config.Database.MaxOpenConns)
                config.MaxIdleConns = int(df.config.Database.MaxIdleConns)
                config.Enable = df.config.Database.Enable

                if df.config.Database.ConnMaxLifetime != "" </span><span class="cov0" title="0">{
                        if duration, err := time.ParseDuration(df.config.Database.ConnMaxLifetime); err == nil </span><span class="cov0" title="0">{
                                config.ConnMaxLifetime = duration
                        }</span>
                }
        }

        <span class="cov0" title="0">return config</span>
}

// CreateUserDBConfig 创建用户数据库配置（示例）
func (df *DatabaseFactory) CreateUserDBConfig() *DatabaseConnectionConfig <span class="cov0" title="0">{
        config := NewDatabaseConnectionConfig()
        // 这里可以根据实际需求配置用户数据库
        // 可以从配置文件、环境变量等获取配置
        return config
}</span>

// CreateLogDBConfig 创建日志数据库配置（示例）
func (df *DatabaseFactory) CreateLogDBConfig() *DatabaseConnectionConfig <span class="cov0" title="0">{
        config := NewDatabaseConnectionConfig()
        // 这里可以根据实际需求配置日志数据库
        return config
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package data

import (
        "fmt"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/go-redis/redis/v8"
)

// DatabaseInitializer 数据库初始化器
type DatabaseInitializer struct {
        factory *DatabaseFactory
        logger  log.Logger
}

// NewDatabaseInitializer 创建数据库初始化器
func NewDatabaseInitializer(factory *DatabaseFactory, logger log.Logger) *DatabaseInitializer <span class="cov0" title="0">{
        return &amp;DatabaseInitializer{
                factory: factory,
                logger:  logger,
        }
}</span>

// InitializeDatabases 初始化所有数据库连接
func (di *DatabaseInitializer) InitializeDatabases() (*DatabaseManager, error) <span class="cov0" title="0">{
        dbManager := NewDatabaseManager()

        // 初始化主数据库
        if err := di.initializeMainDB(dbManager); err != nil </span><span class="cov0" title="0">{
                di.logger.Log(log.LevelError, "msg", "failed to initialize main database", "error", err)
                return nil, fmt.Errorf("failed to initialize main database: %w", err)
        }</span>

        // 初始化同步数据库
        <span class="cov0" title="0">if err := di.initializeSyncDB(dbManager); err != nil </span><span class="cov0" title="0">{
                di.logger.Log(log.LevelError, "msg", "failed to initialize sync database", "error", err)
                return nil, fmt.Errorf("failed to initialize sync database: %w", err)
        }</span>

        // 初始化 Saga 数据库
        <span class="cov0" title="0">if err := di.initializeSagaDB(dbManager); err != nil </span><span class="cov0" title="0">{
                di.logger.Log(log.LevelWarn, "msg", "failed to initialize saga database", "error", err)
                // Saga 数据库初始化失败不影响主流程
        }</span>

        // 初始化用户数据库（可选）
        <span class="cov0" title="0">if err := di.initializeUserDB(dbManager); err != nil </span><span class="cov0" title="0">{
                di.logger.Log(log.LevelWarn, "msg", "failed to initialize user database", "error", err)
                // 用户数据库初始化失败不影响主流程
        }</span>

        // 初始化日志数据库（可选）
        <span class="cov0" title="0">if err := di.initializeLogDB(dbManager); err != nil </span><span class="cov0" title="0">{
                di.logger.Log(log.LevelWarn, "msg", "failed to initialize log database", "error", err)
                // 日志数据库初始化失败不影响主流程
        }</span>

        <span class="cov0" title="0">di.logger.Log(log.LevelInfo, "msg", "all databases initialized successfully")
        return dbManager, nil</span>
}

// initializeMainDB 初始化主数据库
func (di *DatabaseInitializer) initializeMainDB(dbManager *DatabaseManager) error <span class="cov0" title="0">{
        config := di.factory.CreateMainDBConfig()

        if !config.Enable </span><span class="cov0" title="0">{
                di.logger.Log(log.LevelInfo, "msg", "main database is disabled")
                return nil
        }</span>

        <span class="cov0" title="0">db, err := di.factory.CreateDatabase(MainDBType, config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create main database: %w", err)
        }</span>

        <span class="cov0" title="0">dbManager.RegisterDatabase(MainDBType, "main", db, config)
        di.logger.Log(log.LevelInfo, "msg", "main database initialized successfully")
        return nil</span>
}

// initializeSyncDB 初始化同步数据库
func (di *DatabaseInitializer) initializeSyncDB(dbManager *DatabaseManager) error <span class="cov0" title="0">{
        config := di.factory.CreateSyncDBConfig()

        if !config.Enable </span><span class="cov0" title="0">{
                di.logger.Log(log.LevelInfo, "msg", "sync database is disabled")
                return nil
        }</span>

        <span class="cov0" title="0">db, err := di.factory.CreateDatabase(SyncDBType, config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create sync database: %w", err)
        }</span>

        <span class="cov0" title="0">dbManager.RegisterDatabase(SyncDBType, "sync", db, config)
        di.logger.Log(log.LevelInfo, "msg", "sync database initialized successfully")
        return nil</span>
}

// initializeUserDB 初始化用户数据库
func (di *DatabaseInitializer) initializeUserDB(dbManager *DatabaseManager) error <span class="cov0" title="0">{
        config := di.factory.CreateUserDBConfig()

        if !config.Enable </span><span class="cov0" title="0">{
                di.logger.Log(log.LevelInfo, "msg", "user database is disabled")
                return nil
        }</span>

        <span class="cov0" title="0">db, err := di.factory.CreateDatabase(UserDBType, config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create user database: %w", err)
        }</span>

        <span class="cov0" title="0">dbManager.RegisterDatabase(UserDBType, "user", db, config)
        di.logger.Log(log.LevelInfo, "msg", "user database initialized successfully")
        return nil</span>
}

// initializeLogDB 初始化日志数据库
func (di *DatabaseInitializer) initializeLogDB(dbManager *DatabaseManager) error <span class="cov0" title="0">{
        config := di.factory.CreateLogDBConfig()

        if !config.Enable </span><span class="cov0" title="0">{
                di.logger.Log(log.LevelInfo, "msg", "log database is disabled")
                return nil
        }</span>

        <span class="cov0" title="0">db, err := di.factory.CreateDatabase(LogDBType, config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create log database: %w", err)
        }</span>

        <span class="cov0" title="0">dbManager.RegisterDatabase(LogDBType, "log", db, config)
        di.logger.Log(log.LevelInfo, "msg", "log database initialized successfully")
        return nil</span>
}

// initializeSagaDB 初始化 Saga 数据库
func (di *DatabaseInitializer) initializeSagaDB(dbManager *DatabaseManager) error <span class="cov0" title="0">{
        config := di.factory.CreateSagaDBConfig()

        if !config.Enable </span><span class="cov0" title="0">{
                di.logger.Log(log.LevelInfo, "msg", "saga database is disabled")
                return nil
        }</span>

        <span class="cov0" title="0">db, err := di.factory.CreateDatabase(SagaDBType, config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create saga database: %w", err)
        }</span>

        <span class="cov0" title="0">dbManager.RegisterDatabase(SagaDBType, "saga", db, config)
        di.logger.Log(log.LevelInfo, "msg", "saga database initialized successfully")
        return nil</span>
}

// NewDataWithFactory 使用数据库工厂创建数据层实例
func NewDataWithFactory(
        factory *DatabaseFactory,
        redis *redis.Client,
        logger log.Logger,
) (*Data, func(), error) <span class="cov0" title="0">{
        // 创建数据库初始化器
        initializer := NewDatabaseInitializer(factory, logger)

        // 初始化所有数据库
        dbManager, err := initializer.InitializeDatabases()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to initialize databases: %w", err)
        }</span>

        // 获取主数据库用于 Saga 存储（也可以使用专门的 Saga 数据库）
        <span class="cov0" title="0">mainDB, err := dbManager.GetDatabase(MainDBType)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log(log.LevelError, "msg", "failed to get main database for saga", "error", err)
                mainDB = nil
        }</span>

        <span class="cov0" title="0">var sagaRepo *SagaRepository
        if mainDB != nil </span><span class="cov0" title="0">{
                sagaRepo = NewSagaRepository(mainDB)
        }</span>

        <span class="cov0" title="0">data := &amp;Data{
                dbManager: dbManager,
                redis:     redis,
                logger:    logger,
                sagaRepo:  sagaRepo,
        }

        // 返回清理函数
        cleanup := func() </span><span class="cov0" title="0">{
                data.cleanup()
        }</span>

        <span class="cov0" title="0">return data, cleanup, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// internal/data/etcd/client.go
package etcd

import (
        "nancalacc/internal/conf"
        "time"

        clientv3 "go.etcd.io/etcd/client/v3"
)

type Client struct {
        cli    *clientv3.Client
        prefix string
}

func New(cfg *conf.Data_Etcd) (*Client, error) <span class="cov0" title="0">{
        cli, err := clientv3.New(clientv3.Config{
                Endpoints:   cfg.Endpoints,
                DialTimeout: 5 * time.Second,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{cli: cli, prefix: cfg.ConfigPrefix}, nil</span>
}

func (c *Client) Close() error <span class="cov0" title="0">{
        return c.cli.Close()
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// internal/data/etcd/config.go
package etcd

import (
        "context"
        "encoding/json"
        "errors"

        clientv3 "go.etcd.io/etcd/client/v3"
)

// 获取完整配置key
func (c *Client) fullKey(key string) string <span class="cov0" title="0">{
        return c.prefix + "/" + key
}</span>

// 获取配置（JSON格式）
func (c *Client) GetConfig(ctx context.Context, key string, out interface{}) error <span class="cov0" title="0">{
        resp, err := c.cli.Get(ctx, c.fullKey(key))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(resp.Kvs) == 0 </span><span class="cov0" title="0">{
                return errors.New("config not found")
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(resp.Kvs[0].Value, out)</span>
}

// 监听配置变更
func (c *Client) WatchConfig(ctx context.Context, key string, callback func([]byte)) error <span class="cov0" title="0">{
        watchChan := c.cli.Watch(ctx, c.fullKey(key))
        for resp := range watchChan </span><span class="cov0" title="0">{
                for _, ev := range resp.Events </span><span class="cov0" title="0">{
                        if ev.Type == clientv3.EventTypePut </span><span class="cov0" title="0">{
                                callback(ev.Kv.Value)
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package data

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        "gorm.io/gorm"
        gormlogger "gorm.io/gorm/logger"
)

// GormLogger 实现GORM logger接口，使用OpenTelemetry logger
type GormLogger struct {
        logger   log.Logger
        logLevel gormlogger.LogLevel
}

// NewGormLogger 创建新的GORM logger
func NewGormLogger(logger log.Logger, level string) gormlogger.Interface <span class="cov0" title="0">{
        var logLevel gormlogger.LogLevel
        switch level </span>{
        case "silent":<span class="cov0" title="0">
                logLevel = gormlogger.Silent</span>
        case "error":<span class="cov0" title="0">
                logLevel = gormlogger.Error</span>
        case "warn":<span class="cov0" title="0">
                logLevel = gormlogger.Warn</span>
        case "info":<span class="cov0" title="0">
                logLevel = gormlogger.Info</span>
        default:<span class="cov0" title="0">
                logLevel = gormlogger.Info</span>
        }

        <span class="cov0" title="0">return &amp;GormLogger{
                logger:   logger,
                logLevel: logLevel,
        }</span>
}

// LogMode 设置日志级别
func (l *GormLogger) LogMode(level gormlogger.LogLevel) gormlogger.Interface <span class="cov0" title="0">{
        newLogger := *l
        newLogger.logLevel = level
        return &amp;newLogger
}</span>

// Info 记录信息日志
func (l *GormLogger) Info(ctx context.Context, msg string, data ...interface{}) <span class="cov0" title="0">{
        if l.logLevel &gt;= gormlogger.Info </span><span class="cov0" title="0">{
                l.logger.Log(log.LevelInfo, "msg", fmt.Sprintf(msg, data...))
        }</span>
}

// Warn 记录警告日志
func (l *GormLogger) Warn(ctx context.Context, msg string, data ...interface{}) <span class="cov0" title="0">{
        if l.logLevel &gt;= gormlogger.Warn </span><span class="cov0" title="0">{
                l.logger.Log(log.LevelWarn, "msg", fmt.Sprintf(msg, data...))
        }</span>
}

// Error 记录错误日志
func (l *GormLogger) Error(ctx context.Context, msg string, data ...interface{}) <span class="cov0" title="0">{
        if l.logLevel &gt;= gormlogger.Error </span><span class="cov0" title="0">{
                l.logger.Log(log.LevelError, "msg", fmt.Sprintf(msg, data...))
        }</span>
}

// Trace 记录SQL跟踪日志
func (l *GormLogger) Trace(ctx context.Context, begin time.Time, fc func() (string, int64), err error) <span class="cov0" title="0">{
        if l.logLevel &lt;= gormlogger.Silent </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">elapsed := time.Since(begin)
        sql, rows := fc()

        // 记录慢查询
        if elapsed &gt; time.Second &amp;&amp; l.logLevel &gt;= gormlogger.Warn </span><span class="cov0" title="0">{
                l.logger.Log(log.LevelWarn, "msg", "slow sql query",
                        "sql", sql,
                        "rows", rows,
                        "elapsed", elapsed.String())
                return
        }</span>

        // 记录错误
        <span class="cov0" title="0">if err != nil &amp;&amp; !errors.Is(err, gorm.ErrRecordNotFound) &amp;&amp; l.logLevel &gt;= gormlogger.Error </span><span class="cov0" title="0">{
                l.logger.Log(log.LevelError, "msg", "sql error",
                        "sql", sql,
                        "rows", rows,
                        "elapsed", elapsed.String(),
                        "error", err)
                return
        }</span>

        // 记录普通SQL日志
        <span class="cov0" title="0">if l.logLevel &gt;= gormlogger.Info </span><span class="cov0" title="0">{
                l.logger.Log(log.LevelInfo, "msg", "sql query",
                        "sql", sql,
                        "rows", rows,
                        "elapsed", elapsed.String())
        }</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package data

import (
        "context"
        "nancalacc/internal/biz"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/patrickmn/go-cache"
)

type localCacheService struct {
        client *cache.Cache
        logger log.Logger
}

var (
        DefaultExpiration = 5 * time.Minute
        CleanupInterval   = 10 * time.Minute
)

func NewLocalCacheService(logger log.Logger) biz.CacheService <span class="cov0" title="0">{
        return &amp;localCacheService{
                client: cache.New(DefaultExpiration, CleanupInterval),
                logger: logger,
        }
}</span>

func (s *localCacheService) Set(ctx context.Context, key string, value interface{}, d time.Duration) error <span class="cov0" title="0">{
        s.client.Set(key, value, d)
        return nil
}</span>

func (s *localCacheService) Get(ctx context.Context, key string) (interface{}, bool, error) <span class="cov0" title="0">{
        res, ok := s.client.Get(key)
        if !ok </span><span class="cov0" title="0">{
                return nil, false, nil
        }</span>
        <span class="cov0" title="0">return res, true, nil</span>
}

func (s *localCacheService) Del(ctx context.Context, key string) error <span class="cov0" title="0">{
        s.client.Delete(key)
        return nil
}</span>

// other methods...
</pre>
		
		<pre class="file" id="file29" style="display: none">package data

import (
        "nancalacc/internal/data/models"
        "time"

        "gorm.io/gorm"
)

func Migrate(db *gorm.DB) error <span class="cov0" title="0">{

        if err := db.Migrator().DropTable(&amp;models.TbLasDepartment{}, &amp;models.TbLasUser{}, &amp;models.TbLasDepartmentUser{}, &amp;models.TbCompanyCfg{}, &amp;models.Task{}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := db.AutoMigrate(&amp;models.TbLasDepartment{}, &amp;models.TbLasUser{}, &amp;models.TbLasDepartmentUser{}, &amp;models.TbCompanyCfg{}, &amp;models.Task{}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">db.Create(&amp;models.TbCompanyCfg{
                ThirdCompanyId: "1",
                PlatformIds:    "1",
                CompanyId:      "1",
                Status:         0,
                Ctime:          time.Now(),
                Mtime:          time.Now(),
        })
        return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package models

import (
        "gorm.io/gorm"
)

// 数据库实体
type Account struct {
        gorm.Model
        ID        int64  `gorm:"column:id;primaryKey"`
        Username  string `gorm:"column:username;size:255;uniqueIndex"`
        Email     string `gorm:"column:email;size:255;uniqueIndex"`
        Phone     string `gorm:"column:phone;size:20"`
        Password  string `gorm:"column:password;size:255"`
        Status    int32  `gorm:"column:status;default:1"`
        CreatedAt int64  `gorm:"column:created_at"`
        UpdatedAt int64  `gorm:"column:updated_at"`
}

func (a *Account) TableName() string <span class="cov0" title="0">{
        return "nancal_account"
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package models

import (
        "time"
)

// 租户关系配置表
type TbCompanyCfg struct {
        Id             uint      `gorm:"primaryKey;autoIncrement;column:id;type:int unsigned;comment:主键id" json:"id"`
        ThirdCompanyId string    `gorm:"column:third_company_id;type:varchar(20);comment:三方租户id;NOT NULL" json:"third_company_id"`
        PlatformIds    string    `gorm:"column:platform_ids;type:varchar(100);comment:平台id, 用来区分多种数据源,多个用逗号分隔;NOT NULL" json:"platform_ids"`
        CompanyId      string    `gorm:"column:company_id;type:varchar(20);comment:云文档租户id;NOT NULL" json:"company_id"`
        Status         int       `gorm:"column:status;type:tinyint(4);default:1;comment:状态,0-禁用,1-启用;NOT NULL" json:"status"`
        Ctime          time.Time `gorm:"column:ctime;type:timestamp;default:CURRENT_TIMESTAMP;comment:创建时间" json:"ctime"`
        Mtime          time.Time `gorm:"column:mtime;type:timestamp;default:CURRENT_TIMESTAMP;comment:更新时间;NOT NULL" json:"mtime"`
}

func (m *TbCompanyCfg) TableName() string <span class="cov0" title="0">{
        return "tb_company_cfg"
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package models

import (
        "fmt"
        "nancalacc/internal/dingtalk"
        "nancalacc/internal/pkg/cipherutil"
        "strconv"
        "time"
)

func MakeLasUser(user *dingtalk.DingtalkDeptUser, thirdCompanyID, platformID, source, taskId string) *TbLasUser <span class="cov0" title="0">{
        //var account string
        // if user.Mobile != "" {
        //         account = user.Mobile
        // } else {
        //         account = user.Userid
        // }
        account := user.Mobile
        now := time.Now()
        mobile, err := cipherutil.EncryptUserInfo(user.Mobile, user.Userid)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[ERROR]EncryptUserInfo userid:%s, mobile: %s mobile: %s, err: %v\n", user.Userid, user.Mobile, mobile, err)
        }</span>

        <span class="cov0" title="0">entity := &amp;TbLasUser{
                TaskID:         taskId,
                ThirdCompanyID: thirdCompanyID,
                PlatformID:     platformID,
                Uid:            user.Userid,
                DefDid:         "-1",
                DefDidOrder:    0,
                Account:        account,
                NickName:       user.Name,
                Email:          user.Email,
                // Phone:         user.Mobile,
                Phone:            mobile,
                Title:            user.Title,
                Source:           source,
                Ctime:            now,
                Mtime:            now,
                CheckType:        1,
                EmploymentStatus: "active",
                EmploymentType:   "permanent",
        }
        if len(user.LeaderInDept) &gt; 0 </span>{<span class="cov0" title="0">
                //entity.Leader = user.LeaderInDept[0].Leader
        }</span>
        <span class="cov0" title="0">return entity</span>
}

func MakeTbLasDepartment(dep *dingtalk.DingtalkDept, thirdCompanyID, platformID, companyID, source, taskId string) *TbLasDepartment <span class="cov0" title="0">{

        now := time.Now()
        return &amp;TbLasDepartment{
                Did:            strconv.FormatInt(dep.DeptID, 10),
                TaskID:         taskId,
                Name:           dep.Name,
                ThirdCompanyID: thirdCompanyID,
                PlatformID:     platformID,
                Pid:            strconv.FormatInt(dep.ParentID, 10),
                Order:          int(dep.Order),
                Source:         "sync",
                Ctime:          now,
                Mtime:          now,
                CheckType:      1,
        }
}</span>

func MakeTbLasRootDepartment(thirdCompanyID, platformID, companyID, source, taskId string) *TbLasDepartment <span class="cov0" title="0">{

        now := time.Now()
        return &amp;TbLasDepartment{
                Did:            "0",
                TaskID:         taskId,
                Name:           companyID,
                ThirdCompanyID: thirdCompanyID,
                PlatformID:     platformID,
                Pid:            "-1",
                Order:          0,
                Source:         source,
                Ctime:          now,
                Mtime:          now,
                CheckType:      1,
        }
}</span>

func MakeTbLasDepartmentUser(relation *dingtalk.DingtalkDeptUserRelation, thirdCompanyID, platformID, companyID, source, taskId string) *TbLasDepartmentUser <span class="cov0" title="0">{

        return &amp;TbLasDepartmentUser{
                Did:            relation.Did,
                TaskID:         taskId,
                ThirdCompanyID: thirdCompanyID,
                PlatformID:     platformID,
                Uid:            relation.Uid,
                Ctime:          time.Now(),
                Order:          int(relation.Order),
                CheckType:      1,
        }
}</span>

func MakeLasUserIncrement(user *dingtalk.DingtalkDeptUser, thirdCompanyID, platformID, companyID, source, updateType string) *TbLasUserIncrement <span class="cov0" title="0">{

        // var account string
        // if user.Mobile != "" {
        //         account = user.Mobile
        // } else {
        //         account = user.Userid
        // }
        account := user.Mobile
        now := time.Now()

        mobile, err := cipherutil.EncryptUserInfo(user.Mobile, user.Userid)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[ERROR]EncryptUserInfo userid:%s, mobile: %s mobile: %s, err: %v\n", user.Userid, user.Mobile, mobile, err)
        }</span>

        <span class="cov0" title="0">entity := &amp;TbLasUserIncrement{
                ThirdCompanyID: thirdCompanyID,
                PlatformID:     platformID,
                Uid:            user.Userid,
                DefDid:         "-1",
                DefDidOrder:    0,
                Account:        account,
                NickName:       user.Name,
                Email:          user.Email,
                // Phone:            user.Mobile,
                Phone:            mobile,
                Title:            user.Title,
                Source:           source,
                Ctime:            now,
                Mtime:            now,
                EmploymentStatus: "active",
                EmploymentType:   "permanent",
                UpdateType:       updateType,
                SyncType:         "auto",
                SyncTime:         now,
                Status:           0,
        }
        if len(user.LeaderInDept) &gt; 0 </span>{<span class="cov0" title="0">
                //entity.Leader = user.LeaderInDept[0].Leader
        }</span>
        <span class="cov0" title="0">return entity</span>
}

func MakeDepartmentIncrement(dept *dingtalk.DingtalkDept, thirdCompanyID, platformID, companyID, source, updateType string) *TbLasDepartmentIncrement <span class="cov0" title="0">{

        now := time.Now()
        entity := &amp;TbLasDepartmentIncrement{
                Did:            strconv.FormatInt(dept.DeptID, 10),
                Name:           dept.Name,
                ThirdCompanyID: thirdCompanyID,
                PlatformID:     platformID,
                //Pid:            strconv.FormatInt(dept.ParentID, 10),
                Order:      int32(dept.Order),
                Source:     "sync",
                Ctime:      now,
                Mtime:      now,
                UpdateType: updateType,
                SyncTime:   now,
                SyncType:   "auto",
                Status:     0,
        }
        if dept.ParentID != 0 </span><span class="cov0" title="0">{
                entity.Pid = strconv.FormatInt(dept.ParentID, 10)
        }</span> else<span class="cov0" title="0"> {
                entity.Pid = "-1"
        }</span>
        <span class="cov0" title="0">return entity</span>

}

func MmakeTbLasDepartmentUserIncrement(relation *dingtalk.DingtalkDeptUserRelation, thirdCompanyID, platformID, companyID, source, updateType string) *TbLasDepartmentUserIncrement <span class="cov0" title="0">{
        now := time.Now()
        entity := &amp;TbLasDepartmentUserIncrement{
                Did:            relation.Did,
                ThirdCompanyID: thirdCompanyID,
                PlatformID:     platformID,
                Uid:            relation.Uid,
                Ctime:          now,
                Order:          1,
                UpdateType:     updateType,
                SyncType:       "auto",
                SyncTime:       now,
                Status:         0,
        }

        return entity

}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package models

import (
        "time"
)

// 全量部门采集表
type TbLasDepartment struct {
        ID             uint      `gorm:"primaryKey;autoIncrement;column:id;type:int unsigned;comment:主键id" json:"id"`
        Did            string    `gorm:"not null;column:did;type:varchar(255);comment:部门id" json:"did"`
        TaskID         string    `gorm:"not null;column:task_id;type:varchar(20);comment:任务id" json:"task_id"`
        ThirdCompanyID string    `gorm:"not null;column:third_company_id;type:varchar(20);comment:租户id" json:"third_company_id"`
        PlatformID     string    `gorm:"not null;column:platform_id;type:varchar(60);comment:平台id" json:"platform_id"`
        Pid            string    `gorm:"column:pid;type:varchar(255);comment:父部门id" json:"pid"`
        Name           string    `gorm:"not null;column:name;type:varchar(255);comment:部门名称" json:"name"`
        Order          int       `gorm:"column:order;type:int;default:0;comment:排序" json:"order"`
        Source         string    `gorm:"column:source;type:varchar(20);default:sync;comment:来源" json:"source"`
        Ctime          time.Time `gorm:"column:ctime;type:timestamp;default:CURRENT_TIMESTAMP;comment:创建时间" json:"ctime"`
        Mtime          time.Time `gorm:"not null;column:mtime;type:timestamp;comment:修改时间" json:"mtime"`
        CheckType      int8      `gorm:"not null;column:check_type;type:tinyint;default:0;comment:1-勾选 0-未勾选" json:"check_type"`
        Type           string    `gorm:"column:type;type:varchar(255);comment:类型" json:"type"`
}

// TableName 设置表名
func (TbLasDepartment) TableName() string <span class="cov0" title="0">{
        return "tb_las_department"
}</span>

// 增量部门采集表
type TbLasDepartmentIncrement struct {
        ID             uint      `gorm:"primaryKey;autoIncrement;column:id;comment:主键id"`
        Did            string    `gorm:"not null;column:did;size:255;comment:部门id"`
        ThirdCompanyID string    `gorm:"not null;column:third_company_id;size:20;comment:租户id"`
        PlatformID     string    `gorm:"not null;column:platform_id;size:60;comment:平台id"`
        Pid            string    `gorm:"column:pid;size:255;comment:父部门id"`
        Name           string    `gorm:"not null;column:name;size:255;comment:部门名称"`
        Order          int32     `gorm:"column:order;comment:排序"`
        Source         string    `gorm:"column:source;size:20;default:sync;comment:来源"`
        SyncType       string    `gorm:"column:sync_type;size:20;default:auto;comment:同步方式"`
        UpdateType     string    `gorm:"not null;column:update_type;size:20;comment:修改类型"`
        Status         int       `gorm:"column:status;default:0;comment:状态"`
        Msg            string    `gorm:"column:msg;size:2000;comment:错误详情"`
        Operator       string    `gorm:"column:operator;size:100;default:系统;comment:operator"`
        SyncTime       time.Time `gorm:"column:sync_time;default:CURRENT_TIMESTAMP;comment:增量数据变动时间"`
        Ctime          time.Time `gorm:"column:ctime;default:CURRENT_TIMESTAMP;comment:创建时间"`
        Mtime          time.Time `gorm:"not null;column:mtime;comment:修改时间"`
        Type           string    `gorm:"column:type;size:255;comment:类型"`
}

func (TbLasDepartmentIncrement) TableName() string <span class="cov0" title="0">{
        return "tb_las_department_increment"
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package models

import (
        "time"
)

// 全量部门用户关系表
type TbLasDepartmentUser struct {
        ID             uint      `gorm:"primaryKey;autoIncrement;column:id;type:int unsigned;comment:主键id"`
        TaskID         string    `gorm:"not null;column:task_id;type:varchar(20);comment:任务id"`
        ThirdCompanyID string    `gorm:"not null;column:third_company_id;type:varchar(20);comment:租户id"`
        PlatformID     string    `gorm:"not null;column:platform_id;type:varchar(60);comment:平台id"`
        Uid            string    `gorm:"not null;column:uid;type:varchar(255);comment:用户id"`
        Did            string    `gorm:"not null;column:did;type:varchar(255);comment:部门id"`
        Order          int       `gorm:"column:order;type:int;comment:排序"`
        Main           int       `gorm:"column:main;type:int;default:0;comment:是否是主部门"`
        Ctime          time.Time `gorm:"not null;column:ctime;type:timestamp;default:CURRENT_TIMESTAMP;comment:创建时间"`
        CheckType      int8      `gorm:"not null;column:check_type;type:tinyint;default:0;comment:勾选状态"`
}

func (TbLasDepartmentUser) TableName() string <span class="cov0" title="0">{
        return "tb_las_department_user"
}</span>

// 增量部门用户关系表
type TbLasDepartmentUserIncrement struct {
        ID             uint      `gorm:"primaryKey;autoIncrement;column:id;type:int unsigned;comment:主键id"`
        ThirdCompanyID string    `gorm:"not null;column:third_company_id;type:varchar(20);comment:租户id"`
        PlatformID     string    `gorm:"not null;column:platform_id;type:varchar(60);comment:平台id"`
        Uid            string    `gorm:"not null;column:uid;type:varchar(255);comment:用户id"`
        Did            string    `gorm:"not null;column:did;type:varchar(255);comment:默认部门id"`
        Order          int       `gorm:"column:order;type:int;comment:排序"`
        Main           int       `gorm:"column:main;type:int;default:0;comment:是否是主部门"`
        SyncType       string    `gorm:"column:sync_type;type:varchar(20);default:auto;comment:同步方式"`
        UpdateType     string    `gorm:"not null;column:update_type;type:varchar(20);comment:修改类型"`
        Status         int       `gorm:"column:status;type:int;default:0;comment:状态"`
        Msg            string    `gorm:"column:msg;type:varchar(2000);comment:错误详情"`
        Operator       string    `gorm:"column:operator;type:varchar(100);default:系统;comment:operator"`
        SyncTime       time.Time `gorm:"column:sync_time;type:timestamp;default:CURRENT_TIMESTAMP;comment:增量数据变动时间"`
        Ctime          time.Time `gorm:"not null;column:ctime;type:timestamp;default:CURRENT_TIMESTAMP;comment:创建时间"`
        Mtime          time.Time `gorm:"not null;column:mtime;type:timestamp;comment:修改时间"`
        Dids           string    `gorm:"column:dids;type:varchar(5000);comment:dids"`
}

func (TbLasDepartmentUserIncrement) TableName() string <span class="cov0" title="0">{
        return "tb_las_department_user_increment"
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package models

import (
        "time"

        "gorm.io/gorm"
)

// SagaTransaction Saga 事务（对应文档中的 saga_transactions 表）
type SagaTransaction struct {
        ID            uint           `gorm:"primarykey" json:"id"`
        TransactionID string         `gorm:"uniqueIndex;size:64;not null" json:"transaction_id"` // Saga 事务唯一标识
        Name          string         `gorm:"size:255;not null" json:"name"`                      // 事务名称
        Status        SagaStatus     `gorm:"size:20;not null;default:'pending'" json:"status"`   // Saga 状态
        CurrentStep   string         `gorm:"size:64" json:"current_step"`                        // 当前步骤
        Progress      int            `gorm:"default:0" json:"progress"`                          // 进度百分比
        StartTime     time.Time      `json:"start_time"`                                         // 开始时间
        EndTime       *time.Time     `json:"end_time,omitempty"`                                 // 结束时间
        CreatedAt     time.Time      `json:"created_at"`
        UpdatedAt     time.Time      `json:"updated_at"`
        DeletedAt     gorm.DeletedAt `gorm:"index" json:"-"`
}

// SagaStep Saga 步骤（对应文档中的 saga_steps 表）
type SagaStep struct {
        ID             uint           `gorm:"primarykey" json:"id"`
        StepID         string         `gorm:"uniqueIndex;size:64;not null" json:"step_id"`      // 步骤唯一标识
        TransactionID  string         `gorm:"index;size:64;not null" json:"transaction_id"`     // 关联的 Saga 事务ID
        StepName       string         `gorm:"size:255;not null" json:"step_name"`               // 步骤名称
        Status         StepStatus     `gorm:"size:20;not null;default:'pending'" json:"status"` // 步骤状态
        ActionData     string         `gorm:"type:json" json:"action_data"`                     // 操作数据（JSON格式）
        CompensateData string         `gorm:"type:json" json:"compensate_data"`                 // 补偿数据（JSON格式）
        ErrorMessage   string         `gorm:"type:text" json:"error_message"`                   // 错误信息
        RetryCount     int            `gorm:"default:0" json:"retry_count"`                     // 重试次数
        MaxRetries     int            `gorm:"default:3" json:"max_retries"`                     // 最大重试次数
        StartTime      time.Time      `json:"start_time"`                                       // 开始时间
        EndTime        *time.Time     `json:"end_time,omitempty"`                               // 结束时间
        CreatedAt      time.Time      `json:"created_at"`
        UpdatedAt      time.Time      `json:"updated_at"`
        DeletedAt      gorm.DeletedAt `gorm:"index" json:"-"`
}

// SagaEvent Saga 事件（对应文档中的 saga_events 表）
type SagaEvent struct {
        ID            uint           `gorm:"primarykey" json:"id"`
        TransactionID string         `gorm:"index;size:64;not null" json:"transaction_id"` // 关联的 Saga 事务ID
        StepID        string         `gorm:"size:64" json:"step_id"`                       // 关联的步骤ID（可选）
        EventType     EventType      `gorm:"size:50;not null" json:"event_type"`           // 事件类型
        EventData     string         `gorm:"type:json" json:"event_data"`                  // 事件数据（JSON格式）
        CreatedAt     time.Time      `json:"created_at"`
        DeletedAt     gorm.DeletedAt `gorm:"index" json:"-"`
}

// SagaStatus Saga 状态枚举
type SagaStatus string

const (
        SagaStatusPending      SagaStatus = "pending"      // 待执行
        SagaStatusInProgress   SagaStatus = "in_progress"  // 执行中
        SagaStatusCompleted    SagaStatus = "completed"    // 已完成
        SagaStatusFailed       SagaStatus = "failed"       // 执行失败
        SagaStatusCompensating SagaStatus = "compensating" // 补偿中
        SagaStatusCompensated  SagaStatus = "compensated"  // 已补偿
        SagaStatusCancelled    SagaStatus = "cancelled"    // 已取消
)

// StepStatus 步骤状态枚举
type StepStatus string

const (
        StepStatusPending      StepStatus = "pending"      // 待执行
        StepStatusInProgress   StepStatus = "in_progress"  // 执行中
        StepStatusCompleted    StepStatus = "completed"    // 已完成
        StepStatusFailed       StepStatus = "failed"       // 执行失败
        StepStatusCompensating StepStatus = "compensating" // 补偿中
        StepStatusCompensated  StepStatus = "compensated"  // 已补偿
        StepStatusSkipped      StepStatus = "skipped"      // 已跳过
)

// EventType 事件类型枚举
type EventType string

const (
        EventTypeSagaStarted           EventType = "saga_started"           // Saga 开始
        EventTypeStepStarted           EventType = "step_started"           // 步骤开始
        EventTypeStepCompleted         EventType = "step_completed"         // 步骤完成
        EventTypeStepFailed            EventType = "step_failed"            // 步骤失败
        EventTypeStepRetried           EventType = "step_retried"           // 步骤重试
        EventTypeStepSkipped           EventType = "step_skipped"           // 步骤跳过
        EventTypeCompensationStarted   EventType = "compensation_started"   // 补偿开始
        EventTypeCompensationCompleted EventType = "compensation_completed" // 补偿完成
        EventTypeSagaCompleted         EventType = "saga_completed"         // Saga 完成
        EventTypeSagaFailed            EventType = "saga_failed"            // Saga 失败
        EventTypeSagaCancelled         EventType = "saga_cancelled"         // Saga 取消
)

// TableName 指定表名
func (SagaTransaction) TableName() string <span class="cov0" title="0">{
        return "saga_transactions"
}</span>

func (SagaStep) TableName() string <span class="cov0" title="0">{
        return "saga_steps"
}</span>

func (SagaEvent) TableName() string <span class="cov0" title="0">{
        return "saga_events"
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package models

import "time"

const (
        TaskStatusPending    = "pending"
        TaskStatusInProgress = "in_progress"
        TaskStatusCompleted  = "completed"
        TaskStatusCancelled  = "cancelled"
)

type Task struct {
        ID            uint      `gorm:"primaryKey;autoIncrement;column:id;comment:任务ID"`
        Title         string    `gorm:"type:varchar(255);not null;column:title;comment:任务标题"`
        Description   string    `gorm:"type:text;column:description;comment:任务描述"`
        Status        string    `gorm:"type:varchar(20);not null;default:pending;column:status;comment:任务状态(pending/in_progress/completed/cancelled)"`
        CreatedAt     time.Time `gorm:"type:timestamp;not null;default:CURRENT_TIMESTAMP;column:created_at;comment:创建时间"`
        UpdatedAt     time.Time `gorm:"type:timestamp;not null;default:CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;column:updated_at;comment:更新时间"`
        DueDate       time.Time `gorm:"type:timestamp;column:due_date;comment:截止时间"`
        StartDate     time.Time `gorm:"type:timestamp;column:start_date;comment:开始时间"`
        CompletedAt   time.Time `gorm:"type:timestamp;column:completed_at;comment:完成时间"`
        CreatorID     uint      `gorm:"type:bigint;not null;column:creator_id;comment:创建人ID"`
        Progress      int8      `gorm:"type:tinyint;default:0;column:progress;comment:进度(0-100)"`
        EstimatedTime int       `gorm:"type:int;column:estimated_time;comment:预估耗时(分钟)"`
        ActualTime    int       `gorm:"type:int;column:actual_time;comment:实际耗时(分钟)"`
}

func (Task) TableName() string <span class="cov0" title="0">{
        return "task"
}</span>

func (Task) Indexes() []string <span class="cov0" title="0">{
        return []string{"idx_status"}
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package models

import (
        "time"
)

type TbLasUser struct {
        ID               uint      `gorm:"primaryKey;autoIncrement;column:id;type:int unsigned;comment:主键id"`
        TaskID           string    `gorm:"not null;column:task_id;type:varchar(20);comment:任务id"`
        ThirdCompanyID   string    `gorm:"not null;column:third_company_id;type:varchar(20);comment:租户id"`
        PlatformID       string    `gorm:"not null;column:platform_id;type:varchar(60);comment:平台id"`
        Uid              string    `gorm:"not null;column:uid;type:varchar(255);comment:用户id"`
        DefDid           string    `gorm:"column:def_did;type:varchar(255);comment:默认部门"`
        DefDidOrder      int       `gorm:"column:def_did_order;type:int;default:0;comment:排序"`
        Account          string    `gorm:"not null;column:account;type:varchar(255);comment:登录名"`
        NickName         string    `gorm:"not null;column:nick_name;type:varchar(255);comment:用户昵称"`
        Password         string    `gorm:"column:password;type:varchar(255);comment:密码"`
        Avatar           string    `gorm:"column:avatar;type:varchar(255);comment:头像"`
        Email            string    `gorm:"column:email;type:varchar(80);comment:邮箱"`
        Gender           string    `gorm:"column:gender;type:varchar(60);comment:性别"`
        Title            string    `gorm:"column:title;type:varchar(255);comment:职称"`
        WorkPlace        string    `gorm:"column:work_place;type:varchar(255);comment:办公地点"`
        Leader           string    `gorm:"column:leader;type:varchar(255);comment:上级主管ID"`
        Employer         string    `gorm:"column:employer;type:varchar(255);comment:员工工号"`
        EmploymentStatus string    `gorm:"column:employment_status;type:varchar(60);default:notactive;comment:就职状态"`
        EmploymentType   string    `gorm:"column:employment_type;type:varchar(60);comment:就职类型"`
        Phone            string    `gorm:"column:phone;type:varchar(200);comment:手机号"`
        Telephone        string    `gorm:"column:telephone;type:varchar(200);comment:座机号"`
        Source           string    `gorm:"column:source;type:varchar(20);default:sync;comment:来源"`
        CustomFields     string    `gorm:"column:custom_fields;type:varchar(5000);comment:自定义字段"`
        Ctime            time.Time `gorm:"column:ctime;type:timestamp;default:CURRENT_TIMESTAMP;comment:创建时间"`
        Mtime            time.Time `gorm:"not null;column:mtime;type:timestamp;comment:更新时间"`
        CheckType        int8      `gorm:"not null;column:check_type;type:tinyint;default:0;comment:勾选状态"`
}

func (TbLasUser) TableName() string <span class="cov0" title="0">{
        return "tb_las_user"
}</span>

type TbLasUserIncrement struct {
        ID               uint      `gorm:"primaryKey;autoIncrement;column:id;type:int unsigned;comment:主键id"`
        ThirdCompanyID   string    `gorm:"not null;column:third_company_id;type:varchar(20);comment:租户id"`
        PlatformID       string    `gorm:"not null;column:platform_id;type:varchar(60);comment:平台id"`
        Uid              string    `gorm:"not null;column:uid;type:varchar(255);comment:用户id"`
        DefDid           string    `gorm:"column:def_did;type:varchar(255);comment:默认部门"`
        DefDidOrder      int       `gorm:"column:def_did_order;type:int;default:0;comment:排序"`
        Account          string    `gorm:"not null;column:account;type:varchar(255);comment:登录名"`
        NickName         string    `gorm:"not null;column:nick_name;type:varchar(255);comment:用户昵称"`
        Password         string    `gorm:"column:password;type:varchar(255);comment:密码"`
        Avatar           string    `gorm:"column:avatar;type:varchar(255);comment:头像"`
        Email            string    `gorm:"column:email;type:varchar(80);comment:邮箱"`
        Gender           string    `gorm:"column:gender;type:varchar(60);comment:性别"`
        Title            string    `gorm:"column:title;type:varchar(255);comment:职称"`
        WorkPlace        string    `gorm:"column:work_place;type:varchar(255);comment:办公地点"`
        Leader           string    `gorm:"column:leader;type:varchar(255);comment:上级主管ID"`
        Employer         string    `gorm:"column:employer;type:varchar(255);comment:员工工号"`
        EmploymentStatus string    `gorm:"column:employment_status;type:varchar(60);comment:就职状态"`
        EmploymentType   string    `gorm:"column:employment_type;type:varchar(60);comment:就职类型"`
        Phone            string    `gorm:"column:phone;type:varchar(200);comment:手机号"`
        Telephone        string    `gorm:"column:telephone;type:varchar(200);comment:座机号"`
        Source           string    `gorm:"column:source;type:varchar(20);default:sync;comment:来源"`
        CustomFields     string    `gorm:"column:custom_fields;type:varchar(5000);comment:自定义字段"`
        SyncType         string    `gorm:"column:sync_type;type:varchar(20);default:auto;comment:同步方式"`
        UpdateType       string    `gorm:"not null;column:update_type;type:varchar(20);comment:修改类型"`
        Status           int       `gorm:"column:status;type:int;default:0;comment:状态"`
        Msg              string    `gorm:"column:msg;type:varchar(2000);comment:错误详情"`
        Operator         string    `gorm:"column:operator;type:varchar(100);default:系统;comment:operator"`
        SyncTime         time.Time `gorm:"column:sync_time;type:timestamp;default:CURRENT_TIMESTAMP;comment:增量数据变动时间"`
        Ctime            time.Time `gorm:"column:ctime;type:timestamp;default:CURRENT_TIMESTAMP;comment:创建时间"`
        Mtime            time.Time `gorm:"not null;column:mtime;type:timestamp;comment:更新时间"`
}

func (TbLasUserIncrement) TableName() string <span class="cov0" title="0">{
        return "tb_las_user_increment"
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package data

import (
        "context"
        "nancalacc/internal/conf"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/go-redis/redis/v8"
)

func NewRedisClient(c *conf.Data, logger log.Logger) (*redis.Client, error) <span class="cov0" title="0">{
        // 检查 Redis 是否启用
        if !c.Redis.Enable </span><span class="cov0" title="0">{
                logger.Log(log.LevelInfo, "msg", "redis is disabled, skipping initialization")
                return nil, nil
        }</span>

        // logger := integration.CreateLogger()
        <span class="cov0" title="0">rdb := redis.NewClient(&amp;redis.Options{
                Addr:         c.Redis.Addr,
                Password:     c.Redis.Password, // 添加密码字段
                ReadTimeout:  c.Redis.ReadTimeout.AsDuration(),
                WriteTimeout: c.Redis.WriteTimeout.AsDuration(),
        })
        timeout, cancelFunc := context.WithTimeout(context.Background(), time.Second*2)
        defer cancelFunc()
        err := rdb.Ping(timeout).Err()
        if err != nil </span><span class="cov0" title="0">{
                logger.Log(log.LevelError, "msg", "redis ping failed", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return rdb, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package data

import (
        "context"
        "encoding/json"
        "nancalacc/internal/biz"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/go-redis/redis/v8"
)

type redisCacheService struct {
        client *redis.Client
        log    *log.Helper
}

// NewAccounterRepo .
func NewRedisCacheService(client *redis.Client, logger log.Logger) biz.CacheService <span class="cov0" title="0">{
        return &amp;redisCacheService{
                client: client,
                log:    log.NewHelper(logger),
        }
}</span>

func (r *redisCacheService) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov0" title="0">{
        p, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">r.log.Infof("Set key: %s, value: %s", key, string(p))
        return r.client.Set(ctx, key, p, expiration).Err()</span>
}

func (r *redisCacheService) Get(ctx context.Context, key string) (interface{}, bool, error) <span class="cov0" title="0">{
        p, err := r.client.Get(ctx, key).Bytes()
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        return nil, false, nil
                }</span>
                <span class="cov0" title="0">return nil, false, err</span>
        }
        <span class="cov0" title="0">var v interface{}
        err = json.Unmarshal(p, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>
        <span class="cov0" title="0">return v, true, nil</span>
}

func (r *redisCacheService) Del(ctx context.Context, key string) error <span class="cov0" title="0">{
        r.client.Del(ctx, key)
        return nil
}</span>

// func (r *redisRepo) GetWithCachePenetrationProtection(
//         ctx context.Context,
//         key string,
//         dest interface{},
//         fallback func() (interface{}, error),
//         ttl time.Duration,
// ) error {
//         // 1. 先查缓存
//         err := r.Get(ctx, key, dest)
//         if err == nil {
//                 return nil
//         }

//         // 2. 获取分布式锁（防击穿）
//         lockKey := "lock:" + key
//         if !r.Lock(ctx, lockKey, 10*time.Second) {
//                 return errors.New("操作过于频繁")
//         }
//         defer r.Unlock(ctx, lockKey)

//         // 3. 回源查询
//         data, err := fallback()
//         if err != nil {
//                 return err
//         }

//         // 4. 写入缓存
//         return r.Set(ctx, key, data, ttl)
// }

// func (r *redisRepo) Lock(ctx context.Context, key string, expiration time.Duration) bool {
//         return r.data.redis.SetNX(ctx, key, 1, expiration).Val()
// }

// func (r *redisRepo) Unlock(ctx context.Context, key string) {
//         r.data.redis.Del(ctx, key)
// }

// other method：HSet/HGet、LPush/LRange、Incr 等...
</pre>
		
		<pre class="file" id="file40" style="display: none">package data

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "nancalacc/internal/data/models"

        "gorm.io/gorm"
)

// SagaRepository Saga 数据访问层
type SagaRepository struct {
        db *gorm.DB
}

// NewSagaRepository 创建 Saga 仓库实例
func NewSagaRepository(db *gorm.DB) *SagaRepository <span class="cov0" title="0">{
        return &amp;SagaRepository{db: db}
}</span>

// ==================== Saga 事务相关方法 ====================

// CreateTransaction 创建 Saga 事务
func (r *SagaRepository) CreateTransaction(ctx context.Context, transaction *models.SagaTransaction) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(transaction).Error
}</span>

// GetTransaction 根据事务ID获取 Saga 事务
func (r *SagaRepository) GetTransaction(ctx context.Context, transactionID string) (*models.SagaTransaction, error) <span class="cov0" title="0">{
        var transaction models.SagaTransaction
        err := r.db.WithContext(ctx).Where("transaction_id = ?", transactionID).First(&amp;transaction).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;transaction, nil</span>
}

// UpdateTransactionStatus 更新 Saga 事务状态
func (r *SagaRepository) UpdateTransactionStatus(ctx context.Context, transactionID string, status models.SagaStatus) error <span class="cov0" title="0">{
        updates := map[string]interface{}{
                "status":     status,
                "updated_at": time.Now(),
        }

        if status == models.SagaStatusCompleted || status == models.SagaStatusFailed || status == models.SagaStatusCompensated </span><span class="cov0" title="0">{
                now := time.Now()
                updates["end_time"] = &amp;now
        }</span>

        <span class="cov0" title="0">return r.db.WithContext(ctx).Model(&amp;models.SagaTransaction{}).
                Where("transaction_id = ?", transactionID).
                Updates(updates).Error</span>
}

// UpdateTransaction 更新 Saga 事务
func (r *SagaRepository) UpdateTransaction(ctx context.Context, transaction *models.SagaTransaction) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(transaction).Error
}</span>

// ListTransactionsByStatus 根据状态查询 Saga 事务列表
func (r *SagaRepository) ListTransactionsByStatus(ctx context.Context, status models.SagaStatus, limit, offset int) ([]*models.SagaTransaction, error) <span class="cov0" title="0">{
        var transactions []*models.SagaTransaction
        err := r.db.WithContext(ctx).
                Where("status = ?", status).
                Order("created_at DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;transactions).Error
        return transactions, err
}</span>

// ==================== Saga 步骤相关方法 ====================

// CreateStep 创建 Saga 步骤
func (r *SagaRepository) CreateStep(ctx context.Context, step *models.SagaStep) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(step).Error
}</span>

// GetStep 根据步骤ID获取 Saga 步骤
func (r *SagaRepository) GetStep(ctx context.Context, stepID string) (*models.SagaStep, error) <span class="cov0" title="0">{
        var step models.SagaStep
        err := r.db.WithContext(ctx).Where("step_id = ?", stepID).First(&amp;step).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;step, nil</span>
}

// UpdateStep 更新 Saga 步骤
func (r *SagaRepository) UpdateStep(ctx context.Context, step *models.SagaStep) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(step).Error
}</span>

// UpdateStepStatus 更新 Saga 步骤状态
func (r *SagaRepository) UpdateStepStatus(ctx context.Context, stepID string, status models.StepStatus) error <span class="cov0" title="0">{
        updates := map[string]interface{}{
                "status":     status,
                "updated_at": time.Now(),
        }

        if status == models.StepStatusCompleted || status == models.StepStatusFailed || status == models.StepStatusCompensated </span><span class="cov0" title="0">{
                now := time.Now()
                updates["end_time"] = &amp;now
        }</span>

        <span class="cov0" title="0">return r.db.WithContext(ctx).Model(&amp;models.SagaStep{}).
                Where("step_id = ?", stepID).
                Updates(updates).Error</span>
}

// ListStepsByTransaction 根据事务ID查询步骤列表
func (r *SagaRepository) ListStepsByTransaction(ctx context.Context, transactionID string) ([]*models.SagaStep, error) <span class="cov0" title="0">{
        var steps []*models.SagaStep
        err := r.db.WithContext(ctx).
                Where("transaction_id = ?", transactionID).
                Order("start_time ASC").
                Find(&amp;steps).Error
        return steps, err
}</span>

// GetPendingSteps 获取待执行的步骤
func (r *SagaRepository) GetPendingSteps(ctx context.Context, transactionID string) ([]*models.SagaStep, error) <span class="cov0" title="0">{
        var steps []*models.SagaStep
        err := r.db.WithContext(ctx).
                Where("transaction_id = ? AND status = ?", transactionID, models.StepStatusPending).
                Order("start_time ASC").
                Find(&amp;steps).Error
        return steps, err
}</span>

// GetFailedSteps 获取失败的步骤
func (r *SagaRepository) GetFailedSteps(ctx context.Context, transactionID string) ([]*models.SagaStep, error) <span class="cov0" title="0">{
        var steps []*models.SagaStep
        err := r.db.WithContext(ctx).
                Where("transaction_id = ? AND status = ?", transactionID, models.StepStatusFailed).
                Order("start_time ASC").
                Find(&amp;steps).Error
        return steps, err
}</span>

// IncrementRetryCount 增加重试次数
func (r *SagaRepository) IncrementRetryCount(ctx context.Context, stepID string) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Model(&amp;models.SagaStep{}).
                Where("step_id = ?", stepID).
                UpdateColumn("retry_count", gorm.Expr("retry_count + 1")).Error
}</span>

// UpdateStepError 更新步骤错误信息
func (r *SagaRepository) UpdateStepError(ctx context.Context, stepID string, errorMsg string) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Model(&amp;models.SagaStep{}).
                Where("step_id = ?", stepID).
                Update("error_message", errorMsg).Error
}</span>

// ==================== Saga 事件相关方法 ====================

// CreateEvent 创建 Saga 事件
func (r *SagaRepository) CreateEvent(ctx context.Context, event *models.SagaEvent) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(event).Error
}</span>

// LogEvent 记录事件（便捷方法）
func (r *SagaRepository) LogEvent(ctx context.Context, transactionID, stepID string, eventType models.EventType, eventData map[string]interface{}) error <span class="cov0" title="0">{
        dataJSON, _ := json.Marshal(eventData)

        event := &amp;models.SagaEvent{
                TransactionID: transactionID,
                StepID:        stepID,
                EventType:     eventType,
                EventData:     string(dataJSON),
                CreatedAt:     time.Now(),
        }

        return r.CreateEvent(ctx, event)
}</span>

// ListEventsByTransaction 根据事务ID查询事件列表
func (r *SagaRepository) ListEventsByTransaction(ctx context.Context, transactionID string, limit, offset int) ([]*models.SagaEvent, error) <span class="cov0" title="0">{
        var events []*models.SagaEvent
        err := r.db.WithContext(ctx).
                Where("transaction_id = ?", transactionID).
                Order("created_at ASC").
                Limit(limit).
                Offset(offset).
                Find(&amp;events).Error
        return events, err
}</span>

// ListEventsByType 根据事件类型查询事件列表
func (r *SagaRepository) ListEventsByType(ctx context.Context, eventType models.EventType, limit, offset int) ([]*models.SagaEvent, error) <span class="cov0" title="0">{
        var events []*models.SagaEvent
        err := r.db.WithContext(ctx).
                Where("event_type = ?", eventType).
                Order("created_at DESC").
                Limit(limit).
                Offset(offset).
                Find(&amp;events).Error
        return events, err
}</span>

// ==================== 高级查询方法 ====================

// GetTransactionWithSteps 获取 Saga 事务及其所有步骤
func (r *SagaRepository) GetTransactionWithSteps(ctx context.Context, transactionID string) (*models.SagaTransaction, []*models.SagaStep, error) <span class="cov0" title="0">{
        // 获取事务
        transaction, err := r.GetTransaction(ctx, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // 获取步骤
        <span class="cov0" title="0">steps, err := r.ListStepsByTransaction(ctx, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return transaction, steps, nil</span>
}

// GetTransactionWithStepsAndEvents 获取 Saga 事务及其所有步骤和事件
func (r *SagaRepository) GetTransactionWithStepsAndEvents(ctx context.Context, transactionID string) (*models.SagaTransaction, []*models.SagaStep, []*models.SagaEvent, error) <span class="cov0" title="0">{
        // 获取事务和步骤
        transaction, steps, err := r.GetTransactionWithSteps(ctx, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        // 获取事件
        <span class="cov0" title="0">events, err := r.ListEventsByTransaction(ctx, transactionID, 1000, 0) // 获取所有事件
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">return transaction, steps, events, nil</span>
}

// ==================== 清理和维护方法 ====================

// CleanupExpiredTransactions 清理过期的 Saga 事务（保留7天）
func (r *SagaRepository) CleanupExpiredTransactions(ctx context.Context) error <span class="cov0" title="0">{
        expiredTime := time.Now().AddDate(0, 0, -7)
        return r.db.WithContext(ctx).
                Where("status IN (?, ?, ?) AND updated_at &lt; ?",
                        models.SagaStatusCompleted, models.SagaStatusCompensated, models.SagaStatusFailed, expiredTime).
                Delete(&amp;models.SagaTransaction{}).Error
}</span>

// CleanupExpiredEvents 清理过期的事件（保留30天）
func (r *SagaRepository) CleanupExpiredEvents(ctx context.Context) error <span class="cov0" title="0">{
        expiredTime := time.Now().AddDate(0, 0, -30)
        return r.db.WithContext(ctx).
                Where("created_at &lt; ?", expiredTime).
                Delete(&amp;models.SagaEvent{}).Error
}</span>

// ==================== 统计和监控方法 ====================

// GetSagaStatistics 获取 Saga 统计信息
func (r *SagaRepository) GetSagaStatistics(ctx context.Context) (map[string]int64, error) <span class="cov0" title="0">{
        stats := make(map[string]int64)

        // 统计各状态的事务数量
        statuses := []models.SagaStatus{
                models.SagaStatusPending,
                models.SagaStatusInProgress,
                models.SagaStatusCompleted,
                models.SagaStatusFailed,
                models.SagaStatusCompensating,
                models.SagaStatusCompensated,
        }

        for _, status := range statuses </span><span class="cov0" title="0">{
                var count int64
                err := r.db.WithContext(ctx).Model(&amp;models.SagaTransaction{}).
                        Where("status = ?", status).
                        Count(&amp;count).Error
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to count status %s: %w", status, err)
                }</span>
                <span class="cov0" title="0">stats[string(status)] = count</span>
        }

        // 统计事件数量
        <span class="cov0" title="0">var eventCount int64
        err := r.db.WithContext(ctx).Model(&amp;models.SagaEvent{}).Count(&amp;eventCount).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count events: %w", err)
        }</span>
        <span class="cov0" title="0">stats["total_events"] = eventCount

        return stats, nil</span>
}

// GetEventStatistics 获取事件统计信息
func (r *SagaRepository) GetEventStatistics(ctx context.Context) (map[string]int64, error) <span class="cov0" title="0">{
        stats := make(map[string]int64)

        // 统计各类型事件数量
        eventTypes := []models.EventType{
                models.EventTypeSagaStarted,
                models.EventTypeStepStarted,
                models.EventTypeStepCompleted,
                models.EventTypeStepFailed,
                models.EventTypeCompensationStarted,
                models.EventTypeCompensationCompleted,
                models.EventTypeSagaCompleted,
                models.EventTypeSagaFailed,
        }

        for _, eventType := range eventTypes </span><span class="cov0" title="0">{
                var count int64
                err := r.db.WithContext(ctx).Model(&amp;models.SagaEvent{}).
                        Where("event_type = ?", eventType).
                        Count(&amp;count).Error
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to count event type %s: %w", eventType, err)
                }</span>
                <span class="cov0" title="0">stats[string(eventType)] = count</span>
        }

        <span class="cov0" title="0">return stats, nil</span>
}

// // ==================== 向后兼容方法 ====================

// // 为了向后兼容，保留原有的方法名

// // CreateInstance 向后兼容方法
// func (r *SagaRepository) CreateInstance(ctx context.Context, instance *models.SagaInstance) error {
//         // 将 SagaInstance 转换为 SagaTransaction
//         transaction := &amp;models.SagaTransaction{
//                 TransactionID: instance.InstanceID,
//                 Name:          instance.ServiceName,
//                 Status:        instance.Status,
//                 Data:          instance.Data,
//                 CreatedAt:     instance.CreatedAt,
//                 UpdatedAt:     instance.UpdatedAt,
//         }
//         return r.CreateTransaction(ctx, transaction)
// }

// // GetInstance 向后兼容方法
// func (r *SagaRepository) GetInstance(ctx context.Context, instanceID string) (*models.SagaInstance, error) {
//         transaction, err := r.GetTransaction(ctx, instanceID)
//         if err != nil {
//                 return nil, err
//         }

//         // 转换为 SagaInstance
//         instance := &amp;models.SagaInstance{
//                 ID:          transaction.ID,
//                 InstanceID:  transaction.TransactionID,
//                 ServiceName: transaction.Name,
//                 Status:      transaction.Status,
//                 Data:        transaction.Data,
//                 CreatedAt:   transaction.CreatedAt,
//                 UpdatedAt:   transaction.UpdatedAt,
//         }
//         return instance, nil
// }

// // UpdateInstanceStatus 向后兼容方法
// func (r *SagaRepository) UpdateInstanceStatus(ctx context.Context, instanceID string, status models.SagaStatus) error {
//         return r.UpdateTransactionStatus(ctx, instanceID, status)
// }

// // UpdateInstance 向后兼容方法
// func (r *SagaRepository) UpdateInstance(ctx context.Context, instance *models.SagaInstance) error {
//         transaction := &amp;models.SagaTransaction{
//                 ID:            instance.ID,
//                 TransactionID: instance.InstanceID,
//                 Name:          instance.ServiceName,
//                 Status:        instance.Status,
//                 Data:          instance.Data,
//                 CreatedAt:     instance.CreatedAt,
//                 UpdatedAt:     instance.UpdatedAt,
//         }
//         return r.UpdateTransaction(ctx, transaction)
// }

// // ListInstancesByStatus 向后兼容方法
// func (r *SagaRepository) ListInstancesByStatus(ctx context.Context, status models.SagaStatus, limit, offset int) ([]*models.SagaInstance, error) {
//         transactions, err := r.ListTransactionsByStatus(ctx, status, limit, offset)
//         if err != nil {
//                 return nil, err
//         }

//         var instances []*models.SagaInstance
//         for _, transaction := range transactions {
//                 instance := &amp;models.SagaInstance{
//                         ID:          transaction.ID,
//                         InstanceID:  transaction.TransactionID,
//                         ServiceName: transaction.Name,
//                         Status:      transaction.Status,
//                         Data:        transaction.Data,
//                         CreatedAt:   transaction.CreatedAt,
//                         UpdatedAt:   transaction.UpdatedAt,
//                 }
//                 instances = append(instances, instance)
//         }
//         return instances, err
// }
</pre>
		
		<pre class="file" id="file41" style="display: none">package dingtalk

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "nancalacc/internal/auth"
        "nancalacc/internal/conf"
        "nancalacc/internal/pkg/utils"
        "nancalacc/pkg/httputil"
        "sync"
        "time"

        openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
        dingtalkcontact_1_0 "github.com/alibabacloud-go/dingtalk/contact_1_0"
        dingtalkoauth2_1_0 "github.com/alibabacloud-go/dingtalk/oauth2_1_0"
        util "github.com/alibabacloud-go/tea-utils/v2/service"
        "github.com/alibabacloud-go/tea/tea"
        "github.com/go-kratos/kratos/v2/log"
)

type dingTalkRepo struct {
        data      *conf.Auth_Dingtalk
        log       log.Logger
        tokenAuth auth.Authenticator
        // unifiedAuthService auth.UnifiedAuthService
        dingtalkCli *dingtalkoauth2_1_0.Client

        dingtalkCliContact *dingtalkcontact_1_0.Client
}

func NewDingTalkRepo(logger log.Logger) Dingtalk <span class="cov0" title="0">{

        config := &amp;openapi.Config{
                Protocol: tea.String("https"),
                RegionId: tea.String("central"),
        }
        client, err := dingtalkoauth2_1_0.NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log(log.LevelError, "NewClientErr", err)
        }</span>

        <span class="cov0" title="0">clientContact, err := dingtalkcontact_1_0.NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log(log.LevelError, "NewClientErr", err)
        }</span>
        <span class="cov0" title="0">tokenAuth := auth.NewDingTalkAuthenticator()

        return &amp;dingTalkRepo{
                dingtalkCli:        client,
                tokenAuth:          tokenAuth,
                dingtalkCliContact: clientContact,
                data:               conf.Get().GetAuth().GetDingtalk(),
                log:                logger,
        }</span>
}

func (r *dingTalkRepo) GetAccessToken(ctx context.Context) (*auth.AccessTokenResp, error) <span class="cov0" title="0">{

        return r.tokenAuth.GetAccessToken(ctx)
}</span>
func (r *dingTalkRepo) FetchDepartments(ctx context.Context, token string) ([]*DingtalkDept, error) <span class="cov0" title="0">{

        r.log.Log(log.LevelInfo, "msg", "FetchDepartments", "input", token)

        var deptList []*DingtalkDept

        var deptIdlist []int64
        var baseDeptId int64 = 1
        // 1. 获取子部门ID列表（所有）
        deptIdsLevelOne, err := r.getDeptIds(ctx, token, baseDeptId)
        r.log.Log(log.LevelInfo, "msg", "FetchDepartments", "deptIdsLevelOne", deptIdsLevelOne, "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">deptIdlist = append(deptIdlist, baseDeptId)

        r.log.Log(log.LevelInfo, "msg", "FetchDepartments", "deptIdlist", deptIdlist)
        if len(deptIdsLevelOne) &gt; 0 </span><span class="cov0" title="0">{
                r.log.Log(log.LevelInfo, "msg", "FetchDepartments", "len(deptIdsLevelOne) &gt; 0")
                deptIdlist = append(deptIdlist, deptIdsLevelOne...)
                deptIdsLeveltwo, err := r.getDeptIdsConcurrent(ctx, token, deptIdsLevelOne)

                r.log.Log(log.LevelInfo, "msg", "FetchDepartments", "deptIdsLeveltwo", deptIdsLeveltwo, "err", err)

                if err != nil </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelError, "msg", "FetchDepartments", "getDeptIdsConcurrent failed", "err", err)
                }</span>
                <span class="cov0" title="0">if len(deptIdsLeveltwo) &gt; 0 </span><span class="cov0" title="0">{
                        deptIdlist = append(deptIdlist, deptIdsLeveltwo...)
                }</span>
        }

        <span class="cov0" title="0">r.log.Log(log.LevelInfo, "msg", "FetchDepartments", "deptIdlist", deptIdlist)
        // 2. 获取子部门详情
        deptList, err = r.FetchDeptDetails(ctx, token, deptIdlist)
        r.log.Log(log.LevelInfo, "msg", "FetchDepartments", "deptList", deptList, "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return deptList, nil</span>
}
func (r *dingTalkRepo) getDeptIds(ctx context.Context, token string, deptId int64) ([]int64, error) <span class="cov0" title="0">{

        r.log.Log(log.LevelInfo, "msg", "getDeptIds", "token", token, "deptId", deptId)

        uri := fmt.Sprintf("%s/topapi/v2/department/listsubid?access_token=%s", r.data.Endpoint, token)
        input := &amp;ListDeptIDRequest{
                DeptID: deptId,
        }
        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">bs, err := httputil.PostJSON(uri, jsonData, time.Second*10)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        //r.log.Info("FetchAccounts.deptList: %v, err: %v", string(bs), err)

        <span class="cov0" title="0">var deptIDResponse *ListDeptIDResponse
        if err = json.Unmarshal(bs, &amp;deptIDResponse); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if deptIDResponse.Errcode != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("钉钉API返回错误: %s, errcode: %d", deptIDResponse.Errmsg, deptIDResponse.Errcode)
        }</span>
        <span class="cov0" title="0">if deptIDResponse.Result.DeptIDList == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("钉钉API返回错误: %s, errcode: %d", deptIDResponse.Errmsg, deptIDResponse.Errcode)
        }</span>
        <span class="cov0" title="0">deptIdlist := deptIDResponse.Result.DeptIDList
        return deptIdlist, nil</span>
}
func (r *dingTalkRepo) getDeptIdsConcurrent(ctx context.Context, token string, deptIds []int64) ([]int64, error) <span class="cov0" title="0">{

        uri := fmt.Sprintf("%s/topapi/v2/department/listsubid?access_token=%s", r.data.Endpoint, token)

        r.log.Log(log.LevelInfo, "msg", "getDeptIdsConcurrent", "deptIds", deptIds, "uri", uri)
        sem := make(chan struct{}, r.data.MaxConcurrent)
        deptList := make([]int64, 0)
        var mu sync.Mutex

        var wg sync.WaitGroup

        for _, deptId := range deptIds </span><span class="cov0" title="0">{
                wg.Add(1)

                select </span>{
                case sem &lt;- struct{}{}:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        wg.Done()
                        continue</span>
                }

                // 启动goroutine处理任务
                <span class="cov0" title="0">go func(id int64) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                &lt;-sem     // 释放信号量
                                wg.Done() // 通知任务完成
                        }</span>()

                        <span class="cov0" title="0">input := &amp;ListDeptIDRequest{
                                DeptID: id,
                        }
                        jsonData, err := json.Marshal(input)
                        if err != nil </span><span class="cov0" title="0">{
                                r.log.Log(log.LevelError, "msg", "getDeptIdsConcurrent", "jsonData", string(jsonData), "err", err)
                                return
                        }</span>

                        <span class="cov0" title="0">bs, err := httputil.PostJSON(uri, jsonData, time.Second*10)
                        if err != nil </span><span class="cov0" title="0">{
                                r.log.Log(log.LevelError, "msg", "getDeptIdsConcurrent", "PostJSON", string(jsonData), "err", err)
                                return
                        }</span>
                        <span class="cov0" title="0">var deptIDResponse *ListDeptIDResponse
                        if err = json.Unmarshal(bs, &amp;deptIDResponse); err != nil </span><span class="cov0" title="0">{
                                r.log.Log(log.LevelError, "msg", "getDeptIdsConcurrent", "Unmarshal", string(bs), "err", err)
                                return
                        }</span>
                        <span class="cov0" title="0">if deptIDResponse.Errcode != 0 </span><span class="cov0" title="0">{
                                r.log.Log(log.LevelError, "msg", "getDeptIdsConcurrent", "钉钉API返回错误", "Errmsg", deptIDResponse.Errmsg, "Errcode", deptIDResponse.Errcode)
                                return
                        }</span>
                        <span class="cov0" title="0">if deptIDResponse.Result.DeptIDList == nil </span><span class="cov0" title="0">{
                                r.log.Log(log.LevelError, "msg", "getDeptIdsConcurrent", "钉钉API返回错误", "Errmsg", deptIDResponse.Errmsg, "Errcode", deptIDResponse.Errcode)
                                return
                        }</span>
                        <span class="cov0" title="0">deptIdlist := deptIDResponse.Result.DeptIDList

                        mu.Lock()
                        deptList = append(deptList, deptIdlist...)
                        mu.Unlock()</span>
                }(deptId) // 传递当前deptId值
        }
        <span class="cov0" title="0">wg.Wait()

        return deptList, nil</span>
}

func (r *dingTalkRepo) FetchDeptDetails(ctx context.Context, token string, deptIds []int64) ([]*DingtalkDept, error) <span class="cov0" title="0">{
        r.log.Log(log.LevelInfo, "msg", "FetchDeptDetails", "token", token, "depIds", deptIds)

        uriDetail := fmt.Sprintf("%s/topapi/v2/department/get?access_token=%s", r.data.Endpoint, token)

        sem := make(chan struct{}, r.data.MaxConcurrent)
        results := make(chan *DingtalkDept, len(deptIds))
        //errChan := make(chan error, 1)

        var wg sync.WaitGroup

        for _, deptId := range deptIds </span><span class="cov0" title="0">{
                wg.Add(1)

                select </span>{
                case sem &lt;- struct{}{}:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        wg.Done()
                        continue</span>
                }

                // 启动goroutine处理任务
                <span class="cov0" title="0">go func(id int64) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                &lt;-sem     // 释放信号量
                                wg.Done() // 通知任务完成
                        }</span>()

                        <span class="cov0" title="0">input := &amp;DingtalkDeptRequest{
                                DeptID: id,
                        }
                        jsonData, err := json.Marshal(input)
                        if err != nil </span><span class="cov0" title="0">{
                                r.log.Log(log.LevelError, "msg", "FetchDeptDetails", "jsonData", string(jsonData), "err", err)
                                //errChan &lt;- err
                                return
                        }</span>

                        <span class="cov0" title="0">bs, err := httputil.PostJSON(uriDetail, jsonData, time.Second*10)
                        //r.log.Infof("&gt;&gt;&gt;&gt;FetchDeptDetails.bs: %s, err: %v\n", string(bs), err)
                        if err != nil </span><span class="cov0" title="0">{
                                r.log.Log(log.LevelError, "msg", "FetchDeptDetails", "PostJSON", string(jsonData), "err", err)
                                //errChan &lt;- err
                                return
                        }</span>
                        <span class="cov0" title="0">var deptResponse *DingtalkDeptResponse
                        if err = json.Unmarshal(bs, &amp;deptResponse); err != nil </span><span class="cov0" title="0">{
                                r.log.Log(log.LevelError, "msg", "FetchDeptDetails", "Unmarshal", string(bs), "err", err)
                                //errChan &lt;- err
                                return
                        }</span>
                        <span class="cov0" title="0">if deptResponse.Errcode != 0 </span><span class="cov0" title="0">{
                                r.log.Log(log.LevelError, "msg", "FetchDeptDetails", "Errcode", deptResponse.Errcode, "Errmsg", deptResponse.Errmsg)
                                //errChan &lt;- err
                                return
                        }</span>
                        <span class="cov0" title="0">results &lt;- &amp;deptResponse.Result</span>
                }(deptId) // 传递当前deptId值
        }
        <span class="cov0" title="0">wg.Wait()

        close(results)
        //close(errChan)
        var deptList []*DingtalkDept
        for dept := range results </span><span class="cov0" title="0">{
                deptList = append(deptList, dept)
        }</span>

        <span class="cov0" title="0">return deptList, nil</span>

}
func (r *dingTalkRepo) FetchDepartmentUsers(ctx context.Context, token string, deptIds []int64) ([]*DingtalkDeptUser, error) <span class="cov0" title="0">{
        r.log.Log(log.LevelInfo, "msg", "FetchDepartmentUsers", "input", "token", token, "deptIds", deptIds)

        // 服务端API.通讯录管理.用户管理.获取部门用户详情
        //maxConcurrent := 10
        sem := make(chan struct{}, r.data.MaxConcurrent)
        results := make(chan *DingtalkDeptUser, len(deptIds))
        // := make(chan error, 1)

        var wg sync.WaitGroup

        for _, deptId := range deptIds </span><span class="cov0" title="0">{
                wg.Add(1)

                select </span>{
                case sem &lt;- struct{}{}:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        wg.Done()
                        continue</span>
                }

                // 启动goroutine处理任务
                <span class="cov0" title="0">go func(id int64) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                &lt;-sem     // 释放信号量
                                wg.Done() // 通知任务完成
                        }</span>()

                        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                                userList, cursor, err := r.getUserListByDepId(ctx, token, id)
                                if err != nil </span><span class="cov0" title="0">{
                                        r.log.Log(log.LevelError, "msg", "FetchDepartmentUsers", "getUserListByDepId", id, "err", err)
                                        //errChan &lt;- err
                                        return
                                }</span>
                                <span class="cov0" title="0">for _, user := range userList </span><span class="cov0" title="0">{
                                        results &lt;- user
                                }</span>
                                <span class="cov0" title="0">if cursor == 0 </span><span class="cov0" title="0">{
                                        break</span>
                                }

                        }
                }(deptId)
        }
        <span class="cov0" title="0">wg.Wait()

        close(results)
        //close(errChan)
        var userList []*DingtalkDeptUser
        usersMap := make(map[string]*DingtalkDeptUser)
        for user := range results </span><span class="cov0" title="0">{
                // log.Infof("FetchDepartmentUsers results user: %+v", user)
                if _, ok := usersMap[user.Userid]; ok </span><span class="cov0" title="0">{
                        usersMap[user.Userid].DeptIDList = append(usersMap[user.Userid].DeptIDList, user.DeptIDList...)
                        usersMap[user.Userid].DeptIDList = utils.RemoveDuplicates(usersMap[user.Userid].DeptIDList)

                }</span>
                <span class="cov0" title="0">usersMap[user.Userid] = user</span>

        }
        <span class="cov0" title="0">for _, u := range usersMap </span><span class="cov0" title="0">{
                // log.Infof("FetchDepartmentUsers usersMap user: %+v", u)
                userList = append(userList, u)
        }</span>
        <span class="cov0" title="0">return userList, nil</span>
}
func (r *dingTalkRepo) getUserListByDepId(ctx context.Context, token string, deptId int64) ([]*DingtalkDeptUser, int64, error) <span class="cov0" title="0">{
        r.log.Log(log.LevelInfo, "msg", "getUserListByDepId", "token", token, "deptId", deptId)
        // 发送post请求
        var cursor int64 = 0
        uri := fmt.Sprintf("%s/topapi/v2/user/list?access_token=%s", r.data.Endpoint, token)
        input := &amp;ListDeptUserRequest{
                DeptID: deptId,
                Cursor: cursor,
                Size:   100,
        }
        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">bs, err := httputil.PostJSON(uri, jsonData, time.Second*10)
        r.log.Log(log.LevelInfo, "msg", "getUserListByDepId", "body", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">var userResponse ListDeptUserResponse
        if err = json.Unmarshal(bs, &amp;userResponse); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">if userResponse.Errcode != 0 </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("钉钉API返回错误: %s, errcode: %v", userResponse.Errmsg, userResponse.Errcode)
        }</span>

        <span class="cov0" title="0">var userList []*DingtalkDeptUser
        if userResponse.Result.List != nil </span><span class="cov0" title="0">{
                userList = make([]*DingtalkDeptUser, 0, len(userResponse.Result.List))
                for _, user := range userResponse.Result.List </span><span class="cov0" title="0">{
                        userList = append(userList, &amp;user)
                }</span>
        }
        <span class="cov0" title="0">if userResponse.Result.HasMore </span><span class="cov0" title="0">{
                return userList, userResponse.Result.NextCursor, nil
        }</span>
        <span class="cov0" title="0">return userList, 0, nil</span>
}
func (r *dingTalkRepo) GetUserAccessToken(ctx context.Context, code string) (*AuthResponse, error) <span class="cov0" title="0">{

        r.log.Log(log.LevelInfo, "msg", "GetUserAccessToken", "code", code)

        getUserTokenRequest := &amp;dingtalkoauth2_1_0.GetUserTokenRequest{

                ClientId:     tea.String(r.data.AppKey),
                ClientSecret: tea.String(r.data.AppSecret),
                Code:         tea.String(code),
                //RefreshToken: tea.String("abcd"),
                GrantType: tea.String("authorization_code"),
        }

        // var accessToken string
        var response *dingtalkoauth2_1_0.GetUserTokenResponse
        var err error
        tryErr := func() (_e error) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if er := tea.Recover(recover()); er != nil </span><span class="cov0" title="0">{
                                _e = er
                        }</span>
                }()
                <span class="cov0" title="0">response, err = r.dingtalkCli.GetUserToken(getUserTokenRequest)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        }()

        <span class="cov0" title="0">if tryErr != nil </span><span class="cov0" title="0">{
                var err = &amp;tea.SDKError{}
                if _t, ok := tryErr.(*tea.SDKError); ok </span><span class="cov0" title="0">{
                        err = _t
                }</span> else<span class="cov0" title="0"> {
                        err.Message = tea.String(tryErr.Error())
                }</span>
                <span class="cov0" title="0">if !tea.BoolValue(util.Empty(err.Code)) &amp;&amp; !tea.BoolValue(util.Empty(err.Message)) </span>{<span class="cov0" title="0">
                        // err 中含有 code 和 message 属性，可帮助开发定位问题
                }</span>

        }
        <span class="cov0" title="0">if response.StatusCode != nil &amp;&amp; *response.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if response.Body == nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tokenAuthResp := &amp;AuthResponse{}
        if response.Body.AccessToken == nil </span><span class="cov0" title="0">{
                return nil, errors.New("response.Body.AccessToken is nil")
        }</span>
        <span class="cov0" title="0">tokenAuthResp.AccessToken = *response.Body.AccessToken
        tokenAuthResp.RefreshToken = *response.Body.RefreshToken
        tokenAuthResp.ExpireIn = int(*response.Body.ExpireIn)

        return tokenAuthResp, nil</span>
}
func (r *dingTalkRepo) GetUserInfo(ctx context.Context, token, unionId string) (*DingTalkUserInfo, error) <span class="cov0" title="0">{

        r.log.Log(log.LevelInfo, "msg", "GetUserInfo", "token", token, "unionId", unionId)

        getUserHeaders := &amp;dingtalkcontact_1_0.GetUserHeaders{}
        getUserHeaders.XAcsDingtalkAccessToken = tea.String(token)
        var response *dingtalkcontact_1_0.GetUserResponse
        var err error
        tryErr := func() (_e error) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := tea.Recover(recover()); r != nil </span><span class="cov0" title="0">{
                                _e = r
                        }</span>
                }()
                <span class="cov0" title="0">response, err = r.dingtalkCliContact.GetUserWithOptions(tea.String(unionId), getUserHeaders, &amp;util.RuntimeOptions{})

                r.log.Log(log.LevelInfo, "msg", "GetUserInfo", "response", response, "err", err)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if response.Body == nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        }()

        <span class="cov0" title="0">if tryErr != nil </span><span class="cov0" title="0">{
                var err = &amp;tea.SDKError{}
                if _t, ok := tryErr.(*tea.SDKError); ok </span><span class="cov0" title="0">{
                        err = _t
                }</span> else<span class="cov0" title="0"> {
                        err.Message = tea.String(tryErr.Error())
                }</span>
                <span class="cov0" title="0">if !tea.BoolValue(util.Empty(err.Code)) &amp;&amp; !tea.BoolValue(util.Empty(err.Message)) </span><span class="cov0" title="0">{
                        r.log.Log(log.LevelError, "msg", "GetUserInfo", "error", err)
                        // err 中含有 code 和 message 属性，可帮助开发定位问题
                }</span>

        }

        <span class="cov0" title="0">r.log.Log(log.LevelInfo, "msg", "GetUserInfo", "response", response)

        return &amp;DingTalkUserInfo{
                UnionId: *response.Body.UnionId,
                Nick:    *response.Body.Nick,
        }, nil</span>
}

func (r *dingTalkRepo) GetUseridByUnionid(ctx context.Context, token, unionid string) (string, error) <span class="cov0" title="0">{

        r.log.Log(log.LevelInfo, "msg", "GetUseridByUnionid", "token", token, "unionid", unionid)
        uri := fmt.Sprintf("%s/topapi/user/getbyunionid?access_token=%s", r.data.Endpoint, token)
        input := &amp;DingTalkUseridByUnionidRequest{
                Unionid: unionid,
        }
        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">bs, err := httputil.PostJSON(uri, jsonData, time.Second*10)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">r.log.Log(log.LevelInfo, "msg", "GetUseridByUnionid", "body", string(bs), "err", err)

        var getUseridByUnionidResponse *DingTalkUseridByUnionidResponse
        if err = json.Unmarshal(bs, &amp;getUseridByUnionidResponse); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if getUseridByUnionidResponse.Errcode != 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("钉钉API返回错误: %s, errcode: %d", getUseridByUnionidResponse.Errmsg, getUseridByUnionidResponse.Errcode)
        }</span>
        <span class="cov0" title="0">if getUseridByUnionidResponse.Result.Userid == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("钉钉API返回错误 Result: %+v, Result.Userid: %s", getUseridByUnionidResponse.Result, getUseridByUnionidResponse.Result.Userid)
        }</span>
        <span class="cov0" title="0">return getUseridByUnionidResponse.Result.Userid, nil</span>
}

func (r *dingTalkRepo) FetchUserDetail(ctx context.Context, token string, userIds []string) ([]*DingtalkDeptUser, error) <span class="cov0" title="0">{
        r.log.Log(log.LevelInfo, "msg", "FetchUserDetail", "token", token, "userIds", userIds)

        uri := fmt.Sprintf("%s/topapi/v2/user/get?access_token=%s", r.data.Endpoint, token)

        r.log.Log(log.LevelInfo, "msg", "FetchUserDetail", "deptIds", userIds, "uri", uri)
        sem := make(chan struct{}, r.data.MaxConcurrent)
        userList := make([]*DingtalkDeptUser, 0)
        var mu sync.Mutex

        var wg sync.WaitGroup

        for _, userId := range userIds </span><span class="cov0" title="0">{
                wg.Add(1)

                select </span>{
                case sem &lt;- struct{}{}:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        wg.Done()
                        continue</span>
                }

                // 启动goroutine处理任务
                <span class="cov0" title="0">go func(id string) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                &lt;-sem     // 释放信号量
                                wg.Done() // 通知任务完成
                        }</span>()

                        <span class="cov0" title="0">input := &amp;DingTalkUserDetailRequest{
                                Userid: id,
                        }
                        jsonData, err := json.Marshal(input)
                        if err != nil </span><span class="cov0" title="0">{
                                r.log.Log(log.LevelError, "msg", "FetchUserDetail", "jsonData", string(jsonData), "err", err)
                                return
                        }</span>

                        <span class="cov0" title="0">bs, err := httputil.PostJSON(uri, jsonData, time.Second*10)
                        r.log.Log(log.LevelInfo, "msg", "FetchUserDetail", "PostJSON", string(bs), "err", err)
                        if err != nil </span><span class="cov0" title="0">{
                                r.log.Log(log.LevelError, "msg", "FetchUserDetail", "PostJSON", string(bs), "err", err)
                                return
                        }</span>
                        <span class="cov0" title="0">var userDetail *DingTalkUserDetailResponse
                        if err = json.Unmarshal(bs, &amp;userDetail); err != nil </span><span class="cov0" title="0">{
                                r.log.Log(log.LevelError, "msg", "FetchUserDetail", "Unmarshal", string(bs), "err", err)
                                return
                        }</span>
                        <span class="cov0" title="0">if userDetail.Errcode != 0 </span><span class="cov0" title="0">{
                                r.log.Log(log.LevelError, "msg", "FetchUserDetail", "钉钉API返回错误", "Errmsg", userDetail.Errmsg, "Errcode", userDetail.Errcode)
                                return
                        }</span>
                        <span class="cov0" title="0">user := userDetail.Result
                        //r.log.Info("GetUserDetail user: %v", user)
                        mu.Lock()
                        userList = append(userList, &amp;user)
                        mu.Unlock()</span>
                }(userId)
        }
        <span class="cov0" title="0">wg.Wait()

        return userList, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package dingtalk

import (
        "context"
        "errors"
)

func ValidateDingTalkUser(ctx context.Context, user *DingtalkDeptUser) error <span class="cov0" title="0">{
        if user.Name == "" </span><span class="cov0" title="0">{
                return errors.New("DingtalkDeptUser userid is empty")
        }</span>
        <span class="cov0" title="0">if user.Mobile == "" </span><span class="cov0" title="0">{
                return errors.New("DingtalkDeptUser mobile is empty")
        }</span>
        <span class="cov0" title="0">if len(user.DeptIDList) == 0 </span><span class="cov0" title="0">{
                return errors.New("DingtalkDeptUser deptid is empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package otel

import (
        "context"
        stdlog "log"
        "time"

        "nancalacc/internal/conf"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/jaeger"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.17.0"
        "go.opentelemetry.io/otel/trace"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        "go.opentelemetry.io/otel/log"
        "go.opentelemetry.io/otel/metric"
        traceNoop "go.opentelemetry.io/otel/sdk/trace"
)

// Config OpenTelemetry 配置
type Config struct {
        Enabled        bool          `json:"enabled"`
        ServiceName    string        `json:"service_name"`
        ServiceVersion string        `json:"service_version"`
        Environment    string        `json:"environment"`
        Traces         TracesConfig  `json:"traces"`
        Metrics        MetricsConfig `json:"metrics"`
        Logs           LogsConfig    `json:"logs"`
}

// TracesConfig 追踪配置
type TracesConfig struct {
        Enabled bool         `yaml:"enabled" json:"enabled"`
        Jaeger  JaegerConfig `yaml:"jaeger" json:"jaeger"`
        Otlp    OtlpConfig   `yaml:"otlp" json:"otlp"`
}

// JaegerConfig Jaeger 配置
type JaegerConfig struct {
        Enabled  bool   `yaml:"enabled" json:"enabled"`
        Endpoint string `yaml:"endpoint" json:"endpoint"`
}

// OtlpConfig OTLP 配置
type OtlpConfig struct {
        Enabled  bool   `yaml:"enabled" json:"enabled"`
        Endpoint string `yaml:"endpoint" json:"endpoint"`
        Timeout  int    `yaml:"timeout" json:"timeout"` // 超时时间（秒）
}

// MetricsConfig 指标配置
type MetricsConfig struct {
        Enabled    bool             `yaml:"enabled" json:"enabled"`
        Prometheus PrometheusConfig `yaml:"prometheus" json:"prometheus"`
}

// PrometheusConfig Prometheus 配置
type PrometheusConfig struct {
        Enabled  bool   `yaml:"enabled" json:"enabled"`
        Endpoint string `yaml:"endpoint" json:"endpoint"`
        Interval string `yaml:"interval" json:"interval"`
}

// LogsConfig 日志配置
type LogsConfig struct {
        Enabled        bool       `yaml:"enabled" json:"enabled"`
        Level          string     `yaml:"level" json:"level"`
        Format         string     `yaml:"format" json:"format"`
        Output         string     `yaml:"output" json:"output"`
        FilePath       string     `yaml:"file_path" json:"file_path"`
        MaxSize        int        `yaml:"max_size" json:"max_size"`
        MaxBackups     int        `yaml:"max_backups" json:"max_backups"`
        MaxAge         int        `yaml:"max_age" json:"max_age"`
        Compress       bool       `yaml:"compress" json:"compress"`
        Caller         bool       `yaml:"caller" json:"caller"`
        Stacktrace     bool       `yaml:"stacktrace" json:"stacktrace"`
        EscapeNewlines bool       `yaml:"escape_newlines" json:"escape_newlines"`
        Gorm           GormLogs   `yaml:"gorm" json:"gorm"`
        Loki           LokiConfig `yaml:"loki" json:"loki"`
        // Zap配置
        UseZap               bool   `yaml:"use_zap" json:"use_zap"`
        ZapDevelopment       bool   `yaml:"zap_development" json:"zap_development"`
        ZapDisableCaller     bool   `yaml:"zap_disable_caller" json:"zap_disable_caller"`
        ZapDisableStacktrace bool   `yaml:"zap_disable_stacktrace" json:"zap_disable_stacktrace"`
        ZapEncoding          string `yaml:"zap_encoding" json:"zap_encoding"`
        ZapTimeKey           string `yaml:"zap_time_key" json:"zap_time_key"`
        ZapLevelKey          string `yaml:"zap_level_key" json:"zap_level_key"`
        ZapNameKey           string `yaml:"zap_name_key" json:"zap_name_key"`
        ZapCallerKey         string `yaml:"zap_caller_key" json:"zap_caller_key"`
        ZapFunctionKey       string `yaml:"zap_function_key" json:"zap_function_key"`
        ZapMessageKey        string `yaml:"zap_message_key" json:"zap_message_key"`
        ZapStacktraceKey     string `yaml:"zap_stacktrace_key" json:"zap_stacktrace_key"`
}

// LokiConfig Loki 配置
type LokiConfig struct {
        Enabled  bool   `yaml:"enabled" json:"enabled"`
        Endpoint string `yaml:"endpoint" json:"endpoint"`
}

// Logs 日志配置
type Logs struct {
        Enabled        bool     `json:"enabled"`
        Level          string   `json:"level"`
        Format         string   `json:"format"`
        Output         string   `json:"output"`
        FilePath       string   `json:"file_path"`
        MaxSize        int      `json:"max_size"`
        MaxBackups     int      `json:"max_backups"`
        MaxAge         int      `json:"max_age"`
        Compress       bool     `json:"compress"`
        Caller         bool     `json:"caller"`
        Stacktrace     bool     `json:"stacktrace"`
        EscapeNewlines bool     `json:"escape_newlines"`
        Gorm           GormLogs `json:"gorm"`
        Loki           LokiLogs `json:"loki"`
}

// GormLogs GORM日志配置
type GormLogs struct {
        SlowThreshold string `json:"slow_threshold"`
        LogLevel      string `json:"log_level"`
}

// LokiLogs Loki日志配置
type LokiLogs struct {
        Enabled  bool   `json:"enabled"`
        Endpoint string `json:"endpoint"`
}

// DefaultConfig 返回默认配置
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Enabled:        true,
                ServiceName:    "nancalacc",
                ServiceVersion: "1.0.0",
                Environment:    "development",
                Traces: TracesConfig{
                        Enabled: true,
                        Jaeger: JaegerConfig{
                                Enabled:  true,
                                Endpoint: "http://localhost:14268/api/traces",
                        },
                        Otlp: OtlpConfig{
                                Enabled:  true,
                                Endpoint: "localhost:4317",
                                Timeout:  30,
                        },
                },
                Metrics: MetricsConfig{
                        Enabled: true,
                        Prometheus: PrometheusConfig{
                                Enabled:  true,
                                Endpoint: "localhost:9090",
                                Interval: "15s",
                        },
                },
                Logs: LogsConfig{
                        Enabled: true,
                        Level:   "info",
                        Format:  "json",
                        Loki: LokiConfig{
                                Enabled:  true,
                                Endpoint: "http://localhost:3100/loki/api/v1/push",
                        },
                        // Zap默认配置
                        UseZap:               true,   // 默认启用zap
                        ZapDevelopment:       false,  // 默认生产模式
                        ZapDisableCaller:     false,  // 默认启用调用者信息
                        ZapDisableStacktrace: false,  // 默认启用堆栈跟踪
                        ZapEncoding:          "json", // 默认JSON编码
                        ZapTimeKey:           "timestamp",
                        ZapLevelKey:          "level",
                        ZapNameKey:           "logger",
                        ZapCallerKey:         "caller",
                        ZapFunctionKey:       "func",
                        ZapMessageKey:        "message",
                        ZapStacktraceKey:     "stacktrace",
                },
        }
}</span>

// GetLogger 获取日志器
func (c *Config) GetLogger() log.Logger <span class="cov0" title="0">{
        if !c.Enabled || !c.Logs.Enabled </span><span class="cov0" title="0">{
                stdlog.Printf("🔍 [DEBUG] OpenTelemetry logs disabled, using noop logger")
                // 暂时返回 nil，避免导入问题
                return nil
        }</span>

        <span class="cov0" title="0">stdlog.Printf("🔍 [DEBUG] OpenTelemetry logs enabled, attempting to create configured logger")
        // 创建基于配置的日志器
        return c.createConfiguredLogger()</span>
}

// createConfiguredLogger 根据配置创建日志器
func (c *Config) createConfiguredLogger() log.Logger <span class="cov0" title="0">{
        stdlog.Printf("🔍 [DEBUG] Creating configured logger...")

        // 这里应该根据配置创建真正的日志器
        // 由于OpenTelemetry的日志API比较复杂，我们使用Kratos的标准日志器
        // 并在适配器中处理级别过滤

        // 暂时返回 nil，避免导入问题
        stdlog.Printf("🔍 [DEBUG] Returning nil logger (not yet implemented)")
        return nil
}</span>

// GetTracer 获取追踪器
func (c *Config) GetTracer() trace.Tracer <span class="cov0" title="0">{
        if !c.Enabled || !c.Traces.Enabled </span><span class="cov0" title="0">{
                stdlog.Printf("🔍 [DEBUG] OpenTelemetry traces disabled, using noop tracer")
                return traceNoop.NewTracerProvider().Tracer("nancalacc")
        }</span>

        <span class="cov0" title="0">stdlog.Printf("🔍 [DEBUG] OpenTelemetry traces enabled, attempting to create real tracer")

        // 尝试创建真正的追踪器
        if c.Traces.Jaeger.Enabled </span><span class="cov0" title="0">{
                stdlog.Printf("🔍 [DEBUG] Jaeger tracing enabled, endpoint: %s", c.Traces.Jaeger.Endpoint)
                // 创建真正的 Jaeger 导出器
                return c.createJaegerTracer()
        }</span>

        // 如果没有配置 Jaeger，尝试使用 OTLP
        <span class="cov0" title="0">if c.Traces.Otlp.Enabled </span><span class="cov0" title="0">{
                stdlog.Printf("🔍 [DEBUG] OTLP tracing enabled, endpoint: %s", c.Traces.Otlp.Endpoint)
                // 创建真正的 OTLP 导出器
                return c.createOTLPTracer()
        }</span>

        <span class="cov0" title="0">stdlog.Printf("🔍 [DEBUG] No tracing backend configured, using noop tracer")
        // 使用 noop 追踪器作为默认实现
        return traceNoop.NewTracerProvider().Tracer("nancalacc")</span>
}

// GetMeter 获取指标器
func (c *Config) GetMeter() metric.Meter <span class="cov0" title="0">{
        if !c.Enabled || !c.Metrics.Enabled </span><span class="cov0" title="0">{
                // 暂时返回 nil，避免导入问题
                return nil
        }</span>
        // 暂时返回 nil，避免导入问题
        <span class="cov0" title="0">return nil</span>
}

// ConfigAdapter 配置适配器
type ConfigAdapter struct{}

// NewConfigAdapter 创建配置适配器
func NewConfigAdapter() *ConfigAdapter <span class="cov0" title="0">{
        return &amp;ConfigAdapter{}
}</span>

// FromBootstrap 从Bootstrap配置转换为OpenTelemetry配置
func (a *ConfigAdapter) FromBootstrap(bootstrap interface{}) *Config <span class="cov0" title="0">{
        // 使用反射获取Bootstrap配置
        // 这里简化处理，直接返回默认配置
        // 在实际使用中，应该根据Bootstrap配置进行转换

        // 尝试从Bootstrap中获取OpenTelemetry配置
        if bc, ok := bootstrap.(*conf.Bootstrap); ok &amp;&amp; bc.Otel != nil </span><span class="cov0" title="0">{
                config := &amp;Config{
                        Enabled:        bc.Otel.Enabled,
                        ServiceName:    bc.Otel.ServiceName,
                        ServiceVersion: bc.Otel.ServiceVersion,
                        Environment:    bc.Otel.Environment,
                        Traces: TracesConfig{
                                Enabled: bc.Otel.Traces.Enabled,
                                Jaeger: JaegerConfig{
                                        Enabled:  bc.Otel.Traces.Jaeger.Enabled,
                                        Endpoint: bc.Otel.Traces.Jaeger.Endpoint,
                                },
                                Otlp: OtlpConfig{
                                        Enabled:  bc.Otel.Traces.Otlp.Enabled,
                                        Endpoint: bc.Otel.Traces.Otlp.Endpoint,
                                },
                        },
                        Metrics: MetricsConfig{
                                Enabled: bc.Otel.Metrics.Enabled,
                                Prometheus: PrometheusConfig{
                                        Enabled:  bc.Otel.Metrics.Prometheus.Enabled,
                                        Endpoint: bc.Otel.Metrics.Prometheus.Endpoint,
                                        Interval: bc.Otel.Metrics.Prometheus.Interval,
                                },
                        },
                        Logs: LogsConfig{
                                Enabled:  bc.Otel.Logs.Enabled,
                                Level:    bc.Otel.Logs.Level,
                                Format:   bc.Otel.Logs.Format,
                                Output:   bc.Otel.Logs.Output,
                                FilePath: bc.Otel.Logs.FilePath,
                                Loki: LokiConfig{
                                        Enabled:  bc.Otel.Logs.Loki.Enabled,
                                        Endpoint: bc.Otel.Logs.Loki.Endpoint,
                                },
                                // Zap配置
                                UseZap:               bc.Otel.Logs.UseZap,
                                ZapDevelopment:       bc.Otel.Logs.ZapDevelopment,
                                ZapDisableCaller:     bc.Otel.Logs.ZapDisableCaller,
                                ZapDisableStacktrace: bc.Otel.Logs.ZapDisableStacktrace,
                                ZapEncoding:          bc.Otel.Logs.ZapEncoding,
                                ZapTimeKey:           bc.Otel.Logs.ZapTimeKey,
                                ZapLevelKey:          bc.Otel.Logs.ZapLevelKey,
                                ZapNameKey:           bc.Otel.Logs.ZapNameKey,
                                ZapCallerKey:         bc.Otel.Logs.ZapCallerKey,
                                ZapFunctionKey:       bc.Otel.Logs.ZapFunctionKey,
                                ZapMessageKey:        bc.Otel.Logs.ZapMessageKey,
                                ZapStacktraceKey:     bc.Otel.Logs.ZapStacktraceKey,
                        },
                }
                return config
        }</span>

        <span class="cov0" title="0">return DefaultConfig()</span>
}

// NewConfigFromConf 从 conf.OpenTelemetry 创建 Config
func NewConfigFromConf(otelConf *conf.OpenTelemetry) *Config <span class="cov0" title="0">{
        if otelConf == nil </span><span class="cov0" title="0">{
                return DefaultConfig()
        }</span>

        <span class="cov0" title="0">config := &amp;Config{
                Enabled:        otelConf.Enabled,
                ServiceName:    otelConf.ServiceName,
                ServiceVersion: otelConf.ServiceVersion,
                Environment:    otelConf.Environment,
        }

        // 设置追踪配置
        if otelConf.Traces != nil </span><span class="cov0" title="0">{
                config.Traces.Enabled = otelConf.Traces.Enabled
                if otelConf.Traces.Jaeger != nil </span><span class="cov0" title="0">{
                        config.Traces.Jaeger.Enabled = otelConf.Traces.Jaeger.Enabled
                        config.Traces.Jaeger.Endpoint = otelConf.Traces.Jaeger.Endpoint
                }</span>
                <span class="cov0" title="0">if otelConf.Traces.Otlp != nil </span><span class="cov0" title="0">{
                        config.Traces.Otlp.Enabled = otelConf.Traces.Otlp.Enabled
                        config.Traces.Otlp.Endpoint = otelConf.Traces.Otlp.Endpoint
                }</span>
        }

        // 设置指标配置
        <span class="cov0" title="0">if otelConf.Metrics != nil </span><span class="cov0" title="0">{
                config.Metrics.Enabled = otelConf.Metrics.Enabled
                if otelConf.Metrics.Prometheus != nil </span><span class="cov0" title="0">{
                        config.Metrics.Prometheus.Enabled = otelConf.Metrics.Prometheus.Enabled
                        config.Metrics.Prometheus.Endpoint = otelConf.Metrics.Prometheus.Endpoint
                        config.Metrics.Prometheus.Interval = otelConf.Metrics.Prometheus.Interval
                }</span>
        }

        // 设置日志配置
        <span class="cov0" title="0">if otelConf.Logs != nil </span><span class="cov0" title="0">{
                config.Logs.Enabled = otelConf.Logs.Enabled
                config.Logs.Level = otelConf.Logs.Level
                config.Logs.Format = otelConf.Logs.Format
                config.Logs.Output = otelConf.Logs.Output
                config.Logs.FilePath = otelConf.Logs.FilePath
                if otelConf.Logs.Loki != nil </span><span class="cov0" title="0">{
                        config.Logs.Loki.Enabled = otelConf.Logs.Loki.Enabled
                        config.Logs.Loki.Endpoint = otelConf.Logs.Loki.Endpoint
                }</span>
                // Zap配置
                <span class="cov0" title="0">config.Logs.UseZap = otelConf.Logs.UseZap
                config.Logs.ZapDevelopment = otelConf.Logs.ZapDevelopment
                config.Logs.ZapDisableCaller = otelConf.Logs.ZapDisableCaller
                config.Logs.ZapDisableStacktrace = otelConf.Logs.ZapDisableStacktrace
                config.Logs.ZapEncoding = otelConf.Logs.ZapEncoding
                config.Logs.ZapTimeKey = otelConf.Logs.ZapTimeKey
                config.Logs.ZapLevelKey = otelConf.Logs.ZapLevelKey
                config.Logs.ZapNameKey = otelConf.Logs.ZapNameKey
                config.Logs.ZapCallerKey = otelConf.Logs.ZapCallerKey
                config.Logs.ZapFunctionKey = otelConf.Logs.ZapFunctionKey
                config.Logs.ZapMessageKey = otelConf.Logs.ZapMessageKey
                config.Logs.ZapStacktraceKey = otelConf.Logs.ZapStacktraceKey</span>
        }

        <span class="cov0" title="0">return config</span>
}

// createJaegerTracer 创建 Jaeger 追踪器
func (c *Config) createJaegerTracer() trace.Tracer <span class="cov0" title="0">{
        stdlog.Printf("🔍 [DEBUG] Creating real Jaeger tracer with endpoint: %s", c.Traces.Jaeger.Endpoint)

        // 创建 Jaeger 导出器
        exporter, err := jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(c.Traces.Jaeger.Endpoint)))
        if err != nil </span><span class="cov0" title="0">{
                stdlog.Printf("🔍 [ERROR] Failed to create Jaeger exporter: %v", err)
                stdlog.Printf("🔍 [DEBUG] Falling back to noop tracer")
                return traceNoop.NewTracerProvider().Tracer("nancalacc")
        }</span>

        // 创建资源
        <span class="cov0" title="0">ctx := context.Background()
        res, err := resource.New(ctx,
                resource.WithAttributes(
                        semconv.ServiceName(c.ServiceName),
                        semconv.ServiceVersion(c.ServiceVersion),
                        semconv.DeploymentEnvironment(c.Environment),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                stdlog.Printf("🔍 [ERROR] Failed to create resource: %v", err)
                stdlog.Printf("🔍 [DEBUG] Falling back to noop tracer")
                return traceNoop.NewTracerProvider().Tracer("nancalacc")
        }</span>

        // 创建 TracerProvider
        <span class="cov0" title="0">tp := sdktrace.NewTracerProvider(
                sdktrace.WithBatcher(exporter),
                sdktrace.WithResource(res),
        )

        // 设置全局 TracerProvider
        otel.SetTracerProvider(tp)

        // 创建 tracer
        tracer := tp.Tracer(c.ServiceName)

        stdlog.Printf("🔍 [DEBUG] Real Jaeger tracer created successfully")
        return tracer</span>
}

// createOTLPTracer 创建 OTLP 追踪器
func (c *Config) createOTLPTracer() trace.Tracer <span class="cov0" title="0">{
        stdlog.Printf("🔍 [DEBUG] Creating real OTLP tracer with endpoint: %s", c.Traces.Otlp.Endpoint)

        ctx, cancel := context.WithTimeout(context.Background(), time.Duration(c.Traces.Otlp.Timeout)*time.Second)
        defer cancel()

        // 创建 gRPC 连接
        conn, err := grpc.DialContext(ctx, c.Traces.Otlp.Endpoint,
                grpc.WithTransportCredentials(insecure.NewCredentials()),
                grpc.WithBlock(),
        )
        if err != nil </span><span class="cov0" title="0">{
                stdlog.Printf("🔍 [ERROR] Failed to connect to OTLP endpoint: %v", err)
                stdlog.Printf("🔍 [DEBUG] Falling back to noop tracer")
                return trace.NewNoopTracerProvider().Tracer("nancalacc")
        }</span>

        // 创建 OTLP 导出器
        <span class="cov0" title="0">exporter, err := otlptrace.New(ctx, otlptracegrpc.NewClient(otlptracegrpc.WithGRPCConn(conn)))
        if err != nil </span><span class="cov0" title="0">{
                stdlog.Printf("🔍 [ERROR] Failed to create OTLP exporter: %v", err)
                stdlog.Printf("🔍 [DEBUG] Falling back to noop tracer")
                return trace.NewNoopTracerProvider().Tracer("nancalacc")
        }</span>

        // 创建资源
        <span class="cov0" title="0">res, err := resource.New(ctx,
                resource.WithAttributes(
                        semconv.ServiceName(c.ServiceName),
                        semconv.ServiceVersion(c.ServiceVersion),
                        semconv.DeploymentEnvironment(c.Environment),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                stdlog.Printf("🔍 [ERROR] Failed to create resource: %v", err)
                stdlog.Printf("🔍 [DEBUG] Falling back to noop tracer")
                return trace.NewNoopTracerProvider().Tracer("nancalacc")
        }</span>

        // 创建 TracerProvider
        <span class="cov0" title="0">tp := sdktrace.NewTracerProvider(
                sdktrace.WithBatcher(exporter),
                sdktrace.WithResource(res),
        )

        // 设置全局 TracerProvider
        otel.SetTracerProvider(tp)

        // 创建 tracer
        tracer := tp.Tracer(c.ServiceName)

        stdlog.Printf("🔍 [DEBUG] Real OTLP tracer created successfully")
        return tracer</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package otel

import (
        "context"
        "time"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/log"
        "go.opentelemetry.io/otel/metric"
        "go.opentelemetry.io/otel/trace"
)

// TraceHelper 追踪辅助函数
type TraceHelper struct {
        tracer trace.Tracer
}

// NewTraceHelper 创建追踪辅助函数
func NewTraceHelper(tracer trace.Tracer) *TraceHelper <span class="cov0" title="0">{
        return &amp;TraceHelper{tracer: tracer}
}</span>

// StartSpan 开始一个新的 span
func (h *TraceHelper) StartSpan(ctx context.Context, name string, attrs ...attribute.KeyValue) (context.Context, trace.Span) <span class="cov0" title="0">{
        return h.tracer.Start(ctx, name, trace.WithAttributes(attrs...))
}</span>

// AddEvent 添加事件到当前 span
func AddEvent(ctx context.Context, name string, attrs ...attribute.KeyValue) <span class="cov0" title="0">{
        if span := trace.SpanFromContext(ctx); span != nil </span><span class="cov0" title="0">{
                span.AddEvent(name, trace.WithAttributes(attrs...))
        }</span>
}

// SetAttributes 设置属性到当前 span
func SetAttributes(ctx context.Context, attrs ...attribute.KeyValue) <span class="cov0" title="0">{
        if span := trace.SpanFromContext(ctx); span != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attrs...)
        }</span>
}

// RecordError 记录错误到当前 span
func RecordError(ctx context.Context, err error, attrs ...attribute.KeyValue) <span class="cov0" title="0">{
        if span := trace.SpanFromContext(ctx); span != nil </span><span class="cov0" title="0">{
                span.RecordError(err, trace.WithAttributes(attrs...))
        }</span>
}

// MetricsHelper 指标辅助函数
type MetricsHelper struct {
        meter metric.Meter
}

// NewMetricsHelper 创建指标辅助函数
func NewMetricsHelper(meter metric.Meter) *MetricsHelper <span class="cov0" title="0">{
        return &amp;MetricsHelper{meter: meter}
}</span>

// Counter 计数器
type Counter struct {
        counter metric.Int64Counter
}

// NewCounter 创建计数器
func (h *MetricsHelper) NewCounter(name, description string, unit string) *Counter <span class="cov0" title="0">{
        counter, err := h.meter.Int64Counter(name, metric.WithDescription(description), metric.WithUnit(unit))
        if err != nil </span><span class="cov0" title="0">{
                // 在实际应用中，你可能想要记录这个错误
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;Counter{counter: counter}</span>
}

// Add 增加计数器值
func (c *Counter) Add(ctx context.Context, value int64, attrs ...attribute.KeyValue) <span class="cov0" title="0">{
        if c.counter != nil </span><span class="cov0" title="0">{
                c.counter.Add(ctx, value, metric.WithAttributes(attrs...))
        }</span>
}

// Histogram 直方图
type Histogram struct {
        histogram metric.Float64Histogram
}

// NewHistogram 创建直方图
func (h *MetricsHelper) NewHistogram(name, description string, unit string) *Histogram <span class="cov0" title="0">{
        histogram, err := h.meter.Float64Histogram(name, metric.WithDescription(description), metric.WithUnit(unit))
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;Histogram{histogram: histogram}</span>
}

// Record 记录直方图值
func (h *Histogram) Record(ctx context.Context, value float64, attrs ...attribute.KeyValue) <span class="cov0" title="0">{
        if h.histogram != nil </span><span class="cov0" title="0">{
                h.histogram.Record(ctx, value, metric.WithAttributes(attrs...))
        }</span>
}

// Attribute 创建属性键值对
func Attribute(key string, value interface{}) attribute.KeyValue <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return attribute.String(key, v)</span>
        case int:<span class="cov0" title="0">
                return attribute.Int(key, v)</span>
        case int64:<span class="cov0" title="0">
                return attribute.Int64(key, v)</span>
        case float64:<span class="cov0" title="0">
                return attribute.Float64(key, v)</span>
        case bool:<span class="cov0" title="0">
                return attribute.Bool(key, v)</span>
        default:<span class="cov0" title="0">
                return attribute.String(key, "unknown")</span>
        }
}

// Gauge 仪表盘
type Gauge struct {
        gauge metric.Float64ObservableGauge
}

// NewGauge 创建仪表盘
func (h *MetricsHelper) NewGauge(name, description string, unit string, callback func(context.Context, metric.Float64Observer) error) *Gauge <span class="cov0" title="0">{
        gauge, err := h.meter.Float64ObservableGauge(name, metric.WithDescription(description), metric.WithUnit(unit), metric.WithFloat64Callback(callback))
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;Gauge{gauge: gauge}</span>
}

// LogHelper 日志辅助函数
type LogHelper struct {
        logger log.Logger
}

// NewLogHelper 创建日志辅助函数
func NewLogHelper(logger log.Logger) *LogHelper <span class="cov0" title="0">{
        return &amp;LogHelper{logger: logger}
}</span>

// Info 记录信息日志
func (h *LogHelper) Info(ctx context.Context, msg string, attrs ...attribute.KeyValue) <span class="cov0" title="0">{
        // 记录日志
        if h.logger != nil </span><span class="cov0" title="0">{
                record := log.Record{}
                record.SetTimestamp(time.Now())
                record.SetSeverity(log.SeverityInfo)
                record.SetBody(log.StringValue(msg))
                for _, attr := range attrs </span><span class="cov0" title="0">{
                        record.AddAttributes(log.KeyValueFromAttribute(attr))
                }</span>
                <span class="cov0" title="0">h.logger.Emit(ctx, record)</span>
        }
}

// Error 记录错误日志
func (h *LogHelper) Error(ctx context.Context, msg string, attrs ...attribute.KeyValue) <span class="cov0" title="0">{
        if h.logger != nil </span><span class="cov0" title="0">{
                record := log.Record{}
                record.SetTimestamp(time.Now())
                record.SetSeverity(log.SeverityError)
                record.SetBody(log.StringValue(msg))
                for _, attr := range attrs </span><span class="cov0" title="0">{
                        record.AddAttributes(log.KeyValueFromAttribute(attr))
                }</span>
                <span class="cov0" title="0">h.logger.Emit(ctx, record)</span>
        }
}

// Debug 记录调试日志
func (h *LogHelper) Debug(ctx context.Context, msg string, attrs ...attribute.KeyValue) <span class="cov0" title="0">{
        if h.logger != nil </span><span class="cov0" title="0">{
                record := log.Record{}
                record.SetTimestamp(time.Now())
                record.SetSeverity(log.SeverityDebug)
                record.SetBody(log.StringValue(msg))
                for _, attr := range attrs </span><span class="cov0" title="0">{
                        record.AddAttributes(log.KeyValueFromAttribute(attr))
                }</span>
                <span class="cov0" title="0">h.logger.Emit(ctx, record)</span>
        }
}

// Warn 记录警告日志
func (h *LogHelper) Warn(ctx context.Context, msg string, attrs ...attribute.KeyValue) <span class="cov0" title="0">{
        if h.logger != nil </span><span class="cov0" title="0">{
                record := log.Record{}
                record.SetTimestamp(time.Now())
                record.SetSeverity(log.SeverityWarn)
                record.SetBody(log.StringValue(msg))
                for _, attr := range attrs </span><span class="cov0" title="0">{
                        record.AddAttributes(log.KeyValueFromAttribute(attr))
                }</span>
                <span class="cov0" title="0">h.logger.Emit(ctx, record)</span>
        }
}

// TimeOperation 计时操作辅助函数
func TimeOperation(ctx context.Context, name string, operation func(context.Context) error) error <span class="cov0" title="0">{
        start := time.Now()

        // 创建 span
        ctx, span := trace.SpanFromContext(ctx).TracerProvider().Tracer("nancalacc").Start(ctx, name)
        defer span.End()

        // 执行操作
        err := operation(ctx)

        // 记录执行时间
        duration := time.Since(start)
        span.SetAttributes(attribute.Int64("duration_ms", duration.Milliseconds()))

        // 记录指标 - 使用全局 meter
        if meter := otel.GetMeterProvider().Meter("nancalacc"); meter != nil </span><span class="cov0" title="0">{
                if histogram, _ := meter.Float64Histogram("operation_duration_seconds"); histogram != nil </span><span class="cov0" title="0">{
                        histogram.Record(ctx, duration.Seconds(), metric.WithAttributes(attribute.String("operation", name)))
                }</span>
        }

        <span class="cov0" title="0">return err</span>
}

// CommonAttributes 常用属性
var CommonAttributes = struct {
        ServiceName    attribute.Key
        ServiceVersion attribute.Key
        Environment    attribute.Key
        Operation      attribute.Key
        Status         attribute.Key
        Error          attribute.Key
        Duration       attribute.Key
}{
        ServiceName:    attribute.Key("service.name"),
        ServiceVersion: attribute.Key("service.version"),
        Environment:    attribute.Key("environment"),
        Operation:      attribute.Key("operation"),
        Status:         attribute.Key("status"),
        Error:          attribute.Key("error"),
        Duration:       attribute.Key("duration"),
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package otel

import (
        "context"
        stdlog "log"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/go-kratos/kratos/v2/middleware"
        "github.com/go-kratos/kratos/v2/middleware/tracing"
        "github.com/go-kratos/kratos/v2/transport"
        "github.com/go-kratos/kratos/v2/transport/grpc"
        "github.com/go-kratos/kratos/v2/transport/http"
        "go.opentelemetry.io/otel/attribute"
        otellog "go.opentelemetry.io/otel/log"
)

// Integration OpenTelemetry 集成器
type Integration struct {
        service *Service
        config  *Config
}

// NewIntegration 创建集成器
func NewIntegration(config *Config) *Integration <span class="cov0" title="0">{
        stdlog.Printf("🔍 [DEBUG] Creating new OpenTelemetry integration")
        stdlog.Printf("🔍 [DEBUG] Config - Enabled: %v, Traces: %v, Logs: %v", config.Enabled, config.Traces.Enabled, config.Logs.Enabled)

        // 创建真正的 OpenTelemetry 服务
        service := NewService(
                config.GetTracer(),
                config.GetMeter(),
                config.GetLogger(),
        )

        stdlog.Printf("🔍 [DEBUG] OpenTelemetry service created")

        return &amp;Integration{
                service: service,
                config:  config,
        }
}</span>

// Init 初始化集成器
func (i *Integration) Init(ctx context.Context) error <span class="cov0" title="0">{
        return i.service.Init(ctx)
}</span>

// Shutdown 关闭集成器
func (i *Integration) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        return i.service.Shutdown(ctx)
}</span>

// GetService 获取服务实例
func (i *Integration) GetService() *Service <span class="cov0" title="0">{
        return i.service
}</span>

// GetLogger 获取OpenTelemetry日志器
func (i *Integration) GetLogger() otellog.Logger <span class="cov0" title="0">{
        return i.service.Logger()
}</span>

// CreateLogger 创建Kratos兼容的日志器
func (i *Integration) CreateLogger() log.Logger <span class="cov0" title="0">{
        return NewKratosLoggerAdapter(i.service.Logger(), i.config)
}</span>

// CreateHTTPMiddleware 创建HTTP中间件
func (i *Integration) CreateHTTPMiddleware() []http.ServerOption <span class="cov0" title="0">{
        stdlog.Printf("🔍 [DEBUG] CreateHTTPMiddleware called, enabled: %v, traces: %v", i.config.Enabled, i.config.Traces.Enabled)

        if !i.config.Enabled || !i.config.Traces.Enabled </span><span class="cov0" title="0">{
                stdlog.Printf("🔍 [DEBUG] HTTP middleware disabled, returning nil")
                return nil
        }</span>

        <span class="cov0" title="0">stdlog.Printf("🔍 [DEBUG] Creating HTTP middleware with tracing and logging")
        return []http.ServerOption{
                http.Middleware(
                        tracing.Server(),
                        i.createLoggingMiddleware(),
                ),
        }</span>
}

// CreateGRPCMiddleware 创建gRPC中间件
func (i *Integration) CreateGRPCMiddleware() []grpc.ServerOption <span class="cov0" title="0">{
        stdlog.Printf("🔍 [DEBUG] CreateGRPCMiddleware called, enabled: %v, traces: %v", i.config.Enabled, i.config.Traces.Enabled)

        if !i.config.Enabled || !i.config.Traces.Enabled </span><span class="cov0" title="0">{
                stdlog.Printf("🔍 [DEBUG] gRPC middleware disabled, returning nil")
                return nil
        }</span>

        <span class="cov0" title="0">stdlog.Printf("🔍 [DEBUG] Creating gRPC middleware with tracing and logging")
        return []grpc.ServerOption{
                grpc.Middleware(
                        tracing.Server(),
                        i.createLoggingMiddleware(),
                ),
        }</span>
}

// createLoggingMiddleware 创建日志中间件
func (i *Integration) createLoggingMiddleware() middleware.Middleware <span class="cov0" title="0">{
        return func(handler middleware.Handler) middleware.Handler </span><span class="cov0" title="0">{
                return func(ctx context.Context, req interface{}) (reply interface{}, err error) </span><span class="cov0" title="0">{
                        // 获取请求信息
                        var (
                                operation string
                                kind      string
                                start     = time.Now()
                        )
                        if tr, ok := transport.FromServerContext(ctx); ok </span><span class="cov0" title="0">{
                                operation = tr.Operation()
                                kind = tr.Kind().String()
                        }</span>

                        // 添加调试日志
                        <span class="cov0" title="0">stdlog.Printf("🔍 [DEBUG] Creating span for operation: %s, kind: %s", operation, kind)

                        // 创建span
                        ctx, span := i.service.GetTracer().Start(ctx, operation)
                        defer span.End()

                        // 设置span属性
                        span.SetAttributes(
                                attribute.String("transport.kind", kind),
                                attribute.String("transport.operation", operation),
                        )

                        stdlog.Printf("🔍 [DEBUG] Span created with attributes: transport.kind=%s, transport.operation=%s", kind, operation)

                        // 记录请求开始日志
                        if i.config.Logs.Enabled </span><span class="cov0" title="0">{
                                stdlog.Printf("🔍 [DEBUG] Logs enabled, creating logger for request start")
                                logger := i.CreateLogger()
                                logger.Log(log.LevelInfo,
                                        "msg", "request started",
                                        "operation", operation,
                                        "kind", kind,
                                        "request", req,
                                )
                                stdlog.Printf("🔍 [DEBUG] Request start log recorded")
                        }</span> else<span class="cov0" title="0"> {
                                stdlog.Printf("🔍 [DEBUG] Logs disabled, skipping request start log")
                        }</span>

                        // 执行请求
                        <span class="cov0" title="0">reply, err = handler(ctx, req)

                        // 记录请求结束日志
                        if i.config.Logs.Enabled </span><span class="cov0" title="0">{
                                stdlog.Printf("🔍 [DEBUG] Logs enabled, creating logger for request end")
                                logger := i.CreateLogger()
                                logger.Log(log.LevelInfo,
                                        "msg", "request finished",
                                        "operation", operation,
                                        "kind", kind,
                                        "duration", time.Since(start).String(),
                                        "error", err,
                                )
                                stdlog.Printf("🔍 [DEBUG] Request end log recorded, duration: %s", time.Since(start).String())
                        }</span> else<span class="cov0" title="0"> {
                                stdlog.Printf("🔍 [DEBUG] Logs disabled, skipping request end log")
                        }</span>

                        // 记录错误到span
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                stdlog.Printf("🔍 [DEBUG] Recording error to span: %v", err)
                                span.RecordError(err)
                        }</span>

                        <span class="cov0" title="0">stdlog.Printf("🔍 [DEBUG] Span ending for operation: %s", operation)
                        return reply, err</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package otel

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        otellog "go.opentelemetry.io/otel/log"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "gopkg.in/natefinch/lumberjack.v2"
)

// KratosLoggerAdapter 适配OpenTelemetry Logger到Kratos Logger
type KratosLoggerAdapter struct {
        otellogger   otellog.Logger
        config       *Config
        writer       *lumberjack.Logger
        zapLogger    *zap.Logger   // 新增zap logger
        lokiExporter *LokiExporter // 新增Loki导出器
}

// NewKratosLoggerAdapter 创建Kratos Logger适配器
func NewKratosLoggerAdapter(otellogger otellog.Logger, config *Config) log.Logger <span class="cov0" title="0">{
        adapter := &amp;KratosLoggerAdapter{
                otellogger: otellogger,
                config:     config,
        }

        // 如果配置了文件输出，创建文件写入器
        if config != nil &amp;&amp; config.Logs.Enabled &amp;&amp; (config.Logs.Output == "file" || config.Logs.Output == "both") &amp;&amp; config.Logs.FilePath != "" </span><span class="cov0" title="0">{
                // 确保日志目录存在
                logDir := filepath.Dir(config.Logs.FilePath)
                if err := os.MkdirAll(logDir, 0755); err == nil </span><span class="cov0" title="0">{
                        // 创建lumberjack日志轮转器
                        adapter.writer = &amp;lumberjack.Logger{
                                Filename:   config.Logs.FilePath,   // 日志文件路径
                                MaxSize:    config.Logs.MaxSize,    // 单个文件最大大小(MB)
                                MaxBackups: config.Logs.MaxBackups, // 最大备份文件数
                                MaxAge:     config.Logs.MaxAge,     // 最大保留天数
                                Compress:   config.Logs.Compress,   // 是否压缩
                        }
                }</span>
        }

        // 初始化Loki导出器
        <span class="cov0" title="0">adapter.initLokiExporter()

        // 初始化zap logger
        adapter.initZapLogger()

        return adapter</span>
}

// initLokiExporter 初始化Loki导出器
func (a *KratosLoggerAdapter) initLokiExporter() <span class="cov0" title="0">{
        if a.config == nil || !a.config.Logs.Enabled || !a.config.Logs.Loki.Enabled </span><span class="cov0" title="0">{
                return
        }</span>

        // 创建Loki导出器
        <span class="cov0" title="0">a.lokiExporter = NewLokiExporter(a.config.Logs.Loki.Endpoint, a)

        // 打印调试信息
        fmt.Printf("🔧 Loki导出器已初始化，端点: %s\n", a.config.Logs.Loki.Endpoint)</span>
}

// initZapLogger 初始化zap logger
func (a *KratosLoggerAdapter) initZapLogger() <span class="cov0" title="0">{
        if a.config == nil || !a.config.Logs.Enabled </span><span class="cov0" title="0">{
                return
        }</span>

        // 检查是否启用zap
        <span class="cov0" title="0">if !a.config.Logs.UseZap </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var core zapcore.Core
        var err error

        // 根据配置创建zap logger
        switch a.config.Logs.Output </span>{
        case "stdout":<span class="cov0" title="0">
                core, err = a.createZapCore("stdout", nil)</span>
        case "file":<span class="cov0" title="0">
                if a.writer != nil </span><span class="cov0" title="0">{
                        core, err = a.createZapCore("file", a.writer)
                }</span>
        case "both":<span class="cov0" title="0">
                // 同时输出到控制台和文件
                consoleCore, _ := a.createZapCore("stdout", nil)
                fileCore, _ := a.createZapCore("file", a.writer)
                if consoleCore != nil &amp;&amp; fileCore != nil </span><span class="cov0" title="0">{
                        core = zapcore.NewTee(consoleCore, fileCore)
                }</span> else<span class="cov0" title="0"> if consoleCore != nil </span><span class="cov0" title="0">{
                        core = consoleCore
                }</span> else<span class="cov0" title="0"> if fileCore != nil </span><span class="cov0" title="0">{
                        core = fileCore
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // 如果创建失败，使用默认配置
                core = zapcore.NewCore(
                        zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()),
                        zapcore.AddSync(os.Stdout),
                        zap.NewAtomicLevelAt(zap.InfoLevel),
                )
        }</span>

        <span class="cov0" title="0">if core != nil </span><span class="cov0" title="0">{
                // 构建zap选项
                options := []zap.Option{}

                // 添加调用者信息
                if !a.config.Logs.ZapDisableCaller </span><span class="cov0" title="0">{
                        options = append(options, zap.AddCaller(), zap.AddCallerSkip(2))
                }</span>

                // 添加堆栈跟踪
                <span class="cov0" title="0">if !a.config.Logs.ZapDisableStacktrace </span><span class="cov0" title="0">{
                        options = append(options, zap.AddStacktrace(zap.ErrorLevel))
                }</span>

                <span class="cov0" title="0">a.zapLogger = zap.New(core, options...)</span>
        }
}

// createZapCore 创建zap core
func (a *KratosLoggerAdapter) createZapCore(output string, writer *lumberjack.Logger) (zapcore.Core, error) <span class="cov0" title="0">{
        // 配置编码器
        var encoderConfig zapcore.EncoderConfig
        if a.config.Logs.ZapDevelopment </span><span class="cov0" title="0">{
                encoderConfig = zap.NewDevelopmentEncoderConfig()
        }</span> else<span class="cov0" title="0"> {
                encoderConfig = zap.NewProductionEncoderConfig()
        }</span>

        // 自定义字段名
        <span class="cov0" title="0">if a.config.Logs.ZapTimeKey != "" </span><span class="cov0" title="0">{
                encoderConfig.TimeKey = a.config.Logs.ZapTimeKey
        }</span>
        <span class="cov0" title="0">if a.config.Logs.ZapLevelKey != "" </span><span class="cov0" title="0">{
                encoderConfig.LevelKey = a.config.Logs.ZapLevelKey
        }</span>
        <span class="cov0" title="0">if a.config.Logs.ZapNameKey != "" </span><span class="cov0" title="0">{
                encoderConfig.NameKey = a.config.Logs.ZapNameKey
        }</span>
        <span class="cov0" title="0">if a.config.Logs.ZapCallerKey != "" </span><span class="cov0" title="0">{
                encoderConfig.CallerKey = a.config.Logs.ZapCallerKey
        }</span>
        <span class="cov0" title="0">if a.config.Logs.ZapFunctionKey != "" </span><span class="cov0" title="0">{
                encoderConfig.FunctionKey = a.config.Logs.ZapFunctionKey
        }</span>
        <span class="cov0" title="0">if a.config.Logs.ZapMessageKey != "" </span><span class="cov0" title="0">{
                encoderConfig.MessageKey = a.config.Logs.ZapMessageKey
        }</span>
        <span class="cov0" title="0">if a.config.Logs.ZapStacktraceKey != "" </span><span class="cov0" title="0">{
                encoderConfig.StacktraceKey = a.config.Logs.ZapStacktraceKey
        }</span>

        // 设置时间编码
        <span class="cov0" title="0">encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder

        var encoder zapcore.Encoder
        encoding := a.config.Logs.ZapEncoding
        if encoding == "" </span><span class="cov0" title="0">{
                encoding = a.config.Logs.Format
        }</span>

        <span class="cov0" title="0">switch encoding </span>{
        case "json":<span class="cov0" title="0">
                encoder = zapcore.NewJSONEncoder(encoderConfig)</span>
        case "console":<span class="cov0" title="0">
                encoder = zapcore.NewConsoleEncoder(encoderConfig)</span>
        default:<span class="cov0" title="0">
                // 默认使用JSON格式
                encoder = zapcore.NewJSONEncoder(encoderConfig)</span>
        }

        // 配置输出
        <span class="cov0" title="0">var writeSyncer zapcore.WriteSyncer
        switch output </span>{
        case "stdout":<span class="cov0" title="0">
                writeSyncer = zapcore.AddSync(os.Stdout)</span>
        case "file":<span class="cov0" title="0">
                if writer != nil </span><span class="cov0" title="0">{
                        writeSyncer = zapcore.AddSync(writer)
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("file writer not available")
                }</span>
        case "both":<span class="cov0" title="0">
                if writer != nil </span><span class="cov0" title="0">{
                        // 同时输出到控制台和文件
                        writeSyncer = zapcore.NewMultiWriteSyncer(
                                zapcore.AddSync(os.Stdout),
                                zapcore.AddSync(writer),
                        )
                }</span> else<span class="cov0" title="0"> {
                        // 如果文件writer不可用，只输出到控制台
                        writeSyncer = zapcore.AddSync(os.Stdout)
                }</span>
        default:<span class="cov0" title="0">
                // 默认输出到控制台
                writeSyncer = zapcore.AddSync(os.Stdout)</span>
        }

        // 配置日志级别
        <span class="cov0" title="0">level := a.convertToZapLevel(a.config.Logs.Level)

        return zapcore.NewCore(encoder, writeSyncer, level), nil</span>
}

// convertToZapLevel 转换日志级别到zap级别
func (a *KratosLoggerAdapter) convertToZapLevel(level string) zap.AtomicLevel <span class="cov0" title="0">{
        switch strings.ToLower(level) </span>{
        case "debug":<span class="cov0" title="0">
                return zap.NewAtomicLevelAt(zap.DebugLevel)</span>
        case "info":<span class="cov0" title="0">
                return zap.NewAtomicLevelAt(zap.InfoLevel)</span>
        case "warn", "warning":<span class="cov0" title="0">
                return zap.NewAtomicLevelAt(zap.WarnLevel)</span>
        case "error":<span class="cov0" title="0">
                return zap.NewAtomicLevelAt(zap.ErrorLevel)</span>
        case "fatal":<span class="cov0" title="0">
                return zap.NewAtomicLevelAt(zap.FatalLevel)</span>
        default:<span class="cov0" title="0">
                return zap.NewAtomicLevelAt(zap.InfoLevel)</span>
        }
}

// Log 实现Kratos Logger接口
func (a *KratosLoggerAdapter) Log(level log.Level, keyvals ...any) error <span class="cov0" title="0">{
        // 检查日志级别过滤
        if a.config != nil &amp;&amp; a.config.Logs.Enabled </span><span class="cov0" title="0">{
                configLevel := strings.ToLower(a.config.Logs.Level)
                if !a.shouldLog(level, configLevel) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // 转换日志级别
        <span class="cov0" title="0">severity := convertLevel(level)

        // 构建消息和属性
        message := ""
        attrs := make([]otellog.KeyValue, 0, len(keyvals)/2)
        zapFields := make([]zap.Field, 0, len(keyvals)/2)

        for i := 0; i &lt; len(keyvals); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(keyvals) </span><span class="cov0" title="0">{
                        key, ok := keyvals[i].(string)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">value := keyvals[i+1]

                        // 第一个字符串作为消息
                        if message == "" </span><span class="cov0" title="0">{
                                if msg, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        message = msg
                                        continue</span>
                                }
                        }

                        // 其他作为属性
                        <span class="cov0" title="0">attr := convertToKeyValue(key, value)
                        attrs = append(attrs, attr)

                        // 为zap准备字段
                        zapField := convertToZapField(key, value)
                        zapFields = append(zapFields, zapField)</span>
                }
        }

        // 如果没有消息，使用默认消息
        <span class="cov0" title="0">if message == "" </span><span class="cov0" title="0">{
                message = "log message"
        }</span>

        // 推送日志到Loki（如果启用）
        <span class="cov0" title="0">if a.lokiExporter != nil </span><span class="cov0" title="0">{
                // 构建标签
                labels := make(map[string]string)
                labels["service"] = "nancalacc"
                labels["level"] = level.String()
                labels["component"] = "otel_logger"

                // 添加调试日志
                fmt.Printf("🚀 准备推送日志到Loki: level=%s, message=%s\n", level.String(), message)

                // 异步推送日志到Loki
                go func() </span><span class="cov0" title="0">{
                        ctx := context.Background()
                        err := a.lokiExporter.PushLog(ctx, level.String(), message, labels)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("❌ Loki推送失败: %v\n", err)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("✅ Loki推送成功: %s\n", message)
                        }</span>
                }()
        }

        // 优先使用zap logger（如果可用）
        <span class="cov0" title="0">if a.zapLogger != nil </span><span class="cov0" title="0">{
                a.logWithZap(level, message, zapFields)
        }</span> else<span class="cov0" title="0"> {
                // 回退到原有实现
                a.logWithOtel(severity, message, attrs)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// shouldLog 检查是否应该记录该级别的日志
func (a *KratosLoggerAdapter) shouldLog(level log.Level, configLevel string) bool <span class="cov0" title="0">{
        // 定义日志级别优先级
        levelPriority := map[log.Level]int{
                log.LevelDebug: 0,
                log.LevelInfo:  1,
                log.LevelWarn:  2,
                log.LevelError: 3,
                log.LevelFatal: 4,
        }

        configPriority := map[string]int{
                "debug": 0,
                "info":  1,
                "warn":  2,
                "error": 3,
                "fatal": 4,
        }

        levelPrio, levelExists := levelPriority[level]
        configPrio, configExists := configPriority[configLevel]

        if !levelExists || !configExists </span><span class="cov0" title="0">{
                return true // 如果级别未知，默认记录
        }</span>

        <span class="cov0" title="0">return levelPrio &gt;= configPrio</span>
}

// writeToFile 将日志写入文件
func (a *KratosLoggerAdapter) writeToFile(level log.Level, message string, keyvals []any) <span class="cov0" title="0">{
        if a.writer == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // 构建日志行
        <span class="cov0" title="0">logLine := a.formatLogLine(level, message, keyvals)

        // 写入文件（lumberjack会自动处理轮转）
        a.writer.Write([]byte(logLine + "\n"))</span>
}

// formatLogLine 格式化日志行
func (a *KratosLoggerAdapter) formatLogLine(level log.Level, message string, keyvals []any) string <span class="cov0" title="0">{
        // 检查是否配置为JSON格式
        if a.config != nil &amp;&amp; a.config.Logs.Format == "json" </span><span class="cov0" title="0">{
                return a.formatJSON(level, message, keyvals)
        }</span>

        // 默认使用文本格式
        <span class="cov0" title="0">return a.formatText(level, message, keyvals)</span>
}

// formatText 格式化文本日志
func (a *KratosLoggerAdapter) formatText(level log.Level, message string, keyvals []any) string <span class="cov0" title="0">{
        // 简单的文本格式
        levelStr := strings.ToUpper(level.String())

        // 构建键值对字符串
        var kvPairs []string
        for i := 0; i &lt; len(keyvals); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(keyvals) </span><span class="cov0" title="0">{
                        key, ok := keyvals[i].(string)
                        if ok </span><span class="cov0" title="0">{
                                value := keyvals[i+1]
                                kvPairs = append(kvPairs, fmt.Sprintf("%s=%v", key, value))
                        }</span>
                }
        }

        <span class="cov0" title="0">kvStr := ""
        if len(kvPairs) &gt; 0 </span><span class="cov0" title="0">{
                kvStr = " " + strings.Join(kvPairs, " ")
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("[%s] %s%s", levelStr, message, kvStr)</span>
}

// formatJSON 格式化JSON日志
func (a *KratosLoggerAdapter) formatJSON(level log.Level, message string, keyvals []any) string <span class="cov0" title="0">{
        // 构建JSON对象
        logEntry := map[string]interface{}{
                "level":   strings.ToUpper(level.String()),
                "message": message,
                "time":    time.Now().Format(time.RFC3339),
        }

        // 添加键值对
        for i := 0; i &lt; len(keyvals); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(keyvals) </span><span class="cov0" title="0">{
                        key, ok := keyvals[i].(string)
                        if ok </span><span class="cov0" title="0">{
                                value := keyvals[i+1]
                                logEntry[key] = value
                        }</span>
                }
        }

        // 序列化为JSON
        <span class="cov0" title="0">jsonBytes, err := json.Marshal(logEntry)
        if err != nil </span><span class="cov0" title="0">{
                // 如果JSON序列化失败，回退到文本格式
                return a.formatText(level, message, keyvals)
        }</span>

        <span class="cov0" title="0">return string(jsonBytes)</span>
}

// convertLevel 转换Kratos日志级别到OpenTelemetry级别
func convertLevel(level log.Level) otellog.Severity <span class="cov0" title="0">{
        switch level </span>{
        case log.LevelDebug:<span class="cov0" title="0">
                return otellog.SeverityDebug</span>
        case log.LevelInfo:<span class="cov0" title="0">
                return otellog.SeverityInfo</span>
        case log.LevelWarn:<span class="cov0" title="0">
                return otellog.SeverityWarn</span>
        case log.LevelError:<span class="cov0" title="0">
                return otellog.SeverityError</span>
        case log.LevelFatal:<span class="cov0" title="0">
                return otellog.SeverityFatal</span>
        default:<span class="cov0" title="0">
                return otellog.SeverityInfo</span>
        }
}

// convertToKeyValue 转换值到OpenTelemetry KeyValue
func convertToKeyValue(key string, value any) otellog.KeyValue <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return otellog.String(key, v)</span>
        case int:<span class="cov0" title="0">
                return otellog.Int(key, v)</span>
        case int64:<span class="cov0" title="0">
                return otellog.Int64(key, v)</span>
        case float64:<span class="cov0" title="0">
                return otellog.Float64(key, v)</span>
        case bool:<span class="cov0" title="0">
                return otellog.Bool(key, v)</span>
        default:<span class="cov0" title="0">
                return otellog.String(key, toString(v))</span>
        }
}

// toString 将任意值转换为字符串
func toString(v any) string <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return "&lt;nil&gt;"
        }</span>
        <span class="cov0" title="0">return string(toStringBytes(v))</span>
}

// toStringBytes 将任意值转换为字节数组
func toStringBytes(v any) []byte <span class="cov0" title="0">{
        switch val := v.(type) </span>{
        case string:<span class="cov0" title="0">
                return []byte(val)</span>
        case []byte:<span class="cov0" title="0">
                return val</span>
        case error:<span class="cov0" title="0">
                return []byte(val.Error())</span>
        default:<span class="cov0" title="0">
                // 对于其他类型，使用默认的字符串表示
                return []byte("unknown type")</span>
        }
}

// Close 关闭日志文件
func (a *KratosLoggerAdapter) Close() error <span class="cov0" title="0">{
        if a.writer != nil </span><span class="cov0" title="0">{
                return a.writer.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// writeToStdout 将日志输出到控制台
func (a *KratosLoggerAdapter) writeToStdout(level log.Level, message string, keyvals []any) <span class="cov0" title="0">{
        // 构建日志行
        logLine := a.formatLogLine(level, message, keyvals)

        // 输出到标准输出
        fmt.Println(logLine)
}</span>

// convertToZapField 转换值到zap Field
func convertToZapField(key string, value any) zap.Field <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return zap.String(key, v)</span>
        case int:<span class="cov0" title="0">
                return zap.Int(key, v)</span>
        case int64:<span class="cov0" title="0">
                return zap.Int64(key, v)</span>
        case float64:<span class="cov0" title="0">
                return zap.Float64(key, v)</span>
        case bool:<span class="cov0" title="0">
                return zap.Bool(key, v)</span>
        case error:<span class="cov0" title="0">
                return zap.Error(v)</span>
        case []interface{}:<span class="cov0" title="0">
                // 对于接口切片，尝试转换为JSON字符串
                if jsonBytes, err := json.Marshal(v); err == nil </span><span class="cov0" title="0">{
                        return zap.String(key, string(jsonBytes))
                }</span>
                <span class="cov0" title="0">return zap.Any(key, v)</span>
        case map[string]interface{}:<span class="cov0" title="0">
                // 对于map，尝试转换为JSON字符串
                if jsonBytes, err := json.Marshal(v); err == nil </span><span class="cov0" title="0">{
                        return zap.String(key, string(jsonBytes))
                }</span>
                <span class="cov0" title="0">return zap.Any(key, v)</span>
        default:<span class="cov0" title="0">
                // 对于其他复杂类型，尝试JSON序列化
                // 这包括结构体、结构体指针、结构体切片等
                if jsonBytes, err := json.Marshal(v); err == nil </span><span class="cov0" title="0">{
                        return zap.String(key, string(jsonBytes))
                }</span>
                // 如果JSON序列化失败，回退到Any
                <span class="cov0" title="0">return zap.Any(key, v)</span>
        }
}

// logWithZap 使用zap记录日志
func (a *KratosLoggerAdapter) logWithZap(level log.Level, message string, fields []zap.Field) <span class="cov0" title="0">{
        switch level </span>{
        case log.LevelDebug:<span class="cov0" title="0">
                a.zapLogger.Debug(message, fields...)</span>
        case log.LevelInfo:<span class="cov0" title="0">
                a.zapLogger.Info(message, fields...)</span>
        case log.LevelWarn:<span class="cov0" title="0">
                a.zapLogger.Warn(message, fields...)</span>
        case log.LevelError:<span class="cov0" title="0">
                a.zapLogger.Error(message, fields...)</span>
        case log.LevelFatal:<span class="cov0" title="0">
                a.zapLogger.Fatal(message, fields...)</span>
        default:<span class="cov0" title="0">
                a.zapLogger.Info(message, fields...)</span>
        }
}

// logWithOtel 使用OpenTelemetry记录日志
func (a *KratosLoggerAdapter) logWithOtel(severity otellog.Severity, message string, attrs []otellog.KeyValue) <span class="cov0" title="0">{
        // 创建日志记录
        record := otellog.Record{}
        record.SetSeverity(severity)
        record.SetBody(otellog.StringValue(message))
        for _, attr := range attrs </span><span class="cov0" title="0">{
                record.AddAttributes(attr)
        }</span>

        // 记录日志到OpenTelemetry
        <span class="cov0" title="0">a.otellogger.Emit(context.Background(), record)

        // 如果配置了stdout输出，输出到控制台
        if a.config != nil &amp;&amp; a.config.Logs.Output == "stdout" </span><span class="cov0" title="0">{
                a.writeToStdout(convertOtelLevelToKratos(severity), message, nil)
        }</span>

        // 如果配置了文件输出，同时写入文件
        <span class="cov0" title="0">if a.writer != nil </span><span class="cov0" title="0">{
                a.writeToFile(convertOtelLevelToKratos(severity), message, nil)
        }</span>
}

// convertOtelLevelToKratos 转换OpenTelemetry级别到Kratos级别
func convertOtelLevelToKratos(severity otellog.Severity) log.Level <span class="cov0" title="0">{
        switch severity </span>{
        case otellog.SeverityDebug:<span class="cov0" title="0">
                return log.LevelDebug</span>
        case otellog.SeverityInfo:<span class="cov0" title="0">
                return log.LevelInfo</span>
        case otellog.SeverityWarn:<span class="cov0" title="0">
                return log.LevelWarn</span>
        case otellog.SeverityError:<span class="cov0" title="0">
                return log.LevelError</span>
        case otellog.SeverityFatal:<span class="cov0" title="0">
                return log.LevelFatal</span>
        default:<span class="cov0" title="0">
                return log.LevelInfo</span>
        }
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package otel

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/go-kratos/kratos/v2/log"
)

// LokiExporter Loki日志导出器
type LokiExporter struct {
        endpoint string
        client   *http.Client
        logger   *log.Helper
}

// LokiPushRequest Loki推送请求格式
type LokiPushRequest struct {
        Streams []LokiStream `json:"streams"`
}

type LokiStream struct {
        Stream map[string]string `json:"stream"`
        Values [][]string        `json:"values"`
}

// NewLokiExporter 创建Loki导出器
func NewLokiExporter(endpoint string, logger log.Logger) *LokiExporter <span class="cov0" title="0">{
        return &amp;LokiExporter{
                endpoint: endpoint,
                client: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
                logger: log.NewHelper(log.With(logger, "module", "loki_exporter")),
        }
}</span>

// PushLog 推送日志到Loki
func (e *LokiExporter) PushLog(ctx context.Context, level, message string, labels map[string]string) error <span class="cov0" title="0">{
        // 构建Loki推送请求
        now := time.Now().UnixNano()

        // 确保基础标签存在
        if labels == nil </span><span class="cov0" title="0">{
                labels = make(map[string]string)
        }</span>
        <span class="cov0" title="0">labels["service"] = "nancalacc"
        labels["level"] = level

        // 构建日志内容
        logContent := map[string]interface{}{
                "level":     level,
                "msg":       message,
                "service":   "nancalacc",
                "timestamp": time.Now().Format(time.RFC3339),
        }

        logJSON, err := json.Marshal(logContent)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("序列化日志失败: %w", err)
        }</span>

        <span class="cov0" title="0">request := LokiPushRequest{
                Streams: []LokiStream{
                        {
                                Stream: labels,
                                Values: [][]string{
                                        {
                                                fmt.Sprintf("%d", now),
                                                string(logJSON),
                                        },
                                },
                        },
                },
        }

        // 序列化请求
        jsonData, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("序列化请求失败: %w", err)
        }</span>

        // 发送HTTP请求
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", e.endpoint, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("创建请求失败: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := e.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("HTTP请求失败: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // 读取响应
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("读取响应失败: %w", err)
        }</span>

        // 检查响应状态
        <span class="cov0" title="0">if resp.StatusCode != 200 &amp;&amp; resp.StatusCode != 204 </span><span class="cov0" title="0">{
                return fmt.Errorf("Loki推送失败，状态码: %d, 响应: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">e.logger.WithContext(ctx).Debugf("Loki推送成功: %s", string(body))
        return nil</span>
}

// BatchPushLog 批量推送日志
func (e *LokiExporter) BatchPushLog(ctx context.Context, logs []LogEntry) error <span class="cov0" title="0">{
        if len(logs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 按标签分组日志
        <span class="cov0" title="0">streams := make(map[string]*LokiStream)

        for _, logEntry := range logs </span><span class="cov0" title="0">{
                // 生成流标识符
                streamKey := fmt.Sprintf("%s_%s", logEntry.Level, logEntry.Service)

                stream, exists := streams[streamKey]
                if !exists </span><span class="cov0" title="0">{
                        stream = &amp;LokiStream{
                                Stream: map[string]string{
                                        "service": logEntry.Service,
                                        "level":   logEntry.Level,
                                },
                                Values: make([][]string, 0),
                        }
                        streams[streamKey] = stream
                }</span>

                // 添加自定义标签
                <span class="cov0" title="0">for k, v := range logEntry.Labels </span><span class="cov0" title="0">{
                        stream.Stream[k] = v
                }</span>

                // 构建日志内容
                <span class="cov0" title="0">logContent := map[string]interface{}{
                        "level":     logEntry.Level,
                        "msg":       logEntry.Message,
                        "service":   logEntry.Service,
                        "timestamp": logEntry.Timestamp.Format(time.RFC3339),
                }

                logJSON, err := json.Marshal(logContent)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("序列化日志失败: %w", err)
                }</span>

                <span class="cov0" title="0">stream.Values = append(stream.Values, []string{
                        fmt.Sprintf("%d", logEntry.Timestamp.UnixNano()),
                        string(logJSON),
                })</span>
        }

        // 构建请求
        <span class="cov0" title="0">request := LokiPushRequest{
                Streams: make([]LokiStream, 0, len(streams)),
        }

        for _, stream := range streams </span><span class="cov0" title="0">{
                request.Streams = append(request.Streams, *stream)
        }</span>

        // 序列化请求
        <span class="cov0" title="0">jsonData, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("序列化请求失败: %w", err)
        }</span>

        // 发送HTTP请求
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", e.endpoint, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("创建请求失败: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := e.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("HTTP请求失败: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // 读取响应
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("读取响应失败: %w", err)
        }</span>

        // 检查响应状态
        <span class="cov0" title="0">if resp.StatusCode != 200 &amp;&amp; resp.StatusCode != 204 </span><span class="cov0" title="0">{
                return fmt.Errorf("Loki批量推送失败，状态码: %d, 响应: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">e.logger.WithContext(ctx).Debugf("Loki批量推送成功，推送了 %d 条日志", len(logs))
        return nil</span>
}

// LogEntry 日志条目
type LogEntry struct {
        Level     string
        Message   string
        Service   string
        Timestamp time.Time
        Labels    map[string]string
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package otel

import (
        "context"
        "net/http"
        "time"

        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/log"
        "go.opentelemetry.io/otel/metric"
        "go.opentelemetry.io/otel/trace"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// HTTPMiddleware HTTP 中间件
type HTTPMiddleware struct {
        tracer trace.Tracer
        meter  metric.Meter
        logger log.Logger
}

// NewHTTPMiddleware 创建 HTTP 中间件
func NewHTTPMiddleware(tracer trace.Tracer, meter metric.Meter, logger log.Logger) *HTTPMiddleware <span class="cov0" title="0">{
        return &amp;HTTPMiddleware{
                tracer: tracer,
                meter:  meter,
                logger: logger,
        }
}</span>

// Wrap 包装 HTTP 处理器
func (m *HTTPMiddleware) Wrap(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                // 创建 span
                ctx, span := m.tracer.Start(r.Context(), "HTTP "+r.Method+" "+r.URL.Path)
                defer span.End()

                // 设置 span 属性
                span.SetAttributes(
                        attribute.String("http.method", r.Method),
                        attribute.String("http.url", r.URL.String()),
                        attribute.String("http.user_agent", r.UserAgent()),
                        attribute.String("http.remote_addr", r.RemoteAddr),
                )

                // 包装响应写入器以获取状态码
                wrappedWriter := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

                // 执行处理器
                next.ServeHTTP(wrappedWriter, r.WithContext(ctx))

                // 记录响应信息
                duration := time.Since(start)
                span.SetAttributes(
                        attribute.Int("http.status_code", wrappedWriter.statusCode),
                        attribute.String("http.duration", duration.String()),
                )

                // 记录指标
                if m.meter != nil </span><span class="cov0" title="0">{
                        if counter, _ := m.meter.Int64Counter("http_requests_total"); counter != nil </span><span class="cov0" title="0">{
                                counter.Add(ctx, 1,
                                        metric.WithAttributes(attribute.String("method", r.Method)),
                                        metric.WithAttributes(attribute.String("path", r.URL.Path)),
                                        metric.WithAttributes(attribute.Int("status_code", wrappedWriter.statusCode)),
                                )
                        }</span>

                        <span class="cov0" title="0">if histogram, _ := m.meter.Float64Histogram("http_request_duration_seconds"); histogram != nil </span><span class="cov0" title="0">{
                                histogram.Record(ctx, duration.Seconds(),
                                        metric.WithAttributes(attribute.String("method", r.Method)),
                                        metric.WithAttributes(attribute.String("path", r.URL.Path)),
                                )
                        }</span>
                }

                // 记录请求日志
                <span class="cov0" title="0">if m.logger != nil </span><span class="cov0" title="0">{
                        record := log.Record{}
                        record.SetTimestamp(time.Now())
                        record.SetSeverity(log.SeverityInfo)
                        record.SetBody(log.StringValue("HTTP Request"))
                        record.AddAttributes(
                                log.String("method", r.Method),
                                log.String("url", r.URL.String()),
                                log.String("user_agent", r.UserAgent()),
                                log.String("remote_addr", r.RemoteAddr),
                        )
                        m.logger.Emit(ctx, record)
                }</span>
        })
}

// responseWriter 包装的响应写入器
type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (w *responseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        w.statusCode = statusCode
        w.ResponseWriter.WriteHeader(statusCode)
}</span>

// GRPCUnaryInterceptor gRPC 一元拦截器
func GRPCUnaryInterceptor(tracer trace.Tracer, meter metric.Meter, logger log.Logger) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                start := time.Now()

                // 创建 span
                ctx, span := tracer.Start(ctx, "gRPC "+info.FullMethod)
                defer span.End()

                // 设置 span 属性
                span.SetAttributes(
                        attribute.String("grpc.method", info.FullMethod),
                )

                // 执行处理器
                resp, err := handler(ctx, req)

                // 记录响应信息
                duration := time.Since(start)
                span.SetAttributes(attribute.String("grpc.duration", duration.String()))

                // 处理错误
                if err != nil </span><span class="cov0" title="0">{
                        st, _ := status.FromError(err)
                        span.SetAttributes(
                                attribute.String("grpc.status_code", st.Code().String()),
                                attribute.String("grpc.error_message", err.Error()),
                        )
                        span.RecordError(err)
                }</span> else<span class="cov0" title="0"> {
                        span.SetAttributes(attribute.String("grpc.status_code", codes.OK.String()))
                }</span>

                // 记录指标
                <span class="cov0" title="0">if meter != nil </span><span class="cov0" title="0">{
                        if counter, _ := meter.Int64Counter("grpc_requests_total"); counter != nil </span><span class="cov0" title="0">{
                                counter.Add(ctx, 1,
                                        metric.WithAttributes(attribute.String("method", info.FullMethod)),
                                        metric.WithAttributes(attribute.String("status_code", getGRPCStatusCode(err))),
                                )
                        }</span>

                        <span class="cov0" title="0">if histogram, _ := meter.Float64Histogram("grpc_request_duration_seconds"); histogram != nil </span><span class="cov0" title="0">{
                                histogram.Record(ctx, duration.Seconds(),
                                        metric.WithAttributes(attribute.String("method", info.FullMethod)),
                                )
                        }</span>
                }

                // 记录日志
                <span class="cov0" title="0">if logger != nil </span><span class="cov0" title="0">{
                        level := log.SeverityInfo
                        if err != nil </span><span class="cov0" title="0">{
                                level = log.SeverityError
                        }</span>

                        <span class="cov0" title="0">record := log.Record{}
                        record.SetTimestamp(time.Now())
                        record.SetSeverity(level)
                        record.SetBody(log.StringValue("gRPC " + info.FullMethod + " " + getGRPCStatusCode(err)))
                        record.AddAttributes(
                                log.String("grpc.method", info.FullMethod),
                                log.String("grpc.status_code", getGRPCStatusCode(err)),
                                log.String("grpc.duration", duration.String()),
                        )
                        logger.Emit(ctx, record)</span>
                }

                <span class="cov0" title="0">return resp, err</span>
        }
}

// getGRPCStatusCode 获取 gRPC 状态码
func getGRPCStatusCode(err error) string <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return codes.OK.String()
        }</span>

        <span class="cov0" title="0">if st, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                return st.Code().String()
        }</span>

        <span class="cov0" title="0">return codes.Unknown.String()</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package otel

import (
        "context"
        "time"

        "go.opentelemetry.io/otel/log"
        "go.opentelemetry.io/otel/metric"
        "go.opentelemetry.io/otel/trace"
)

// Service OpenTelemetry 服务
type Service struct {
        tracer trace.Tracer
        meter  metric.Meter
        logger log.Logger
}

// NewService 创建 OpenTelemetry 服务
func NewService(tracer trace.Tracer, meter metric.Meter, logger log.Logger) *Service <span class="cov0" title="0">{
        return &amp;Service{
                tracer: tracer,
                meter:  meter,
                logger: logger,
        }
}</span>

// Tracer 获取追踪器
func (s *Service) Tracer() trace.Tracer <span class="cov0" title="0">{
        return s.tracer
}</span>

// Meter 获取指标器
func (s *Service) Meter() metric.Meter <span class="cov0" title="0">{
        return s.meter
}</span>

// Logger 获取日志器
func (s *Service) Logger() log.Logger <span class="cov0" title="0">{
        return s.logger
}</span>

// Log 记录日志
func (s *Service) Log(ctx context.Context, level log.Severity, message string, attrs ...log.KeyValue) <span class="cov0" title="0">{
        if s.logger != nil </span><span class="cov0" title="0">{
                record := log.Record{}
                record.SetTimestamp(time.Now())
                record.SetSeverity(level)
                record.SetBody(log.StringValue(message))
                for _, attr := range attrs </span><span class="cov0" title="0">{
                        record.AddAttributes(attr)
                }</span>
                <span class="cov0" title="0">s.logger.Emit(ctx, record)</span>
        }
}

// LogInfo 记录信息日志
func (s *Service) LogInfo(ctx context.Context, message string, attrs ...log.KeyValue) <span class="cov0" title="0">{
        s.Log(ctx, log.SeverityInfo, message, attrs...)
}</span>

// LogError 记录错误日志
func (s *Service) LogError(ctx context.Context, message string, attrs ...log.KeyValue) <span class="cov0" title="0">{
        s.Log(ctx, log.SeverityError, message, attrs...)
}</span>

// LogWarn 记录警告日志
func (s *Service) LogWarn(ctx context.Context, message string, attrs ...log.KeyValue) <span class="cov0" title="0">{
        s.Log(ctx, log.SeverityWarn, message, attrs...)
}</span>

// LogDebug 记录调试日志
func (s *Service) LogDebug(ctx context.Context, message string, attrs ...log.KeyValue) <span class="cov0" title="0">{
        s.Log(ctx, log.SeverityDebug, message, attrs...)
}</span>

// Init 初始化服务
func (s *Service) Init(ctx context.Context) error <span class="cov0" title="0">{
        // 初始化 OpenTelemetry 服务
        return nil
}</span>

// Shutdown 关闭服务
func (s *Service) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        // 关闭 OpenTelemetry 服务
        return nil
}</span>

// GetTracer 获取追踪器
func (s *Service) GetTracer() trace.Tracer <span class="cov0" title="0">{
        if s.tracer != nil </span><span class="cov0" title="0">{
                return s.tracer
        }</span>
        <span class="cov0" title="0">return trace.NewNoopTracerProvider().Tracer("nancalacc")</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package cache

import (
        "context"
        "time"

        "github.com/go-redis/redis/v8"
)

type RedisCache struct {
        client *redis.Client
}

func NewRedisCache(client *redis.Client) *RedisCache <span class="cov0" title="0">{
        return &amp;RedisCache{client: client}
}</span>

func (r *RedisCache) Get(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        return r.client.Get(ctx, key).Result()
}</span>

func (r *RedisCache) Set(ctx context.Context, key string, value string, ttl time.Duration) error <span class="cov0" title="0">{
        return r.client.Set(ctx, key, value, ttl).Err()
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package cipherutil

import (
        "bytes"
        "crypto/aes"
        "crypto/cipher"
        "crypto/md5"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "encoding/hex"
        "errors"
        "fmt"
        "nancalacc/internal/conf"
)

var (
        ErrEmptyPlaintext          = errors.New("empty plaintext")
        ErrInvalidPadding          = errors.New("invalid padding")
        ErrInvalidPaddingBlockSize = errors.New("invalid padding block size")
        ErrInvalidKey              = errors.New("invalid key")
        ErrIVGeneration            = errors.New("failed to generate initialization vector")
        ErrDecryptFailed           = errors.New("decrypt failed")
        ErrMD5WriteFailed          = errors.New("md5 write failed")
        ErrInvalidInput            = errors.New("invalid input")
        ErrAesCipher               = errors.New("aes cipher creation failed")

        ErrNonceGeneration   = errors.New("failed to generate nonce")
        ErrCipherCreation    = errors.New("failed to create AES cipher")
        ErrGCMCreation       = errors.New("failed to create GCM instance")
        ErrInvalidCiphertext = errors.New("ciphertext too short or invalid")
        ErrDecryptionFailed  = errors.New("decryption failed")
)

// GetAppUID 获取应用UID，优先从环境变量获取，否则使用默认值
func GetAppUID() string <span class="cov0" title="0">{
        uid := conf.GetEnvWithDefault("APP_UID", "nancalacc-426614174000")
        return uid
}</span>

func DecryptByAes(content string, key string) (string, error) <span class="cov0" title="0">{

        if len(content) &lt; 24 </span><span class="cov0" title="0">{
                return "", ErrEmptyPlaintext
        }</span>
        <span class="cov0" title="0">if len(key) == 0 </span><span class="cov0" title="0">{
                return "", ErrInvalidKey
        }</span>
        <span class="cov0" title="0">h := md5.New()
        if _, err := h.Write([]byte(key)); err != nil </span><span class="cov0" title="0">{
                return "", ErrMD5WriteFailed
        }</span>
        <span class="cov0" title="0">akey := hex.EncodeToString(h.Sum(nil))
        enDataFromBase64, err := base64.StdEncoding.DecodeString(content)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if len(enDataFromBase64) == 0 || len(enDataFromBase64)%aes.BlockSize != 0 </span><span class="cov0" title="0">{
                return "", ErrInvalidInput
        }</span>

        <span class="cov0" title="0">block, err := aes.NewCipher([]byte(akey))
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrAesCipher
        }</span>
        <span class="cov0" title="0">iv := []byte(akey)[:aes.BlockSize]
        decrypter := cipher.NewCBCDecrypter(block, iv)
        dst := make([]byte, len(enDataFromBase64))
        decrypter.CryptBlocks(dst, enDataFromBase64)
        length := len(dst)
        unpadding := int(dst[length-1])
        if length &lt; unpadding </span><span class="cov0" title="0">{
                return "", ErrInvalidPadding
        }</span>
        <span class="cov0" title="0">res := string(dst[:(length - unpadding)])
        return res, nil</span>
}

func EncryptByAes(content string, key string) (string, error) <span class="cov0" title="0">{

        if len(content) == 0 </span><span class="cov0" title="0">{
                return "", ErrEmptyPlaintext
        }</span>
        <span class="cov0" title="0">if len(key) == 0 </span><span class="cov0" title="0">{
                return "", ErrInvalidKey
        }</span>

        <span class="cov0" title="0">h := md5.New()
        if _, err := h.Write([]byte(key)); err != nil </span><span class="cov0" title="0">{
                return "", ErrMD5WriteFailed
        }</span>
        <span class="cov0" title="0">akey := hex.EncodeToString(h.Sum(nil))

        block, err := aes.NewCipher([]byte(akey))
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrAesCipher
        }</span>

        <span class="cov0" title="0">iv := []byte(akey)[:aes.BlockSize]

        plaintext := []byte(content)
        padding := aes.BlockSize - len(plaintext)%aes.BlockSize
        padtext := append(plaintext, bytes.Repeat([]byte{byte(padding)}, padding)...)

        ciphertext := make([]byte, len(padtext))
        encrypter := cipher.NewCBCEncrypter(block, iv)
        encrypter.CryptBlocks(ciphertext, padtext)

        return base64.StdEncoding.EncodeToString(ciphertext), nil</span>
}

func Encrypt(plaintext string, key []byte) (string, error) <span class="cov0" title="0">{
        if len(key) != 32 </span><span class="cov0" title="0">{
                return "", ErrInvalidKey
        }</span>
        <span class="cov0" title="0">if plaintext == "" </span><span class="cov0" title="0">{
                return "", ErrEmptyPlaintext
        }</span>

        <span class="cov0" title="0">nonce := make([]byte, 12)
        if _, err := rand.Read(nonce); err != nil </span><span class="cov0" title="0">{
                return "", ErrNonceGeneration
        }</span>

        <span class="cov0" title="0">block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrCipherCreation
        }</span>

        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrGCMCreation
        }</span>

        <span class="cov0" title="0">ciphertext := gcm.Seal(nil, nonce, []byte(plaintext), nil)
        encrypted := append(nonce, ciphertext...)
        return base64.StdEncoding.EncodeToString(encrypted), nil</span>
}

func Decrypt(ciphertext string, key []byte) (string, error) <span class="cov0" title="0">{
        if len(key) != 32 </span><span class="cov0" title="0">{
                return "", ErrInvalidKey
        }</span>

        <span class="cov0" title="0">encryptedData, err := base64.StdEncoding.DecodeString(ciphertext)
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrInvalidCiphertext
        }</span>

        <span class="cov0" title="0">if len(encryptedData) &lt; 12 </span><span class="cov0" title="0">{
                return "", ErrInvalidCiphertext
        }</span>

        <span class="cov0" title="0">nonce := encryptedData[:12]
        data := encryptedData[12:]

        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrCipherCreation
        }</span>

        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrGCMCreation
        }</span>

        <span class="cov0" title="0">plaintext, err := gcm.Open(nil, nonce, data, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrDecryptionFailed
        }</span>

        <span class="cov0" title="0">return string(plaintext), nil</span>
}

func GenerateKey(uid, salt string) string <span class="cov0" title="0">{
        h := sha256.New()
        h.Write([]byte(uid + salt))
        hash := hex.EncodeToString(h.Sum(nil))
        return hash[:32]
}</span>

func EncryptUserInfo(plaintext string, uid string) (string, error) <span class="cov0" title="0">{
        if plaintext == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">salt, err := conf.GetEnv("salt")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get encryption salt: %w", err)
        }</span>

        <span class="cov0" title="0">uidSaltKey := GenerateKey(uid, salt)
        if len(uidSaltKey) != 32 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("generated key must be 32 bytes, got %d", len(uidSaltKey))
        }</span>

        <span class="cov0" title="0">encrypted, err := Encrypt(plaintext, []byte(uidSaltKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("encryption failed: %w", err)
        }</span>
        <span class="cov0" title="0">return encrypted, nil</span>
}

func DecryptUserInfo(ciphertext string, uid string) (string, error) <span class="cov0" title="0">{
        if ciphertext == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">salt, err := conf.GetEnv("salt")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get encryption salt: %w", err)
        }</span>

        <span class="cov0" title="0">uidSaltKey := GenerateKey(uid, salt)
        if len(uidSaltKey) != 32 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("generated key must be 32 bytes, got %d", len(uidSaltKey))
        }</span>

        <span class="cov0" title="0">decrypted, err := Decrypt(ciphertext, []byte(uidSaltKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("decryption failed: %w", err)
        }</span>
        <span class="cov0" title="0">return decrypted, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">// internal/pkg/limiter/example.go
package limiter

import (
        "context"
        "fmt"
        "log"
        "time"
)

// ExampleUsage 展示限流器的使用示例
func ExampleUsage() <span class="cov0" title="0">{
        // 创建自定义配置
        config := &amp;Config{
                CleanupInterval: 5 * time.Minute,  // 5分钟清理一次
                MaxIdleTime:     15 * time.Minute, // 15分钟空闲后清理
                MaxEntries:      1000,             // 最多1000个限流器
                DefaultRate:     5,                // 默认每秒5个请求
                DefaultBurst:    10,               // 默认突发10个请求
        }

        // 创建限流器
        limiter := NewRateLimiter(config)

        // 示例1: 使用 Allow 方法（非阻塞）
        fmt.Println("=== 示例1: 使用 Allow 方法 ===")
        for i := 0; i &lt; 15; i++ </span><span class="cov0" title="0">{
                allowed := limiter.Allow("user:123", 2, 5) // 每秒2个请求，突发5个
                fmt.Printf("请求 %d: %s\n", i+1, map[bool]string{true: "允许", false: "限流"}[allowed])
                time.Sleep(100 * time.Millisecond)
        }</span>

        // 示例2: 使用 Wait 方法（阻塞）
        <span class="cov0" title="0">fmt.Println("\n=== 示例2: 使用 Wait 方法 ===")
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                start := time.Now()
                err := limiter.Wait(ctx, "api:sync", 1, 2) // 每秒1个请求，突发2个
                duration := time.Since(start)

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("请求 %d: 超时或取消\n", i+1)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("请求 %d: 等待 %v 后执行\n", i+1, duration)
                }</span>
        }

        // 示例3: 使用 Reserve 方法
        <span class="cov0" title="0">fmt.Println("\n=== 示例3: 使用 Reserve 方法 ===")
        for i := 0; i &lt; 8; i++ </span><span class="cov0" title="0">{
                reservation := limiter.Reserve("upload:file", 0.5, 3) // 每2秒1个请求，突发3个
                delay := reservation.Delay()

                if delay &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("请求 %d: 需要等待 %v\n", i+1, delay)
                        time.Sleep(delay)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("请求 %d: 立即执行\n", i+1)
                }</span>

                <span class="cov0" title="0">reservation.CancelAt(time.Now())</span> // 取消预留
        }

        // 示例4: 获取统计信息
        <span class="cov0" title="0">fmt.Println("\n=== 示例4: 统计信息 ===")
        stats := limiter.GetStats()
        for key, value := range stats </span><span class="cov0" title="0">{
                fmt.Printf("%s: %v\n", key, value)
        }</span>

        // 示例5: 列出所有限流器
        <span class="cov0" title="0">fmt.Println("\n=== 示例5: 限流器列表 ===")
        keys := limiter.ListKeys()
        fmt.Printf("活跃的限流器: %v\n", keys)

        // 示例6: 获取特定限流器信息
        fmt.Println("\n=== 示例6: 限流器详情 ===")
        if info, exists := limiter.GetEntryInfo("user:123"); exists </span><span class="cov0" title="0">{
                for key, value := range info </span><span class="cov0" title="0">{
                        fmt.Printf("%s: %v\n", key, value)
                }</span>
        }

        // 示例7: 移除限流器
        <span class="cov0" title="0">fmt.Println("\n=== 示例7: 移除限流器 ===")
        removed := limiter.Remove("user:123")
        fmt.Printf("移除 user:123: %s\n", map[bool]string{true: "成功", false: "不存在"}[removed])

        // 示例8: 重置限流器
        fmt.Println("\n=== 示例8: 重置限流器 ===")
        limiter.Reset()
        fmt.Println("限流器已重置")

        // 显示最终统计
        finalStats := limiter.GetStats()
        fmt.Printf("重置后的统计: %v\n", finalStats)</span>
}

// ExampleMiddleware 展示在HTTP中间件中的使用
func ExampleMiddleware() <span class="cov0" title="0">{
        limiter := NewRateLimiter(nil) // 使用默认配置

        // 模拟HTTP请求处理
        handleRequest := func(userID string) </span><span class="cov0" title="0">{
                // 使用用户ID作为限流键
                key := fmt.Sprintf("user:%s", userID)

                // 检查是否允许请求
                if limiter.Allow(key, 10, 20) </span><span class="cov0" title="0">{ // 每秒10个请求，突发20个
                        fmt.Printf("用户 %s 的请求被处理\n", userID)
                        // 处理请求...
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("用户 %s 的请求被限流\n", userID)
                        // 返回429状态码...
                }</span>
        }

        // 模拟多个用户同时请求
        <span class="cov0" title="0">for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                userID := fmt.Sprintf("user%d", i+1)
                for j := 0; j &lt; 15; j++ </span><span class="cov0" title="0">{
                        handleRequest(userID)
                        time.Sleep(50 * time.Millisecond)
                }</span>
        }
}

// ExampleGRPC 展示在gRPC服务中的使用
func ExampleGRPC() <span class="cov0" title="0">{
        limiter := NewRateLimiter(&amp;Config{
                DefaultRate:  100, // 每秒100个请求
                DefaultBurst: 200, // 突发200个请求
                MaxEntries:   5000,
        })

        // 模拟gRPC方法调用
        callGRPCMethod := func(clientIP string, method string) error </span><span class="cov0" title="0">{
                // 使用客户端IP和方法名作为限流键
                key := fmt.Sprintf("%s:%s", clientIP, method)

                ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                defer cancel()

                // 等待直到允许请求
                if err := limiter.Wait(ctx, key, 50, 100); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("rate limit exceeded: %w", err)
                }</span>

                // 执行gRPC方法...
                <span class="cov0" title="0">fmt.Printf("执行 gRPC 方法: %s, 客户端: %s\n", method, clientIP)
                return nil</span>
        }

        // 模拟多个客户端调用
        <span class="cov0" title="0">clients := []string{"192.168.1.1", "192.168.1.2", "192.168.1.3"}
        methods := []string{"CreateAccount", "GetAccount", "UpdateAccount"}

        for _, client := range clients </span><span class="cov0" title="0">{
                for _, method := range methods </span><span class="cov0" title="0">{
                        for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                                if err := callGRPCMethod(client, method); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("调用失败: %v", err)
                                }</span>
                                <span class="cov0" title="0">time.Sleep(10 * time.Millisecond)</span>
                        }
                }
        }
}

// ExampleMonitoring 展示监控和指标收集
func ExampleMonitoring() <span class="cov0" title="0">{
        limiter := NewRateLimiter(nil)

        // 启动监控协程
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(30 * time.Second)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        stats := limiter.GetStats()

                        // 计算限流率
                        total := stats["total_requests"].(int64)
                        limited := stats["limited_requests"].(int64)
                        var rate float64
                        if total &gt; 0 </span><span class="cov0" title="0">{
                                rate = float64(limited) / float64(total) * 100
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("监控报告 - 总请求: %d, 限流请求: %d, 限流率: %.2f%%, 活跃限流器: %d\n",
                                total, limited, rate, stats["active_limiters"])</span>
                }
        }()

        // 模拟负载
        <span class="cov0" title="0">for i := 0; i &lt; 100; i++ </span><span class="cov0" title="0">{
                limiter.Allow("test:key", 5, 10)
                time.Sleep(50 * time.Millisecond)
        }</span>

        <span class="cov0" title="0">time.Sleep(35 * time.Second)</span> // 等待监控报告
}
</pre>
		
		<pre class="file" id="file53" style="display: none">// internal/pkg/limiter/limiter.go
package limiter

import (
        "context"
        "fmt"
        "sync"
        "time"

        "golang.org/x/time/rate"
)

// RateLimiter 限流器
type RateLimiter struct {
        limiters map[string]*limiterEntry
        mu       sync.RWMutex
        config   *Config
        metrics  *Metrics
}

// limiterEntry 限流器条目
type limiterEntry struct {
        limiter    *rate.Limiter
        lastAccess time.Time
        created    time.Time
        key        string
}

// Config 限流器配置
type Config struct {
        CleanupInterval time.Duration // 清理间隔
        MaxIdleTime     time.Duration // 最大空闲时间
        MaxEntries      int           // 最大条目数
        DefaultRate     rate.Limit    // 默认速率
        DefaultBurst    int           // 默认突发量
}

// Metrics 监控指标
type Metrics struct {
        mu sync.RWMutex
        // 总请求数
        TotalRequests int64
        // 被限流的请求数
        LimitedRequests int64
        // 当前活跃的限流器数量
        ActiveLimiters int64
        // 清理的限流器数量
        CleanedLimiters int64
}

// DefaultConfig 默认配置
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                CleanupInterval: 10 * time.Minute,
                MaxIdleTime:     30 * time.Minute,
                MaxEntries:      10000,
                DefaultRate:     10, // 每秒10个请求
                DefaultBurst:    20, // 突发20个请求
        }
}</span>

// NewRateLimiter 创建新的限流器
func NewRateLimiter(config *Config) *RateLimiter <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultConfig()
        }</span>

        // 验证配置参数
        <span class="cov0" title="0">if config.CleanupInterval &lt;= 0 </span><span class="cov0" title="0">{
                config.CleanupInterval = 10 * time.Minute
        }</span>
        <span class="cov0" title="0">if config.MaxIdleTime &lt;= 0 </span><span class="cov0" title="0">{
                config.MaxIdleTime = 30 * time.Minute
        }</span>
        <span class="cov0" title="0">if config.MaxEntries &lt;= 0 </span><span class="cov0" title="0">{
                config.MaxEntries = 10000
        }</span>
        <span class="cov0" title="0">if config.DefaultRate &lt;= 0 </span><span class="cov0" title="0">{
                config.DefaultRate = 10
        }</span>
        <span class="cov0" title="0">if config.DefaultBurst &lt;= 0 </span><span class="cov0" title="0">{
                config.DefaultBurst = 20
        }</span>

        <span class="cov0" title="0">rl := &amp;RateLimiter{
                limiters: make(map[string]*limiterEntry),
                config:   config,
                metrics:  &amp;Metrics{},
        }

        // 启动清理协程
        go rl.startCleanup()

        return rl</span>
}

// GetLimiter 获取或创建限流器
func (rl *RateLimiter) GetLimiter(key string, r rate.Limit, b int) *rate.Limiter <span class="cov0" title="0">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        if entry, exists := rl.limiters[key]; exists </span><span class="cov0" title="0">{
                entry.lastAccess = time.Now()
                return entry.limiter
        }</span>

        // 检查是否超过最大条目数
        <span class="cov0" title="0">if len(rl.limiters) &gt;= rl.config.MaxEntries </span><span class="cov0" title="0">{
                // 清理最旧的条目
                rl.cleanupOldest()
        }</span>

        // 使用默认值如果参数为0
        <span class="cov0" title="0">if r == 0 </span><span class="cov0" title="0">{
                r = rl.config.DefaultRate
        }</span>
        <span class="cov0" title="0">if b == 0 </span><span class="cov0" title="0">{
                b = rl.config.DefaultBurst
        }</span>

        <span class="cov0" title="0">limiter := rate.NewLimiter(r, b)
        entry := &amp;limiterEntry{
                limiter:    limiter,
                lastAccess: time.Now(),
                created:    time.Now(),
                key:        key,
        }

        rl.limiters[key] = entry
        rl.metrics.incrementActiveLimiters()

        return limiter</span>
}

// Allow 检查是否允许请求（非阻塞）
func (rl *RateLimiter) Allow(key string, r rate.Limit, b int) bool <span class="cov0" title="0">{
        limiter := rl.GetLimiter(key, r, b)
        allowed := limiter.Allow()

        rl.metrics.incrementTotalRequests()
        if !allowed </span><span class="cov0" title="0">{
                rl.metrics.incrementLimitedRequests()
        }</span>

        <span class="cov0" title="0">return allowed</span>
}

// Wait 等待直到允许请求（阻塞）
func (rl *RateLimiter) Wait(ctx context.Context, key string, r rate.Limit, b int) error <span class="cov0" title="0">{
        limiter := rl.GetLimiter(key, r, b)
        rl.metrics.incrementTotalRequests()
        return limiter.Wait(ctx)
}</span>

// Reserve 预留一个令牌
func (rl *RateLimiter) Reserve(key string, r rate.Limit, b int) *rate.Reservation <span class="cov0" title="0">{
        limiter := rl.GetLimiter(key, r, b)
        rl.metrics.incrementTotalRequests()
        return limiter.Reserve()
}</span>

// cleanupOldest 清理最旧的条目
func (rl *RateLimiter) cleanupOldest() <span class="cov0" title="0">{
        var oldestKey string
        var oldestTime time.Time

        for key, entry := range rl.limiters </span><span class="cov0" title="0">{
                if oldestKey == "" || entry.lastAccess.Before(oldestTime) </span><span class="cov0" title="0">{
                        oldestKey = key
                        oldestTime = entry.lastAccess
                }</span>
        }

        <span class="cov0" title="0">if oldestKey != "" </span><span class="cov0" title="0">{
                delete(rl.limiters, oldestKey)
                rl.metrics.decrementActiveLimiters()
                rl.metrics.incrementCleanedLimiters()
        }</span>
}

// startCleanup 启动清理协程
func (rl *RateLimiter) startCleanup() <span class="cov0" title="0">{
        ticker := time.NewTicker(rl.config.CleanupInterval)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                rl.cleanup()
        }</span>
}

// cleanup 清理过期的限流器
func (rl *RateLimiter) cleanup() <span class="cov0" title="0">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        now := time.Now()
        cleaned := 0

        for key, entry := range rl.limiters </span><span class="cov0" title="0">{
                if now.Sub(entry.lastAccess) &gt; rl.config.MaxIdleTime </span><span class="cov0" title="0">{
                        delete(rl.limiters, key)
                        cleaned++
                }</span>
        }

        <span class="cov0" title="0">if cleaned &gt; 0 </span><span class="cov0" title="0">{
                rl.metrics.decrementActiveLimitersBy(int64(cleaned))
                rl.metrics.incrementCleanedLimitersBy(int64(cleaned))
        }</span>
}

// GetStats 获取统计信息
func (rl *RateLimiter) GetStats() map[string]interface{} <span class="cov0" title="0">{
        rl.mu.RLock()
        defer rl.mu.RUnlock()

        rl.metrics.mu.RLock()
        defer rl.metrics.mu.RUnlock()

        return map[string]interface{}{
                "active_limiters":  rl.metrics.ActiveLimiters,
                "total_requests":   rl.metrics.TotalRequests,
                "limited_requests": rl.metrics.LimitedRequests,
                "cleaned_limiters": rl.metrics.CleanedLimiters,
                "current_entries":  len(rl.limiters),
                "max_entries":      rl.config.MaxEntries,
                "cleanup_interval": rl.config.CleanupInterval.String(),
                "max_idle_time":    rl.config.MaxIdleTime.String(),
                "default_rate":     float64(rl.config.DefaultRate),
                "default_burst":    rl.config.DefaultBurst,
        }
}</span>

// Reset 重置限流器
func (rl *RateLimiter) Reset() <span class="cov0" title="0">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        rl.limiters = make(map[string]*limiterEntry)
        rl.metrics.reset()
}</span>

// Remove 移除指定的限流器
func (rl *RateLimiter) Remove(key string) bool <span class="cov0" title="0">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        if _, exists := rl.limiters[key]; exists </span><span class="cov0" title="0">{
                delete(rl.limiters, key)
                rl.metrics.decrementActiveLimiters()
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// ListKeys 列出所有限流器键
func (rl *RateLimiter) ListKeys() []string <span class="cov0" title="0">{
        rl.mu.RLock()
        defer rl.mu.RUnlock()

        keys := make([]string, 0, len(rl.limiters))
        for key := range rl.limiters </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// GetEntryInfo 获取条目信息
func (rl *RateLimiter) GetEntryInfo(key string) (map[string]interface{}, bool) <span class="cov0" title="0">{
        rl.mu.RLock()
        defer rl.mu.RUnlock()

        if entry, exists := rl.limiters[key]; exists </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "key":         entry.key,
                        "created":     entry.created,
                        "last_access": entry.lastAccess,
                        "rate":        float64(entry.limiter.Limit()),
                        "burst":       entry.limiter.Burst(),
                }, true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

// Metrics 方法实现
func (m *Metrics) incrementTotalRequests() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.TotalRequests++
}</span>

func (m *Metrics) incrementLimitedRequests() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.LimitedRequests++
}</span>

func (m *Metrics) incrementActiveLimiters() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.ActiveLimiters++
}</span>

func (m *Metrics) decrementActiveLimiters() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        if m.ActiveLimiters &gt; 0 </span><span class="cov0" title="0">{
                m.ActiveLimiters--
        }</span>
}

func (m *Metrics) decrementActiveLimitersBy(count int64) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        if m.ActiveLimiters &gt;= count </span><span class="cov0" title="0">{
                m.ActiveLimiters -= count
        }</span> else<span class="cov0" title="0"> {
                m.ActiveLimiters = 0
        }</span>
}

func (m *Metrics) incrementCleanedLimiters() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.CleanedLimiters++
}</span>

func (m *Metrics) incrementCleanedLimitersBy(count int64) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.CleanedLimiters += count
}</span>

func (m *Metrics) reset() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.TotalRequests = 0
        m.LimitedRequests = 0
        m.ActiveLimiters = 0
        m.CleanedLimiters = 0
}</span>

// String 实现 Stringer 接口
func (rl *RateLimiter) String() string <span class="cov0" title="0">{
        stats := rl.GetStats()
        return fmt.Sprintf("RateLimiter{active_limiters: %v, total_requests: %v, limited_requests: %v}",
                stats["active_limiters"], stats["total_requests"], stats["limited_requests"])
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package utils

func RemoveDuplicates[T comparable](slice []T) []T <span class="cov0" title="0">{
        seen := make(map[T]struct{})
        result := make([]T, 0, len(slice))

        for _, item := range slice </span><span class="cov0" title="0">{
                if _, exists := seen[item]; !exists </span><span class="cov0" title="0">{
                        seen[item] = struct{}{}
                        result = append(result, item)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func RemoveDuplicatesBy[T any, K comparable](slice []T, keyFunc func(T) K) []T <span class="cov0" title="0">{
        seen := make(map[K]struct{})
        result := make([]T, 0, len(slice))

        for _, item := range slice </span><span class="cov0" title="0">{
                key := keyFunc(item)
                if _, exists := seen[key]; !exists </span><span class="cov0" title="0">{
                        seen[key] = struct{}{}
                        result = append(result, item)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func Contains[T comparable](slice []T, target T) bool <span class="cov0" title="0">{
        for _, item := range slice </span><span class="cov0" title="0">{
                if item == target </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// 使用示例：
// nums := []int{1, 2, 3, 4, 5}
// fmt.Println(Contains(nums, 3)) // true
// fmt.Println(Contains(nums, 6)) // false
</pre>
		
		<pre class="file" id="file55" style="display: none">package server

import (
        v1 "nancalacc/api/account/v1"
        "nancalacc/internal/conf"
        "nancalacc/internal/otel"
        "nancalacc/internal/service"

        "github.com/go-kratos/kratos/v2/middleware/recovery"
        "github.com/go-kratos/kratos/v2/middleware/tracing"
        "github.com/go-kratos/kratos/v2/transport/grpc"

        "google.golang.org/grpc/health"
        "google.golang.org/grpc/health/grpc_health_v1"
)

// NewGRPCServer new a gRPC server.
func NewGRPCServer(c *conf.Server, accountService *service.AccountService, integration *otel.Integration) *grpc.Server <span class="cov0" title="0">{
        var opts = []grpc.ServerOption{
                grpc.Middleware(
                        recovery.Recovery(),
                        tracing.Server(),
                ),
        }

        // 添加OpenTelemetry中间件
        if integration != nil </span><span class="cov0" title="0">{
                otelOpts := integration.CreateGRPCMiddleware()
                opts = append(opts, otelOpts...)
        }</span>

        <span class="cov0" title="0">if c.Grpc.Network != "" </span><span class="cov0" title="0">{
                opts = append(opts, grpc.Network(c.Grpc.Network))
        }</span>
        <span class="cov0" title="0">if c.Grpc.Addr != "" </span><span class="cov0" title="0">{
                opts = append(opts, grpc.Address(c.Grpc.Addr))
        }</span>
        <span class="cov0" title="0">if c.Grpc.Timeout != nil </span><span class="cov0" title="0">{
                opts = append(opts, grpc.Timeout(c.Grpc.Timeout.AsDuration()))
        }</span>
        <span class="cov0" title="0">srv := grpc.NewServer(opts...)

        healthCheck := health.NewServer()
        healthCheck.SetServingStatus("nancalacc.account.v1.asyncacc", grpc_health_v1.HealthCheckResponse_SERVING)
        v1.RegisterAccountServer(srv, accountService)
        return srv</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package server

import (
        "io"
        v1 "nancalacc/api/account/v1"
        "nancalacc/internal/conf"
        "nancalacc/internal/otel"
        "nancalacc/internal/service"

        nethttp "net/http"

        "github.com/go-kratos/kratos/v2/middleware/recovery"
        "github.com/go-kratos/kratos/v2/transport/http"
)

// NewHTTPServer new an HTTP server with OpenTelemetry integration.
func NewHTTPServer(c *conf.Server, accountService *service.AccountService, integration *otel.Integration, otelConfig *conf.OpenTelemetry) *http.Server <span class="cov0" title="0">{
        // 创建中间件选项
        var opts = []http.ServerOption{
                http.Middleware(
                        recovery.Recovery(),
                ),
        }

        // 添加OpenTelemetry中间件
        if integration != nil </span><span class="cov0" title="0">{
                otelOpts := integration.CreateHTTPMiddleware()
                opts = append(opts, otelOpts...)
        }</span>

        // 添加请求解码器
        <span class="cov0" title="0">opts = append(opts, http.RequestDecoder(func(r *http.Request, v interface{}) error </span><span class="cov0" title="0">{
                if r.URL.Path == "/v1/upload" </span><span class="cov0" title="0">{
                        data, err := io.ReadAll(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if req, ok := v.(*v1.UploadRequest); ok </span><span class="cov0" title="0">{
                                req.File = data
                                if filename := r.Header.Get("X-Filename"); filename != "" </span><span class="cov0" title="0">{
                                        req.Filename = filename
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }
                }
                <span class="cov0" title="0">return http.DefaultRequestDecoder(r, v)</span>
        }))

        // 添加服务器配置
        <span class="cov0" title="0">if c.Http.Network != "" </span><span class="cov0" title="0">{
                opts = append(opts, http.Network(c.Http.Network))
        }</span>
        <span class="cov0" title="0">if c.Http.Addr != "" </span><span class="cov0" title="0">{
                opts = append(opts, http.Address(c.Http.Addr))
        }</span>
        <span class="cov0" title="0">if c.Http.Timeout != nil </span><span class="cov0" title="0">{
                opts = append(opts, http.Timeout(c.Http.Timeout.AsDuration()))
        }</span>

        <span class="cov0" title="0">srv := http.NewServer(opts...)
        v1.RegisterAccountHTTPServer(srv, accountService)

        // 添加健康检查路由
        srv.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(nethttp.StatusOK)
                w.Write([]byte("OK"))
        }</span>)

        // 添加指标端点（如果启用）
        <span class="cov0" title="0">if otelConfig != nil &amp;&amp; otelConfig.Metrics != nil &amp;&amp; otelConfig.Metrics.Enabled </span><span class="cov0" title="0">{
                srv.HandleFunc("/metrics", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // 这里可以添加Prometheus指标端点
                        w.WriteHeader(nethttp.StatusOK)
                        w.Write([]byte("# OpenTelemetry metrics endpoint"))
                }</span>)
        }

        <span class="cov0" title="0">return srv</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package service

import (
        "context"
        "errors"
        "os"
        "path/filepath"
        "time"

        v1 "nancalacc/api/account/v1"
        "nancalacc/internal/biz"
        "nancalacc/internal/conf"
        "nancalacc/internal/pkg/limiter"

        "github.com/go-kratos/kratos/v2/log"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
        "google.golang.org/protobuf/types/known/timestamppb"
)

type AccountService struct {
        v1.UnimplementedAccountServer
        accounterUsecase *biz.AccounterUsecase
        oauth2Usecase    *biz.Oauth2Usecase
        fullSyncUsecase  *biz.FullSyncUsecase
        limiter          *limiter.RateLimiter
        log              log.Logger
}

func NewAccountService(accounterUsecase *biz.AccounterUsecase, oauth2Usecase *biz.Oauth2Usecase, fullSyncUsecase *biz.FullSyncUsecase, logger log.Logger) *AccountService <span class="cov0" title="0">{
        limiter := limiter.NewRateLimiter(nil) // 使用默认配置
        return &amp;AccountService{accounterUsecase: accounterUsecase, oauth2Usecase: oauth2Usecase, fullSyncUsecase: fullSyncUsecase, limiter: limiter, log: logger}
}</span>

func (s *AccountService) CreateSyncAccount(ctx context.Context, req *v1.CreateSyncAccountRequest) (*v1.CreateSyncAccountReply, error) <span class="cov0" title="0">{
        s.log.Log(log.LevelInfo, "msg", "CreateSyncAccount", "req", req)
        if req.GetTaskName() != "" &amp;&amp; len(req.GetTaskName()) != 14 </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "invalid taskname: %s", req.GetTaskName())
        }</span>
        <span class="cov0" title="0">if req.GetTaskName() == "" </span><span class="cov0" title="0">{
                taskId := time.Now().Add(time.Duration(1) * time.Second).Format("20060102150405")
                req.TaskName = &amp;taskId
        }</span>

        // 使用更合理的限流配置
        // 全局限流：每秒最多10个请求，突发20个请求
        <span class="cov0" title="0">if !s.limiter.Allow("global_sync_account", 10, 20) </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.ResourceExhausted, "global rate limit exceeded")
        }</span>

        // 如果提供了任务名称，对特定任务进行额外限流
        <span class="cov0" title="0">if req.GetTaskName() != "" </span><span class="cov0" title="0">{
                // 特定任务限流：每秒最多2个请求，突发5个请求
                if !s.limiter.Allow("task_"+req.GetTaskName(), 2, 5) </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.ResourceExhausted, "task rate limit exceeded for: %s", req.GetTaskName())
                }</span>
        }

        // 4. 立即创建任务记录（状态：pending）
        <span class="cov0" title="0">_, ok, err := s.fullSyncUsecase.GetCacheTask(ctx, req.GetTaskName())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Log(log.LevelError, "msg", "CreateSyncAccountAsync.GetCacheTask", "taskId", req.GetTaskName(), "err", err)
                return nil, status.Errorf(codes.Internal, "failed to create task: %v", err)
        }</span>
        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.AlreadyExists, "task name %s exists", req.GetTaskName())
        }</span>

        // 5. 启动异步处理
        <span class="cov0" title="0">go s.executeAsyncSync(req)

        // 6. 立即返回任务ID，不等待同步完成
        s.log.Log(log.LevelInfo, "msg", "CreateSyncAccountAsync.started", "taskId", req.GetTaskName())

        return &amp;v1.CreateSyncAccountReply{
                TaskId:     req.GetTaskName(),
                CreateTime: timestamppb.Now(),
        }, nil</span>
}
func (s *AccountService) executeAsyncSync(req *v1.CreateSyncAccountRequest) <span class="cov0" title="0">{
        startTime := time.Now()
        taskId := req.GetTaskName()
        // 设置异步执行的超时时间（比HTTP超时更长）
        asyncCtx, cancel := context.WithTimeout(context.Background(), 60*time.Minute)
        defer cancel()

        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.log.Log(log.LevelError, "msg", "executeAsyncSync.panic", "taskId", taskId, "panic", r)
                }</span>
        }()

        <span class="cov0" title="0">s.log.Log(log.LevelInfo, "msg", "executeAsyncSync.start", "taskId", taskId, "layer", "service")

        _, err := s.fullSyncUsecase.CreateSyncAccount(asyncCtx, req)
        if err != nil </span><span class="cov0" title="0">{
                err = s.fullSyncUsecase.UpdateCacheTask(asyncCtx, taskId, "failed", 0)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Log(log.LevelError, "msg", "executeAsyncSync.update_cache_task", "taskId", taskId, "err", err)
                }</span>
                <span class="cov0" title="0">s.log.Log(log.LevelError, "msg", "executeAsyncSync.business_layer", "taskId", taskId, "err", err)
                return</span>
        }

        <span class="cov0" title="0">actualTime := int(time.Since(startTime).Minutes())
        s.log.Log(log.LevelInfo, "msg", "executeAsyncSync.completed", "taskId", taskId, "actualTime", actualTime, "layer", "service")</span>
}
func (s *AccountService) GetSyncAccount(ctx context.Context, req *v1.GetSyncAccountRequest) (*v1.GetSyncAccountReply, error) <span class="cov0" title="0">{

        log.Infof("GetSyncAccount req: %v", req)
        globalConf := conf.Get()
        log.Infof("globalConf: %v", globalConf)
        ctx, cancel := context.WithTimeout(ctx, 50*time.Minute)
        defer cancel()
        return s.fullSyncUsecase.GetSyncAccount(ctx, req)
}</span>
func (s *AccountService) CancelSyncTask(ctx context.Context, req *v1.CancelSyncAccountRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        s.log.Log(log.LevelInfo, "msg", "CancelSyncTask", "req", req)
        if req.TaskId == "" </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "task_id is empty")
        }</span>
        <span class="cov0" title="0">err := s.fullSyncUsecase.CleanSyncAccount(ctx, req.TaskId, req.GetTags())

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}
func (s *AccountService) GetUserInfo(ctx context.Context, req *v1.GetUserInfoRequest) (*v1.GetUserInfoResponse, error) <span class="cov0" title="0">{

        s.log.Log(log.LevelInfo, "msg", "GetUserInfo", "req", req)

        accessToken := req.GetAccessToken()
        if accessToken == "" </span><span class="cov0" title="0">{
                return nil, errors.New("access_token is empty")
        }</span>
        <span class="cov0" title="0">userInfo, err := s.oauth2Usecase.GetUserInfo(ctx, &amp;v1.GetUserInfoRequest{
                AccessToken: accessToken,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return userInfo, nil</span>
}
func (s *AccountService) GetAccessToken(ctx context.Context, req *v1.GetAccessTokenRequest) (*v1.GetAccessTokenResponse, error) <span class="cov0" title="0">{

        s.log.Log(log.LevelInfo, "msg", "GetAccessToken", "req", req)

        code := req.GetCode()
        if code == "" </span><span class="cov0" title="0">{
                return nil, errors.New("code is empty")
        }</span>
        <span class="cov0" title="0">accessTokenResp, err := s.oauth2Usecase.GetAccessToken(ctx, &amp;v1.GetAccessTokenRequest{
                Code: code,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return accessTokenResp, nil</span>
}

func (s *AccountService) Callback(ctx context.Context, req *v1.CallbackRequest) (*v1.CallbackResponse, error) <span class="cov0" title="0">{

        s.accounterUsecase.CreateSyncTask(ctx, &amp;v1.CreateSyncAccountRequest{})
        return nil, status.Errorf(codes.Unimplemented, "method Callback not implemented")
}</span>

//        curl -X POST "http://your-server/v1/upload/excel" \
//          -H "X-Filename: test.xlsx" \
//          --data-binary "@/path/to/your/file.xlsx"

func (s *AccountService) UploadFile(ctx context.Context, req *v1.UploadRequest) (*v1.UploadReply, error) <span class="cov0" title="0">{

        s.log.Log(log.LevelInfo, "msg", "UploadFile", "req", req.GetFilename())

        taskId := time.Now().Add(time.Duration(1) * time.Second).Format("20060102150405")

        s.log.Log(log.LevelInfo, "msg", "UploadFile", "taskId", taskId)

        if req.GetFile() == nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "file is empty")
        }</span>

        // 检查文件类型
        // if req.GetFile().GetContentType() != "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" {
        //         return nil, status.Errorf(codes.InvalidArgument, "file type is not excel")
        // }

        // // 检查文件大小
        // if req.GetFile().GetSize() &gt; 10*1024*1024 {
        //         return nil, status.Errorf(codes.InvalidArgument, "file size is too large")
        // }

        // 创建临时文件
        <span class="cov0" title="0">tempDir := os.TempDir()
        tempDir = "/tmp"
        filename := filepath.Join(tempDir, taskId+".xlsx")

        // 写入文件
        err := os.WriteFile(filename, req.GetFile(), 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "failed to write file: %v", err)
        }</span>

        // 创建缓存任务
        <span class="cov0" title="0">err = s.fullSyncUsecase.CreateCacheTask(ctx, taskId, "pending")
        if err != nil </span><span class="cov0" title="0">{
                // 清理临时文件
                os.Remove(filename)
                return nil, status.Errorf(codes.Internal, "failed to create cache task: %v", err)
        }</span>
        // 使用带错误处理的异步执行
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        // 清理临时文件
                        if err := os.Remove(filename); err != nil </span><span class="cov0" title="0">{
                                s.log.Log(log.LevelWarn, "msg", "failed to remove temp file", "filename", filename, "err", err)
                        }</span>
                }()

                // 检查原始 context 状态
                // select {
                // case &lt;-ctx.Done():
                //         s.log.Log(log.LevelWarn, "msg", "original context already canceled before starting goroutine", "err", ctx.Err())
                //         return
                // default:
                //         // 继续执行
                // }

                // 使用 Background context 避免依赖可能被取消的原始 context
                <span class="cov0" title="0">parseCtx, cancel := context.WithTimeout(context.Background(), 120*time.Minute)
                defer cancel()

                s.log.Log(log.LevelInfo, "msg", "starting excel parsing", "taskId", taskId, "filename", filename)

                // 更新任务状态为进行中
                if err := s.fullSyncUsecase.UpdateCacheTask(parseCtx, taskId, "in_progress", 20); err != nil </span><span class="cov0" title="0">{
                        s.log.Log(log.LevelError, "msg", "failed to update task status to in_progress", "err", err)
                }</span>

                // 执行解析
                <span class="cov0" title="0">if err := s.fullSyncUsecase.ParseExecell(parseCtx, taskId, filename); err != nil </span><span class="cov0" title="0">{
                        s.log.Log(log.LevelError, "msg", "failed to parse excel", "err", err)
                        // 更新任务状态为失败
                        s.fullSyncUsecase.UpdateCacheTask(parseCtx, taskId, "completed", 0)
                        return
                }</span>

                // 更新任务状态为完成
                <span class="cov0" title="0">if err := s.fullSyncUsecase.UpdateCacheTask(parseCtx, taskId, "completed", 100); err != nil </span><span class="cov0" title="0">{
                        s.log.Log(log.LevelError, "msg", "failed to update task status to completed", "err", err)
                }</span>

                <span class="cov0" title="0">s.log.Log(log.LevelInfo, "msg", "Excel parsing completed for task", "taskId", taskId)</span>
        }()

        <span class="cov0" title="0">return &amp;v1.UploadReply{
                Task: taskId,
        }, nil</span>
}

func (s *AccountService) GetTask(ctx context.Context, in *v1.GetTaskRequest) (*v1.GetTaskReply, error) <span class="cov0" title="0">{

        s.log.Log(log.LevelInfo, "msg", "GetTask", "req", in)

        taskName := in.GetTaskName()
        if taskName == "" </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "taskName empty")
        }</span>

        <span class="cov0" title="0">if len(taskName) != 14 </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "taskName invalid")
        }</span>

        <span class="cov0" title="0">task, err := s.accounterUsecase.GetTask(ctx, taskName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "create task failed: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;v1.GetTaskReply{
                Task: task,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package service

import (
        "context"
        "nancalacc/internal/biz"
        "nancalacc/internal/conf"
        "sync/atomic"

        "github.com/go-kratos/kratos/v2/log"
        clientV2 "github.com/open-dingtalk/dingtalk-stream-sdk-go/clientV2"
)

type DingTalkEventService struct {
        cfg                    *conf.Auth_Dingtalk
        log                    *log.Helper
        incrementalSyncUsecase *biz.IncrementalSyncUsecase
        running                atomic.Bool
        cancel                 context.CancelFunc
        //client clientV2.OpenDingTalkClient
}

func NewDingTalkEventService(incrementalSyncUsecase *biz.IncrementalSyncUsecase, logger log.Logger) *DingTalkEventService <span class="cov0" title="0">{
        cfg := conf.Get().GetAuth().GetDingtalk()
        return &amp;DingTalkEventService{cfg: cfg, log: log.NewHelper(logger), incrementalSyncUsecase: incrementalSyncUsecase}
}</span>

func (es *DingTalkEventService) Start() <span class="cov0" title="0">{
        //log.Info(es.cfg)

        cred := &amp;clientV2.AuthClientCredential{
                ClientId:     es.cfg.AppKey,
                ClientSecret: es.cfg.AppSecret,
        }

        ctx, cancel := context.WithCancel(context.Background())
        es.cancel = cancel
        es.running.Store(true)
        go func() </span><span class="cov0" title="0">{
                defer es.running.Store(false)
                e := clientV2.
                        NewBuilder().
                        Credential(cred).
                        //监听开放平台事件
                        RegisterAllEventHandler(es.HandleEvent).
                        Build().
                        Start(ctx)
                if e != nil </span><span class="cov0" title="0">{
                        log.Error("DingTalkEventService.Start failed", e.Error())
                }</span>
                <span class="cov0" title="0">log.Info("event service start success")</span>
        }()
        <span class="cov0" title="0">log.Info("event service starting...")</span>

}
func (es *DingTalkEventService) Stop() <span class="cov0" title="0">{
        if !es.running.Load() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">log.Info("=====DingTalkEventService.Stop===")
        es.cancel()</span>
}
func (es *DingTalkEventService) Running() bool <span class="cov0" title="0">{
        return es.running.Load()

}</span>

func (es *DingTalkEventService) HandleEvent(event *clientV2.GenericOpenDingTalkEvent) clientV2.EventStatus <span class="cov0" title="0">{
        println("HandleEvent ", event.Data)

        ctx := context.Background()
        switch event.EventType </span>{
        case "org_dept_create":<span class="cov0" title="0">
                es.log.Infof("org_dept_create: %v", event.Data)
                es.OrgDeptCreate(ctx, event)</span>
        case "org_dept_modify":<span class="cov0" title="0">
                es.log.Infof("org_dept_modify: %v", event.Data)
                es.OrgDeptModify(ctx, event)</span>
        case "org_dept_remove":<span class="cov0" title="0">
                es.log.Infof("org_dept_remove: %v", event.Data)
                es.OrgDeptRemove(ctx, event)</span>
        case "user_add_org":<span class="cov0" title="0">
                es.log.Infof("user_add_org: %v", event.Data)
                es.UserAddOrg(ctx, event)</span>
        case "user_modify_org":<span class="cov0" title="0">
                es.log.Infof("user_modify_org: %v", event.Data)
                es.UserModifyOrg(ctx, event)</span>
        case "user_leave_org":<span class="cov0" title="0">
                es.UserLeaveOrg(ctx, event)
                es.log.Infof("user_leave_org: %v", event.Data)</span>
        default:<span class="cov0" title="0">
                es.log.Infof("unknown event: %v", event.Data)
                return clientV2.EventStatusSuccess</span>
        }
        <span class="cov0" title="0">return clientV2.EventStatusSuccess</span>
}

func (es *DingTalkEventService) OrgDeptCreate(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) clientV2.EventStatus <span class="cov0" title="0">{
        es.log.Infof("OrgDeptCreate: %v", event.Data)
        err := es.incrementalSyncUsecase.OrgDeptCreate(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return clientV2.EventStatusLater
        }</span>

        <span class="cov0" title="0">return clientV2.EventStatusSuccess</span>
}
func (es *DingTalkEventService) OrgDeptModify(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) clientV2.EventStatus <span class="cov0" title="0">{

        err := es.incrementalSyncUsecase.OrgDeptModify(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return clientV2.EventStatusLater
        }</span>
        <span class="cov0" title="0">return clientV2.EventStatusSuccess</span>
}
func (es *DingTalkEventService) OrgDeptRemove(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) clientV2.EventStatus <span class="cov0" title="0">{

        err := es.incrementalSyncUsecase.OrgDeptRemove(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return clientV2.EventStatusLater
        }</span>
        <span class="cov0" title="0">return clientV2.EventStatusSuccess</span>
}
func (es *DingTalkEventService) UserAddOrg(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) clientV2.EventStatus <span class="cov0" title="0">{

        err := es.incrementalSyncUsecase.UserAddOrg(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return clientV2.EventStatusLater
        }</span>
        <span class="cov0" title="0">return clientV2.EventStatusSuccess</span>
}
func (es *DingTalkEventService) UserModifyOrg(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) clientV2.EventStatus <span class="cov0" title="0">{

        err := es.incrementalSyncUsecase.UserModifyOrg(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return clientV2.EventStatusLater
        }</span>
        <span class="cov0" title="0">return clientV2.EventStatusSuccess</span>
}
func (es *DingTalkEventService) UserLeaveOrg(ctx context.Context, event *clientV2.GenericOpenDingTalkEvent) clientV2.EventStatus <span class="cov0" title="0">{

        err := es.incrementalSyncUsecase.UserLeaveOrg(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return clientV2.EventStatusLater
        }</span>
        <span class="cov0" title="0">return clientV2.EventStatusSuccess</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package service

import (
        "context"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/jaeger"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.17.0"
        "go.opentelemetry.io/otel/trace"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        "nancalacc/internal/conf"
)

// ProviderSet 是otel服务的提供者集合

// OTelService OpenTelemetry服务
type OTelService struct {
        logger *log.Helper
        config *conf.OpenTelemetry
        tracer trace.Tracer
}

// NewOTelService 创建OpenTelemetry服务
func NewOTelService(c *conf.OpenTelemetry, logger log.Logger) *OTelService <span class="cov0" title="0">{
        return &amp;OTelService{
                logger: log.NewHelper(logger),
                config: c,
        }
}</span>

// Init 初始化OpenTelemetry
func (s *OTelService) Init(ctx context.Context) error <span class="cov0" title="0">{
        if !s.config.Enabled </span><span class="cov0" title="0">{
                s.logger.Info("OpenTelemetry is disabled")
                return nil
        }</span>

        // 创建资源
        <span class="cov0" title="0">res, err := resource.New(ctx,
                resource.WithAttributes(
                        semconv.ServiceName(s.config.ServiceName),
                        semconv.ServiceVersion(s.config.ServiceVersion),
                        semconv.DeploymentEnvironment(s.config.Environment),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 创建导出器
        <span class="cov0" title="0">var exporter sdktrace.SpanExporter
        if s.config.Traces.Jaeger != nil &amp;&amp; s.config.Traces.Jaeger.Enabled </span><span class="cov0" title="0">{
                exporter, err = jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(s.config.Traces.Jaeger.Endpoint)))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">s.logger.Infof("Jaeger exporter initialized: %s", s.config.Traces.Jaeger.Endpoint)</span>
        } else<span class="cov0" title="0"> if s.config.Traces.Otlp != nil &amp;&amp; s.config.Traces.Otlp.Enabled </span><span class="cov0" title="0">{
                timeout := time.Duration(s.config.Traces.Otlp.Timeout) * time.Second
                conn, err := grpc.DialContext(ctx, s.config.Traces.Otlp.Endpoint,
                        grpc.WithTransportCredentials(insecure.NewCredentials()),
                        grpc.WithBlock(),
                        grpc.WithTimeout(timeout),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">exporter, err = otlptrace.New(ctx, otlptracegrpc.NewClient(otlptracegrpc.WithGRPCConn(conn)))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">s.logger.Infof("OTLP exporter initialized: %s", s.config.Traces.Otlp.Endpoint)</span>
        } else<span class="cov0" title="0"> {
                s.logger.Warn("No exporter configured, using noop exporter")
                return nil
        }</span>

        // 创建TracerProvider
        <span class="cov0" title="0">tp := sdktrace.NewTracerProvider(
                sdktrace.WithBatcher(exporter),
                sdktrace.WithResource(res),
        )

        // 设置全局TracerProvider
        otel.SetTracerProvider(tp)

        // 设置全局Propagator
        otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        ))

        // 创建tracer
        s.tracer = tp.Tracer(s.config.ServiceName)

        s.logger.Info("OpenTelemetry initialized successfully")
        return nil</span>
}

// GetTracer 获取tracer
func (s *OTelService) GetTracer() trace.Tracer <span class="cov0" title="0">{
        return s.tracer
}</span>

// Shutdown 关闭OpenTelemetry
func (s *OTelService) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        if s.config.Enabled </span><span class="cov0" title="0">{
                if tp, ok := otel.GetTracerProvider().(*sdktrace.TracerProvider); ok </span><span class="cov0" title="0">{
                        return tp.Shutdown(ctx)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package service

import (
        "context"
        "fmt"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/jaeger"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        "go.opentelemetry.io/otel/exporters/stdout/stdouttrace"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.17.0"
        "go.opentelemetry.io/otel/trace"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        "nancalacc/internal/conf"

        "go.opentelemetry.io/otel/attribute"
)

// UnifiedOTelService 统一的 OpenTelemetry 服务
type UnifiedOTelService struct {
        logger *log.Helper
        config *conf.OpenTelemetry
        tracer trace.Tracer
}

// NewUnifiedOTelService 创建统一的 OpenTelemetry 服务
func NewUnifiedOTelService(c *conf.OpenTelemetry, logger log.Logger) *UnifiedOTelService <span class="cov0" title="0">{
        return &amp;UnifiedOTelService{
                logger: log.NewHelper(logger),
                config: c,
        }
}</span>

// Init 初始化 OpenTelemetry
func (s *UnifiedOTelService) Init(ctx context.Context) error <span class="cov0" title="0">{
        if !s.config.Enabled </span><span class="cov0" title="0">{
                s.logger.Info("OpenTelemetry is disabled")
                return nil
        }</span>

        <span class="cov0" title="0">s.logger.Info("Initializing OpenTelemetry...")

        // 1. 创建资源
        res, err := s.createResource(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create resource: %w", err)
        }</span>

        // 2. 创建导出器
        <span class="cov0" title="0">exporter, err := s.createExporter(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create exporter: %w", err)
        }</span>

        // 3. 创建 TracerProvider
        <span class="cov0" title="0">tp := sdktrace.NewTracerProvider(
                sdktrace.WithBatcher(exporter),
                sdktrace.WithResource(res),
                sdktrace.WithSampler(sdktrace.AlwaysSample()), // 采样所有追踪
        )

        // 4. 设置全局配置
        otel.SetTracerProvider(tp)
        otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        ))

        // 5. 创建 tracer
        s.tracer = tp.Tracer(s.config.ServiceName)

        s.logger.Infof("OpenTelemetry initialized successfully with service: %s, version: %s, environment: %s",
                s.config.ServiceName, s.config.ServiceVersion, s.config.Environment)

        return nil</span>
}

// createResource 创建资源
func (s *UnifiedOTelService) createResource(ctx context.Context) (*resource.Resource, error) <span class="cov0" title="0">{
        attrs := []attribute.KeyValue{
                semconv.ServiceName(s.config.ServiceName),
                semconv.ServiceVersion(s.config.ServiceVersion),
                semconv.DeploymentEnvironment(s.config.Environment),
        }

        return resource.New(ctx, resource.WithAttributes(attrs...))
}</span>

// createExporter 创建导出器
func (s *UnifiedOTelService) createExporter(ctx context.Context) (sdktrace.SpanExporter, error) <span class="cov0" title="0">{
        // 优先级：Jaeger &gt; OTLP &gt; Stdout
        if s.config.Traces.Jaeger != nil &amp;&amp; s.config.Traces.Jaeger.Enabled </span><span class="cov0" title="0">{
                return s.createJaegerExporter(ctx)
        }</span>

        <span class="cov0" title="0">if s.config.Traces.Otlp != nil &amp;&amp; s.config.Traces.Otlp.Enabled </span><span class="cov0" title="0">{
                return s.createOTLPExporter(ctx)
        }</span>

        // 默认使用 stdout 导出器（用于开发环境）
        <span class="cov0" title="0">s.logger.Warn("No exporter configured, using stdout exporter for development")
        return s.createStdoutExporter()</span>
}

// createJaegerExporter 创建 Jaeger 导出器
func (s *UnifiedOTelService) createJaegerExporter(ctx context.Context) (sdktrace.SpanExporter, error) <span class="cov0" title="0">{
        s.logger.Infof("Creating Jaeger exporter with endpoint: %s", s.config.Traces.Jaeger.Endpoint)

        exporter, err := jaeger.New(jaeger.WithCollectorEndpoint(
                jaeger.WithEndpoint(s.config.Traces.Jaeger.Endpoint),
        ))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Jaeger exporter: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Jaeger exporter created successfully")
        return exporter, nil</span>
}

// createOTLPExporter 创建 OTLP 导出器
func (s *UnifiedOTelService) createOTLPExporter(ctx context.Context) (sdktrace.SpanExporter, error) <span class="cov0" title="0">{
        s.logger.Infof("Creating OTLP exporter with endpoint: %s", s.config.Traces.Otlp.Endpoint)

        timeout := time.Duration(s.config.Traces.Otlp.Timeout) * time.Second
        conn, err := grpc.DialContext(ctx, s.config.Traces.Otlp.Endpoint,
                grpc.WithTransportCredentials(insecure.NewCredentials()),
                grpc.WithBlock(),
                grpc.WithTimeout(timeout),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to OTLP endpoint: %w", err)
        }</span>

        <span class="cov0" title="0">exporter, err := otlptrace.New(ctx, otlptracegrpc.NewClient(
                otlptracegrpc.WithGRPCConn(conn),
        ))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create OTLP exporter: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("OTLP exporter created successfully")
        return exporter, nil</span>
}

// createStdoutExporter 创建标准输出导出器
func (s *UnifiedOTelService) createStdoutExporter() (sdktrace.SpanExporter, error) <span class="cov0" title="0">{
        s.logger.Info("Creating stdout exporter")

        exporter, err := stdouttrace.New(stdouttrace.WithPrettyPrint())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stdout exporter: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Stdout exporter created successfully")
        return exporter, nil</span>
}

// GetTracer 获取 tracer
func (s *UnifiedOTelService) GetTracer() trace.Tracer <span class="cov0" title="0">{
        return s.tracer
}</span>

// Shutdown 关闭 OpenTelemetry
func (s *UnifiedOTelService) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        if !s.config.Enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">s.logger.Info("Shutting down OpenTelemetry...")

        if tp, ok := otel.GetTracerProvider().(*sdktrace.TracerProvider); ok </span><span class="cov0" title="0">{
                if err := tp.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to shutdown tracer provider: %w", err)
                }</span>
        }

        <span class="cov0" title="0">s.logger.Info("OpenTelemetry shutdown completed")
        return nil</span>
}

// IsEnabled 检查是否启用
func (s *UnifiedOTelService) IsEnabled() bool <span class="cov0" title="0">{
        return s.config.Enabled
}</span>

// GetConfig 获取配置
func (s *UnifiedOTelService) GetConfig() *conf.OpenTelemetry <span class="cov0" title="0">{
        return s.config
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">// internal/task/config.go
package task

import (
        "context"
        "fmt"
        "time"

        "github.com/go-kratos/kratos/v2/log"
)

// JobConfig 任务配置
type JobConfig struct {
        Name        string        `json:"name"`        // 任务名称
        Spec        string        `json:"spec"`        // cron 表达式
        Description string        `json:"description"` // 任务描述
        Timeout     time.Duration `json:"timeout"`     // 执行超时时间
        RetryCount  int           `json:"retry_count"` // 重试次数
        RetryDelay  time.Duration `json:"retry_delay"` // 重试间隔
        Enabled     bool          `json:"enabled"`     // 是否启用
        MaxRetries  int           `json:"max_retries"` // 最大重试次数（包括首次执行）
        Backoff     BackoffConfig `json:"backoff"`     // 退避策略配置
}

// BackoffConfig 退避策略配置
type BackoffConfig struct {
        Type      BackoffType   `json:"type"`       // 退避类型：fixed, exponential, jitter
        BaseDelay time.Duration `json:"base_delay"` // 基础延迟时间
        MaxDelay  time.Duration `json:"max_delay"`  // 最大延迟时间
        Factor    float64       `json:"factor"`     // 指数退避因子
}

// BackoffType 退避类型
type BackoffType string

const (
        BackoffFixed       BackoffType = "fixed"       // 固定延迟
        BackoffExponential BackoffType = "exponential" // 指数退避
        BackoffJitter      BackoffType = "jitter"      // 抖动退避
)

// JobResult 任务执行结果
type JobResult struct {
        JobName    string        `json:"job_name"`
        StartTime  time.Time     `json:"start_time"`
        EndTime    time.Time     `json:"end_time"`
        Duration   time.Duration `json:"duration"`
        Success    bool          `json:"success"`
        Error      error         `json:"error,omitempty"`
        RetryCount int           `json:"retry_count"`
        IsTimeout  bool          `json:"is_timeout"`
        IsRetry    bool          `json:"is_retry"`
}

// JobExecutor 任务执行器接口
type JobExecutor interface {
        Execute(ctx context.Context) error
}

// JobExecutorFunc 任务执行器函数类型
type JobExecutorFunc func(ctx context.Context) error

// Execute 实现 JobExecutor 接口
func (f JobExecutorFunc) Execute(ctx context.Context) error <span class="cov0" title="0">{
        return f(ctx)
}</span>

// DefaultJobConfig 创建默认任务配置
func DefaultJobConfig(name, spec string) *JobConfig <span class="cov0" title="0">{
        return &amp;JobConfig{
                Name:        name,
                Spec:        spec,
                Description: "",
                Timeout:     30 * time.Minute, // 默认30分钟超时
                RetryCount:  3,                // 默认重试3次
                RetryDelay:  5 * time.Minute,  // 默认重试间隔5分钟
                Enabled:     true,
                MaxRetries:  3,
                Backoff: BackoffConfig{
                        Type:      BackoffExponential,
                        BaseDelay: 1 * time.Minute,
                        MaxDelay:  30 * time.Minute,
                        Factor:    2.0,
                },
        }
}</span>

// WithTimeout 设置超时时间
func (jc *JobConfig) WithTimeout(timeout time.Duration) *JobConfig <span class="cov0" title="0">{
        jc.Timeout = timeout
        return jc
}</span>

// WithRetry 设置重试配置
func (jc *JobConfig) WithRetry(count int, delay time.Duration) *JobConfig <span class="cov0" title="0">{
        jc.RetryCount = count
        jc.RetryDelay = delay
        jc.MaxRetries = count
        return jc
}</span>

// WithBackoff 设置退避策略
func (jc *JobConfig) WithBackoff(backoffType BackoffType, baseDelay, maxDelay time.Duration, factor float64) *JobConfig <span class="cov0" title="0">{
        jc.Backoff = BackoffConfig{
                Type:      backoffType,
                BaseDelay: baseDelay,
                MaxDelay:  maxDelay,
                Factor:    factor,
        }
        return jc
}</span>

// WithDescription 设置任务描述
func (jc *JobConfig) WithDescription(description string) *JobConfig <span class="cov0" title="0">{
        jc.Description = description
        return jc
}</span>

// WithEnabled 设置是否启用
func (jc *JobConfig) WithEnabled(enabled bool) *JobConfig <span class="cov0" title="0">{
        jc.Enabled = enabled
        return jc
}</span>

// ExecuteWithRetry 带重试机制的任务执行
func (jc *JobConfig) ExecuteWithRetry(ctx context.Context, executor JobExecutor, logger log.Logger) *JobResult <span class="cov0" title="0">{
        result := &amp;JobResult{
                JobName:   jc.Name,
                StartTime: time.Now(),
        }

        var lastErr error
        for attempt := 0; attempt &lt;= jc.MaxRetries; attempt++ </span><span class="cov0" title="0">{
                // 创建带超时的上下文
                execCtx, cancel := context.WithTimeout(ctx, jc.Timeout)

                // 执行任务
                err := executor.Execute(execCtx)
                cancel()

                // 记录执行时间
                result.EndTime = time.Now()
                result.Duration = result.EndTime.Sub(result.StartTime)
                result.RetryCount = attempt

                if err == nil </span><span class="cov0" title="0">{
                        // 任务执行成功
                        result.Success = true
                        logger.Log(log.LevelInfo, "msg", "job executed successfully",
                                "job_name", jc.Name,
                                "attempt", attempt+1,
                                "duration", result.Duration)
                        return result
                }</span>

                // 任务执行失败
                <span class="cov0" title="0">lastErr = err
                result.Error = err
                result.IsRetry = attempt &lt; jc.MaxRetries

                // 检查是否超时
                if execCtx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        result.IsTimeout = true
                        logger.Log(log.LevelError, "msg", "job execution timeout",
                                "job_name", jc.Name,
                                "attempt", attempt+1,
                                "timeout", jc.Timeout)
                }</span> else<span class="cov0" title="0"> {
                        logger.Log(log.LevelError, "msg", "job execution failed",
                                "job_name", jc.Name,
                                "attempt", attempt+1,
                                "error", err)
                }</span>

                // 如果还有重试机会，等待后重试
                <span class="cov0" title="0">if attempt &lt; jc.MaxRetries </span><span class="cov0" title="0">{
                        delay := jc.calculateDelay(attempt)
                        logger.Log(log.LevelInfo, "msg", "retrying job",
                                "job_name", jc.Name,
                                "attempt", attempt+1,
                                "next_attempt", attempt+2,
                                "delay", delay)

                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                // 父上下文被取消
                                result.Error = ctx.Err()
                                return result</span>
                        case &lt;-time.After(delay):<span class="cov0" title="0">
                                // 等待重试延迟
                                continue</span>
                        }
                }
        }

        // 所有重试都失败了
        <span class="cov0" title="0">logger.Log(log.LevelError, "msg", "job execution failed after all retries",
                "job_name", jc.Name,
                "total_attempts", jc.MaxRetries+1,
                "final_error", lastErr)

        return result</span>
}

// calculateDelay 计算重试延迟时间
func (jc *JobConfig) calculateDelay(attempt int) time.Duration <span class="cov0" title="0">{
        switch jc.Backoff.Type </span>{
        case BackoffFixed:<span class="cov0" title="0">
                return jc.RetryDelay</span>

        case BackoffExponential:<span class="cov0" title="0">
                delay := jc.Backoff.BaseDelay
                for i := 0; i &lt; attempt; i++ </span><span class="cov0" title="0">{
                        delay = time.Duration(float64(delay) * jc.Backoff.Factor)
                        if delay &gt; jc.Backoff.MaxDelay </span><span class="cov0" title="0">{
                                delay = jc.Backoff.MaxDelay
                                break</span>
                        }
                }
                <span class="cov0" title="0">return delay</span>

        case BackoffJitter:<span class="cov0" title="0">
                // 指数退避 + 随机抖动
                baseDelay := jc.Backoff.BaseDelay
                for i := 0; i &lt; attempt; i++ </span><span class="cov0" title="0">{
                        baseDelay = time.Duration(float64(baseDelay) * jc.Backoff.Factor)
                        if baseDelay &gt; jc.Backoff.MaxDelay </span><span class="cov0" title="0">{
                                baseDelay = jc.Backoff.MaxDelay
                                break</span>
                        }
                }
                // 添加 ±25% 的随机抖动
                <span class="cov0" title="0">jitter := time.Duration(float64(baseDelay) * 0.25)
                return baseDelay + time.Duration(float64(jitter)*(0.5-0.5*float64(time.Now().UnixNano()%2)))</span>

        default:<span class="cov0" title="0">
                return jc.RetryDelay</span>
        }
}

// Validate 验证任务配置
func (jc *JobConfig) Validate() error <span class="cov0" title="0">{
        if jc.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("job name cannot be empty")
        }</span>
        <span class="cov0" title="0">if jc.Spec == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("cron spec cannot be empty")
        }</span>
        <span class="cov0" title="0">if jc.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("timeout must be positive")
        }</span>
        <span class="cov0" title="0">if jc.RetryCount &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("retry count cannot be negative")
        }</span>
        <span class="cov0" title="0">if jc.MaxRetries &lt; jc.RetryCount </span><span class="cov0" title="0">{
                return fmt.Errorf("max retries cannot be less than retry count")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">// internal/task/cron.go
package task

import (
        "context"
        "fmt"
        "sync"

        "nancalacc/internal/biz"
        "nancalacc/internal/data"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/robfig/cron/v3"
)

// CronService 定时任务服务
type CronService struct {
        cron            *cron.Cron
        log             log.Logger
        fullSyncUsecase *biz.FullSyncUsecase
        data            *data.Data
        // 添加任务名称映射，防止重复注册
        registeredJobs map[string]cron.EntryID
        mu             sync.RWMutex
}

// Start 启动定时任务服务
func (s *CronService) Start() error <span class="cov0" title="0">{
        s.log.Log(log.LevelInfo, "msg", "starting cron service")
        s.cron.Start()
        return nil
}</span>

// Stop 停止定时任务服务
func (s *CronService) Stop() error <span class="cov0" title="0">{
        s.log.Log(log.LevelInfo, "msg", "stopping cron service")
        ctx := s.cron.Stop()
        &lt;-ctx.Done()
        return nil
}</span>

// AddFuncWithContext 添加带上下文的定时任务
func (s *CronService) AddFuncWithContext(name, spec string, cmd func(context.Context) error) (cron.EntryID, error) <span class="cov0" title="0">{
        // 检查任务是否已注册
        s.mu.RLock()
        if existingID, exists := s.registeredJobs[name]; exists </span><span class="cov0" title="0">{
                s.mu.RUnlock()
                s.log.Log(log.LevelWarn, "msg", "job already registered", "name", name, "existing_id", existingID)
                return existingID, nil
        }</span>
        <span class="cov0" title="0">s.mu.RUnlock()

        entryID, err := s.cron.AddFunc(spec, func() </span><span class="cov0" title="0">{
                ctx := context.Background()
                if err := cmd(ctx); err != nil </span><span class="cov0" title="0">{
                        s.log.Log(log.LevelError, "msg", "AddFuncWithContext.AddFunc", "name", name, "err", err)
                }</span> else<span class="cov0" title="0"> {
                        s.log.Log(log.LevelInfo, "msg", "AddFuncWithContext.AddFunc", "name", name)
                }</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to add job [%s]: %w", name, err)
        }</span>

        // 注册成功后，记录任务名称
        <span class="cov0" title="0">s.mu.Lock()
        s.registeredJobs[name] = entryID
        s.mu.Unlock()

        return entryID, nil</span>
}

// GetEntries 获取所有任务条目
func (s *CronService) GetEntries() []cron.Entry <span class="cov0" title="0">{
        return s.cron.Entries()
}</span>

// RemoveEntry 移除任务条目
func (s *CronService) RemoveEntry(id cron.EntryID) <span class="cov0" title="0">{
        s.cron.Remove(id)
}</span>

// NewCronService 创建定时任务服务
func NewCronService(fullSyncUsecase *biz.FullSyncUsecase, data *data.Data, log log.Logger) *CronService <span class="cov0" title="0">{
        return &amp;CronService{
                cron:            cron.New(cron.WithSeconds()),
                log:             log,
                fullSyncUsecase: fullSyncUsecase,
                data:            data,
                registeredJobs:  make(map[string]cron.EntryID),
        }
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">// internal/task/example_with_config.go
package task

import (
        "context"
        "fmt"
        v1 "nancalacc/api/account/v1"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/robfig/cron/v3"
)

// 注册所有定时任务
func RegisterJobsConfig(s *CronService) <span class="cov0" title="0">{
        // 示例1: 添加一个简单的配置化任务
        addSimpleConfigJob(s)

        // 示例2: 添加一个带重试和超时的任务
        //addRetryConfigJob(s)

        // 示例3: 添加一个带退避策略的任务
        //addBackoffConfigJob(s)

        // 示例4: 添加一个动态配置的任务
        //addDynamicConfigJob(s)

        // 添加 CreateSyncAccount 任务
        //addCreateSyncAccountJob(s)

        // 添加数据库检测任务
        //addDatabaseCheckJob(s)
}</span>

// addSimpleConfigJob 添加简单配置任务
func addSimpleConfigJob(s *CronService) <span class="cov0" title="0">{
        // 创建任务配置
        config := DefaultJobConfig("simple_task", "0 */15 * * * *") // 每15分钟执行
        config.WithTimeout(5 * time.Minute)
        config.Description = "简单的配置化任务示例"

        // 注册任务
        _, err := s.AddJobWithConfig(config, JobExecutorFunc(func(ctx context.Context) error </span><span class="cov0" title="0">{
                s.log.Log(log.LevelInfo, "msg", "executing simple config job",
                        "job_name", config.Name,
                        "timeout", config.Timeout)

                // 模拟任务执行
                time.Sleep(2 * time.Second)
                s.log.Log(log.LevelInfo, "msg", "simple config job completed")
                return nil
        }</span>))

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.log.Log(log.LevelError, "msg", "failed to register simple config job", "err", err)
        }</span>
}

// addRetryConfigJob 添加带重试配置的任务
// func addRetryConfigJob(s *CronService) {
//         // 创建任务配置
//         config := DefaultJobConfig("retry_task", "0 */30 * * * *") // 每30分钟执行
//         config.WithRetry(3, 2*time.Minute)                         // 重试3次，间隔2分钟
//         config.WithTimeout(10 * time.Minute)
//         config.Description = "带重试机制的任务示例"

//         // 注册任务
//         _, err := s.AddJobWithConfig(config, JobExecutorFunc(func(ctx context.Context) error {
//                 s.log.Log(log.LevelInfo, "msg", "executing retry config job",
//                         "job_name", config.Name,
//                         "retry_count", config.RetryCount,
//                         "retry_delay", config.RetryDelay)

//                 // 模拟可能失败的任务
//                 if time.Now().Second()%2 == 0 { // 偶数秒时模拟失败
//                         return fmt.Errorf("simulated failure for retry testing")
//                 }

//                 s.log.Log(log.LevelInfo, "msg", "retry config job completed successfully")
//                 return nil
//         }))

//         if err != nil {
//                 s.log.Log(log.LevelError, "msg", "failed to register retry config job", "err", err)
//         }
// }

// addBackoffConfigJob 添加带退避策略的任务
// func addBackoffConfigJob(s *CronService) {
//         // 创建任务配置
//         config := DefaultJobConfig("backoff_task", "0 0 */2 * * *") // 每2小时执行
//         config.Backoff = BackoffConfig{
//                 Type:      BackoffExponential,
//                 BaseDelay: 30 * time.Second,
//                 MaxDelay:  5 * time.Minute,
//                 Factor:    2.0,
//         }
//         config.WithRetry(5, 0) // 重试5次，使用退避策略
//         config.WithTimeout(15 * time.Minute)
//         config.Description = "带指数退避策略的任务示例"

//         // 注册任务
//         _, err := s.AddJobWithConfig(config, JobExecutorFunc(func(ctx context.Context) error {
//                 s.log.Log(log.LevelInfo, "msg", "executing backoff config job",
//                         "job_name", config.Name,
//                         "backoff_type", config.Backoff.Type,
//                         "base_delay", config.Backoff.BaseDelay)

//                 // 模拟网络请求任务
//                 if time.Now().Minute()%10 == 0 { // 每10分钟模拟一次失败
//                         return fmt.Errorf("network timeout, will retry with backoff")
//                 }

//                 s.log.Log(log.LevelInfo, "msg", "backoff config job completed successfully")
//                 return nil
//         }))

//         if err != nil {
//                 s.log.Log(log.LevelError, "msg", "failed to register backoff config job", "err", err)
//         }
// }

// addDynamicConfigJob 添加动态配置任务
// func addDynamicConfigJob(s *CronService) {
//         // 创建动态配置
//         config := DefaultJobConfig("dynamic_task", "0 */5 * * * *") // 每5分钟执行
//         config.Description = "动态配置任务示例"

//         // 注册任务
//         _, err := s.AddJobWithConfig(config, JobExecutorFunc(func(ctx context.Context) error {
//                 // 动态调整配置
//                 dynamicConfig := getDynamicConfig()

//                 s.log.Log(log.LevelInfo, "msg", "executing dynamic config job",
//                         "job_name", config.Name,
//                         "dynamic_timeout", dynamicConfig.Timeout,
//                         "dynamic_retry_count", dynamicConfig.RetryCount)

//                 // 使用动态配置执行任务
//                 return executeWithDynamicConfig(ctx, dynamicConfig)
//         }))

//         if err != nil {
//                 s.log.Log(log.LevelError, "msg", "failed to register dynamic config job", "err", err)
//         }
// }

// getDynamicConfig 获取动态配置
// func getDynamicConfig() *JobConfig {
//         // 根据当前时间或其他条件动态调整配置
//         now := time.Now()

//         config := DefaultJobConfig("dynamic", "")

//         // 根据时间调整超时时间
//         if now.Hour() &gt;= 22 || now.Hour() &lt;= 6 {
//                 // 夜间时段，增加超时时间
//                 config.Timeout = 20 * time.Minute
//                 config.RetryCount = 5
//         } else {
//                 // 白天时段，正常配置
//                 config.Timeout = 10 * time.Minute
//                 config.RetryCount = 3
//         }

//         // 根据系统负载调整配置
//         // if isHighLoad() {
//         //         config.RetryDelay = 10 * time.Minute
//         // } else {
//         //         config.RetryDelay = 2 * time.Minute
//         // }

//         return config
// }

// executeWithDynamicConfig 使用动态配置执行任务
// func executeWithDynamicConfig(ctx context.Context, config *JobConfig) error {
//         // 模拟任务执行
//         time.Sleep(3 * time.Second)

//         // 模拟偶尔的失败
//         if time.Now().Second()%7 == 0 {
//                 return fmt.Errorf("dynamic task failed, will retry with config: timeout=%v, retry_count=%d",
//                         config.Timeout, config.RetryCount)
//         }

//         return nil
// }

// isHighLoad 检查系统是否高负载
// func isHighLoad() bool {
//         // 这里可以实现实际的负载检测逻辑
//         // 例如：检查CPU使用率、内存使用率、队列长度等
//         return time.Now().Minute()%15 == 0 // 每15分钟模拟一次高负载
// }

// AddJobWithConfig 添加带配置的任务（需要在CronService中实现）
func (s *CronService) AddJobWithConfig(config *JobConfig, executor JobExecutor) (cron.EntryID, error) <span class="cov0" title="0">{
        // 检查任务是否已注册
        s.mu.RLock()
        if existingID, exists := s.registeredJobs[config.Name]; exists </span><span class="cov0" title="0">{
                s.mu.RUnlock()
                s.log.Log(log.LevelWarn, "msg", "job already registered", "name", config.Name, "existing_id", existingID)
                return existingID, nil
        }</span>
        <span class="cov0" title="0">s.mu.RUnlock()

        // 创建带配置的任务执行器
        configExecutor := &amp;ConfigJobExecutor{
                config:   config,
                executor: executor,
                log:      s.log,
        }

        entryID, err := s.cron.AddFunc(config.Spec, func() </span><span class="cov0" title="0">{
                ctx := context.Background()
                if err := configExecutor.Execute(ctx); err != nil </span><span class="cov0" title="0">{
                        s.log.Log(log.LevelError, "msg", "job execution failed",
                                "name", config.Name, "err", err)
                }</span> else<span class="cov0" title="0"> {
                        s.log.Log(log.LevelInfo, "msg", "job execution completed", "name", config.Name)
                }</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to add job [%s]: %w", config.Name, err)
        }</span>

        // 注册成功后，记录任务名称
        <span class="cov0" title="0">s.mu.Lock()
        s.registeredJobs[config.Name] = entryID
        s.mu.Unlock()

        s.log.Log(log.LevelInfo, "msg", "job registered with config",
                "name", config.Name,
                "spec", config.Spec,
                "timeout", config.Timeout,
                "retry_count", config.RetryCount)

        return entryID, nil</span>
}

// ConfigJobExecutor 带配置的任务执行器
type ConfigJobExecutor struct {
        config   *JobConfig
        executor JobExecutor
        log      log.Logger
}

// Execute 执行带配置的任务
func (cje *ConfigJobExecutor) Execute(ctx context.Context) error <span class="cov0" title="0">{
        startTime := time.Now()
        retryCount := 0

        for attempt := 0; attempt &lt;= cje.config.MaxRetries; attempt++ </span><span class="cov0" title="0">{
                // 创建带超时的上下文
                timeoutCtx, cancel := context.WithTimeout(ctx, cje.config.Timeout)

                // 执行任务
                err := cje.executor.Execute(timeoutCtx)
                cancel()

                // 记录执行结果
                result := &amp;JobResult{
                        JobName:    cje.config.Name,
                        StartTime:  startTime,
                        EndTime:    time.Now(),
                        Duration:   time.Since(startTime),
                        Success:    err == nil,
                        Error:      err,
                        RetryCount: retryCount,
                        IsTimeout:  timeoutCtx.Err() == context.DeadlineExceeded,
                        IsRetry:    attempt &gt; 0,
                }

                // 记录结果
                cje.logResult(result)

                // 如果成功，直接返回
                if err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // 如果是最后一次尝试，返回错误
                <span class="cov0" title="0">if attempt == cje.config.MaxRetries </span><span class="cov0" title="0">{
                        return fmt.Errorf("job [%s] failed after %d attempts: %w",
                                cje.config.Name, cje.config.MaxRetries, err)
                }</span>

                // 计算重试延迟
                <span class="cov0" title="0">delay := cje.calculateRetryDelay(attempt)

                cje.log.Log(log.LevelWarn, "msg", "job failed, will retry",
                        "name", cje.config.Name,
                        "attempt", attempt+1,
                        "max_retries", cje.config.MaxRetries,
                        "delay", delay,
                        "error", err)

                // 等待重试
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-time.After(delay):<span class="cov0" title="0">
                        retryCount++</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// calculateRetryDelay 计算重试延迟
func (cje *ConfigJobExecutor) calculateRetryDelay(attempt int) time.Duration <span class="cov0" title="0">{
        switch cje.config.Backoff.Type </span>{
        case BackoffFixed:<span class="cov0" title="0">
                return cje.config.RetryDelay</span>
        case BackoffExponential:<span class="cov0" title="0">
                delay := cje.config.Backoff.BaseDelay
                for i := 0; i &lt; attempt; i++ </span><span class="cov0" title="0">{
                        delay = time.Duration(float64(delay) * cje.config.Backoff.Factor)
                        if delay &gt; cje.config.Backoff.MaxDelay </span><span class="cov0" title="0">{
                                delay = cje.config.Backoff.MaxDelay
                                break</span>
                        }
                }
                <span class="cov0" title="0">return delay</span>
        case BackoffJitter:<span class="cov0" title="0">
                // 实现抖动退避策略 - 基于指数退避添加随机抖动
                baseDelay := cje.config.Backoff.BaseDelay
                for i := 0; i &lt; attempt; i++ </span><span class="cov0" title="0">{
                        baseDelay = time.Duration(float64(baseDelay) * cje.config.Backoff.Factor)
                        if baseDelay &gt; cje.config.Backoff.MaxDelay </span><span class="cov0" title="0">{
                                baseDelay = cje.config.Backoff.MaxDelay
                                break</span>
                        }
                }
                // 添加10%的随机抖动
                <span class="cov0" title="0">jitter := time.Duration(float64(baseDelay) * 0.1)
                return baseDelay + jitter</span>
        default:<span class="cov0" title="0">
                return cje.config.RetryDelay</span>
        }
}

// logResult 记录执行结果
func (cje *ConfigJobExecutor) logResult(result *JobResult) <span class="cov0" title="0">{
        if result.Success </span><span class="cov0" title="0">{
                cje.log.Log(log.LevelInfo, "msg", "job completed successfully",
                        "name", result.JobName,
                        "duration", result.Duration,
                        "retry_count", result.RetryCount)
        }</span> else<span class="cov0" title="0"> {
                cje.log.Log(log.LevelError, "msg", "job failed",
                        "name", result.JobName,
                        "duration", result.Duration,
                        "retry_count", result.RetryCount,
                        "is_timeout", result.IsTimeout,
                        "is_retry", result.IsRetry,
                        "error", result.Error)
        }</span>
}

// addCreateSyncAccountJob 添加 CreateSyncAccount 任务
func addCreateSyncAccountJob(s *CronService) <span class="cov0" title="0">{
        // 创建任务配置
        config := DefaultJobConfig("sync_account_job", "0 */3 * * * *") // 每3分钟执行
        config.WithTimeout(50 * time.Minute)
        config.WithRetry(2, 1*time.Minute) // 重试2次，间隔1分钟
        config.Description = "定时同步账户任务"

        // 注册任务
        _, err := s.AddJobWithConfig(config, JobExecutorFunc(func(ctx context.Context) error </span><span class="cov0" title="0">{
                s.log.Log(log.LevelInfo, "msg", "starting scheduled sync account job, every 3 minutes")

                // 创建同步请求
                req := &amp;v1.CreateSyncAccountRequest{
                        TriggerType: v1.TriggerType_TRIGGER_SCHEDULED,
                        SyncType:    v1.SyncType_FULL,
                        TaskName:    &amp;[]string{time.Now().Format("20060102150405")}[0],
                }

                // 调用 fullSyncUsecase.CreateSyncAccount
                reply, err := s.fullSyncUsecase.CreateSyncAccount(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Log(log.LevelError, "msg", "failed to create sync account", "err", err)
                        return err
                }</span>

                <span class="cov0" title="0">s.log.Log(log.LevelInfo, "msg", "sync account job completed", "task_id", reply.TaskId)
                return nil</span>
        }))

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.log.Log(log.LevelError, "msg", "failed to register sync_account_job", "err", err)
        }</span>
}

// addDatabaseCheckJob 添加数据库检测任务
func addDatabaseCheckJob(s *CronService) <span class="cov0" title="0">{
        // 创建任务配置
        config := DefaultJobConfig("resource_check", "0 */10 * * * *") // 每10分钟执行
        config.WithTimeout(5 * time.Minute)
        config.Description = "数据库和Redis连接检测任务"

        // 注册任务
        _, err := s.AddJobWithConfig(config, JobExecutorFunc(func(ctx context.Context) error </span><span class="cov0" title="0">{
                s.log.Log(log.LevelInfo, "msg", "starting resource check")

                // 检查数据库连接
                databases := s.data.GetDBManager().ListDatabases()
                for dbType, config := range databases </span><span class="cov0" title="0">{
                        if config.IsActive &amp;&amp; config.DB != nil </span><span class="cov0" title="0">{
                                if sqlDB, err := config.DB.DB(); err == nil </span><span class="cov0" title="0">{
                                        // 检查连接池状态
                                        stats := sqlDB.Stats()
                                        s.log.Log(log.LevelInfo, "msg", "database connection pool stats",
                                                "db_type", dbType,
                                                "max_open_connections", stats.MaxOpenConnections,
                                                "open_connections", stats.OpenConnections,
                                                "in_use", stats.InUse,
                                                "idle", stats.Idle)

                                        // 检查连接是否可用
                                        if err := sqlDB.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                                                s.log.Log(log.LevelError, "msg", "database ping failed", "db_type", dbType, "err", err)
                                        }</span> else<span class="cov0" title="0"> {
                                                s.log.Log(log.LevelInfo, "msg", "database ping successful", "db_type", dbType)
                                        }</span>
                                }
                        }
                }

                // 检查 Redis 连接
                <span class="cov0" title="0">if s.data.GetRedis() != nil </span><span class="cov0" title="0">{
                        redisClient := s.data.GetRedis()

                        // 检查 Redis 连接
                        if _, err := redisClient.Ping(ctx).Result(); err != nil </span><span class="cov0" title="0">{
                                s.log.Log(log.LevelError, "msg", "redis ping failed", "err", err)
                        }</span> else<span class="cov0" title="0"> {
                                s.log.Log(log.LevelInfo, "msg", "redis ping successful")

                                // 获取 Redis 信息
                                info, err := redisClient.Info(ctx).Result()
                                if err != nil </span><span class="cov0" title="0">{
                                        s.log.Log(log.LevelWarn, "msg", "failed to get redis info", "err", err)
                                }</span> else<span class="cov0" title="0"> {
                                        s.log.Log(log.LevelInfo, "msg", "redis info retrieved", "info_length", len(info))
                                }</span>
                        }
                }

                <span class="cov0" title="0">s.log.Log(log.LevelInfo, "msg", "resource check completed")
                return nil</span>
        }))

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.log.Log(log.LevelError, "msg", "failed to register resource_check job", "err", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package task

import (
        "nancalacc/internal/biz"
        "nancalacc/internal/data"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/google/wire"
)

// ProviderSet 是 task 模块的 provider 集合
var ProviderSet = wire.NewSet(NewCronServiceWithJobs)

// NewCronServiceWithJobs 创建带预定义任务的定时任务服务
func NewCronServiceWithJobs(fullSyncUsecase *biz.FullSyncUsecase, data *data.Data, logger log.Logger) *CronService <span class="cov0" title="0">{
        // 创建定时任务服务
        svc := NewCronService(fullSyncUsecase, data, logger)

        // 注册预定义任务
        //RegisterJobs(svc)

        RegisterJobsConfig(svc)

        return svc
}</span>

// startMetricsExport 启动指标导出（示例）
// func startMetricsExport(svc *CronService, mc *MetricsCollector, logger log.Logger) {
//         log := log.NewHelper(log.With(logger, "module", "metrics_export"))

//         ticker := time.NewTicker(5 * time.Minute) // 每5分钟导出一次指标
//         defer ticker.Stop()

//         // 创建一个可取消的上下文
//         ctx, cancel := context.WithCancel(context.Background())
//         defer cancel()

//         for {
//                 select {
//                 case &lt;-ticker.C:
//                         ctx := context.Background()
//                         metrics := mc.ExportMetrics(ctx)

//                         // 这里可以将指标发送到监控系统
//                         // 例如：Prometheus, InfluxDB, 或者日志系统
//                         log.Infof("exported metrics: %+v", metrics)

//                 case &lt;-ctx.Done():
//                         log.Info("metrics export stopped")
//                         return
//                 }
//         }
// }
</pre>
		
		<pre class="file" id="file65" style="display: none">package wps

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/go-kratos/kratos/v2/log"
)

// logAPIRequest 统一的API请求日志记录
func logAPIRequest(ctx context.Context, logger log.Logger, operation, method, path string, input interface{}) <span class="cov0" title="0">{
        logger.Log(log.LevelInfo, "msg", "API request started", "method", method, "path", path)

        if input != nil </span><span class="cov0" title="0">{
                logger.Log(log.LevelInfo, "msg", "Request input", "input", input)
        }</span>
}

// CodeChecker 定义检查业务码的接口
type CodeChecker[T comparable] interface {
        GetCode() T
}

// handleAPIResponse 统一的API响应处理函数，使用泛型支持int和string类型的Code字段
func handleAPIResponse[T comparable](ctx context.Context, logger log.Logger, operation string, responseBody []byte, response CodeChecker[T], expectedCode T) error <span class="cov0" title="0">{
        start := time.Now()

        // 记录响应
        logger.Log(log.LevelInfo, "msg", "API response received", "size", len(responseBody), "duration_ms", time.Since(start).Milliseconds())

        // 解析响应
        if err := json.Unmarshal(responseBody, response); err != nil </span><span class="cov0" title="0">{
                logger.Log(log.LevelError, "msg", "Failed to unmarshal response", "operation", operation, "err", err)
                return fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        // 检查业务错误码
        <span class="cov0" title="0">if code := response.GetCode(); code != expectedCode </span><span class="cov0" title="0">{
                logger.Log(log.LevelError, "msg", "Business error", "operation", operation, "code", code, "expected", expectedCode)
                return fmt.Errorf("business error: code=%v", code)
        }</span>

        <span class="cov0" title="0">logger.Log(log.LevelInfo, "msg", "API call completed", "operation", operation)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package wps

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "errors"
        "fmt"
        "net/http"
        "strings"
        "time"
)

type KsoSign struct {
        accessKey string
        secretKey string
}

type Out struct {
        Date          string // X-Kso-Date
        Authorization string // X-Kso-Authorization
}

const (
        ContentType   = "Content-Type"
        KsoAuthHeader = "X-Kso-Authorization"
        KsoDateHeader = "X-Kso-Date"
        Kso1Version   = "KSO-1"
)

func NewKsoSign(accessKey, secretKey string) (*KsoSign, error) <span class="cov0" title="0">{
        if accessKey == "" || secretKey == "" </span><span class="cov0" title="0">{
                return nil, errors.New("NewKsoSign error: AccessKey/SecretKey can not be empty")
        }</span>
        <span class="cov0" title="0">return &amp;KsoSign{
                accessKey: accessKey,
                secretKey: secretKey,
        }, nil</span>
}

// signUri := strings.TrimLeft(req.URL.Path, openApiPath)
func (k *KsoSign) getKso1Signature(secretKey, method, uri, ksoDate, contentType string, requestBody []byte) string <span class="cov0" title="0">{
        sha256Hex := ""
        if len(requestBody) &gt; 0 </span><span class="cov0" title="0">{
                s := sha256.New()
                s.Write(requestBody)
                sha256Hex = hex.EncodeToString(s.Sum(nil))
        }</span>

        <span class="cov0" title="0">mac := hmac.New(sha256.New, []byte(secretKey))

        signatureByte := []byte("KSO-1" + method + uri + contentType + ksoDate + sha256Hex)

        // fmt.Printf("signature origin: %s\n", string(signatureByte))
        // fmt.Printf("signature sha256Hex body: %s\n", sha256Hex)
        mac.Write(signatureByte)

        return hex.EncodeToString(mac.Sum(nil))</span>
}

func (k *KsoSign) KSO1Sign(method, signPath, contentType, ksoDate string, body []byte) (*Out, error) <span class="cov0" title="0">{

        //fmt.Printf("[KSO1Sign] method: %s, signPath: %s, contentType: %s, ksoDate: %s, body: %s\n", method, signPath, contentType, ksoDate, string(body))
        ksoSignature := k.getKso1Signature(k.secretKey, method, signPath, ksoDate, contentType, body)
        authorization := fmt.Sprintf("%s %s:%s", "KSO-1", k.accessKey, ksoSignature)
        //fmt.Printf("[KSO1Sign authorization]: %s\n", authorization)
        return &amp;Out{
                Date:          ksoDate,
                Authorization: authorization,
        }, nil
}</span>

func (k *KsoSign) validDate(ksoDate string) (tm time.Time, err error) <span class="cov0" title="0">{
        if tm, err = time.Parse(time.RFC1123, ksoDate); err == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if tm, err = time.Parse(time.RFC1123Z, ksoDate); err == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // 或者使用星期是全拼的非标准RFC1123
        <span class="cov0" title="0">RFC1123 := "Monday, 02 Jan 2006 15:04:05 MST"
        if tm, err = time.Parse(RFC1123, ksoDate); err == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">return tm, errors.New("kso1sign check error: invalid kso-date header")</span>
}

func (k *KsoSign) extractSign(authHeader string) (string, string, string, error) <span class="cov0" title="0">{
        spaceParts := strings.SplitN(authHeader, " ", 2)
        if len(spaceParts) != 2 </span><span class="cov0" title="0">{
                return "", "", "", errors.New("kso1sign check error: invalid authorization header")
        }</span>

        <span class="cov0" title="0">colonParts := strings.SplitN(spaceParts[1], ":", 2)
        if len(colonParts) != 2 </span><span class="cov0" title="0">{
                return "", "", "", errors.New("kso1sign check error: invalid authorization header")
        }</span>

        <span class="cov0" title="0">return spaceParts[0], colonParts[0], colonParts[1], nil</span>
}

func (k *KsoSign) validSign(req *http.Request, ksoSignature, secretKey, ksoDate, contentType string, requestBody []byte) error <span class="cov0" title="0">{
        sha256Hex := ""
        if len(requestBody) &gt; 0 </span><span class="cov0" title="0">{
                s := sha256.New()
                s.Write(requestBody)
                sha256Hex = hex.EncodeToString(s.Sum(nil))
        }</span>

        <span class="cov0" title="0">mac := hmac.New(sha256.New, []byte(secretKey))
        mac.Write([]byte("KSO-1" + req.Method + req.URL.RequestURI() + contentType + ksoDate + sha256Hex))
        sign := hex.EncodeToString(mac.Sum(nil))

        if sign == ksoSignature </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return errors.New("kso1sign check error: invalid signature")</span>
}

func (k *KsoSign) Kso1SignCheck(req *http.Request, requestBody []byte, SKGetter func(string) (string, error)) error <span class="cov0" title="0">{
        ksoAuthHeader := req.Header.Get(KsoAuthHeader)
        ksoDate := req.Header.Get(KsoDateHeader)
        contentType := req.Header.Get(ContentType)

        _, err := k.validDate(ksoDate)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">signVersion, accessKey, ksoSignature, err := k.extractSign(ksoAuthHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if signVersion != Kso1Version </span><span class="cov0" title="0">{
                return errors.New("kso1sign check error: unknown authorization version")
        }</span>

        // 获取 SK 及校验 AK 合法性
        <span class="cov0" title="0">secretKey, err := SKGetter(accessKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return k.validSign(req, ksoSignature, secretKey, ksoDate, contentType, requestBody)</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package wps

type EcisaccountsyncAllRequest struct {
        TaskId         string `json:"task_id"`
        ThirdCompanyId string `json:"third_company_id"`
        CollectCost    int    `json:"collect_cost"`
}

type EcisaccountsyncAllResponse struct {
        Code   string `json:"code"`
        Msg    string `json:"msg"`
        Data   any    `json:"data"`
        Detail string `json:"detail"`
}

// GetCode 实现 CodeChecker 接口
func (r *EcisaccountsyncAllResponse) GetCode() string <span class="cov0" title="0">{
        return r.Code
}</span>

type EcisaccountsyncIncrementRequest struct {
        ThirdCompanyId string `json:"third_company_id"`
}

type EcisaccountsyncIncrementResponse struct {
        Code   string `json:"code"`
        Msg    string `json:"msg"`
        Data   any    `json:"data"`
        Detail string `json:"detail"`
}

// GetCode 实现 CodeChecker 接口
func (r *EcisaccountsyncIncrementResponse) GetCode() string <span class="cov0" title="0">{
        return r.Code
}</span>

// dept...
type BatchPostDepartmentsRequest struct {
        DeptIDs []string `json:"dept_ids"`
}

type WpsDepartmentItem struct {
        ID       string                `json:"id"`
        Name     string                `json:"name"`
        ParentID string                `json:"parent_id"`
        Order    int                   `json:"order"`
        Leaders  []WpsDepartmentLeader `json:"leaders"`
        AbsPath  string                `json:"abs_path"`
        Ctime    int                   `json:"ctime"`
        ExDeptID string                `json:"ex_dept_id"`
}

type WpsDepartmentLeader struct {
        Order  int    `json:"order"`
        UserID string `json:"user_id"`
}

type BatchPostDepartmentsResponse struct {
        Code   int    `json:"code"`
        Msg    string `json:"msg"`
        Detail string `json:"detail"`
        Data   struct {
                Items []WpsDepartmentItem `json:"items"`
        } `json:"data"`
}

type PostBatchDeleteDeptRequest struct {
        DeptIDs []string `json:"dept_ids"`
}
type PostBatchDeleteDeptResponse struct {
        Code   int    `json:"code"`
        Msg    string `json:"msg"`
        Detail string `json:"detail"`
        Data   struct {
        } `json:"data"`
}

type PostBatchDeleteUserRequest struct {
        UserIDs []string `json:"user_ids"`
}
type PostBatchDeleteUserResponse struct {
        Code   int    `json:"code"`
        Msg    string `json:"msg"`
        Detail string `json:"detail"`
        Data   struct {
        } `json:"data"`
}
type PostRomoveUserIdFromDeptIdRequest struct {
        UserID string `json:"user_id"`
        DeptID string `json:"dept_id"`
}
type PostRomoveUserIdFromDeptIdResponse struct {
        Code   int    `json:"code"`
        Msg    string `json:"msg"`
        Detail string `json:"detail"`
        Data   struct {
        } `json:"data"`
}

type PostAddUserIdToDeptIdRequest struct {
        UserID string `json:"user_id"`
        DeptID string `json:"dept_id"`
}
type PostAddUserIdToDeptIdResponse struct {
        Code   int    `json:"code"`
        Msg    string `json:"msg"`
        Detail string `json:"detail"`
        Data   struct {
        } `json:"data"`
}

type PostBatchDepartmentsByExDepIdsRequest struct {
        ExDeptIDs []string `json:"ex_dept_ids"`
}
type PostBatchDepartmentsByExDepIdsResponse struct {
        Code   int    `json:"code"`
        Msg    string `json:"msg"`
        Detail string `json:"detail"`
        Data   struct {
                Items []WpsDepartmentItem `json:"items"`
        } `json:"data"`
}
type GetDepartmentRootRequest struct {
}

type GetDepartmentRootResponse struct {
        Code   int               `json:"code"`
        Msg    string            `json:"msg"`
        Detail string            `json:"detail"`
        Data   WpsDepartmentItem `json:"data"`
}

type GetDepartmentChildrenListRequest struct {
        Recursive bool   `json:"recursive"`
        PageSize  int    `json:"page_size"`
        PageToken string `json:"page_token"`
        WithTotal bool   `json:"with_total"`
}
type GetDepartmentChildrenListResponse struct {
        Code   int    `json:"code"`
        Msg    string `json:"msg"`
        Detail string `json:"detail"`
        Data   struct {
                Items []WpsDepartmentItem `json:"items"`
        } `json:"data"`
        NextPageToken string `json:"next_page_token"`
        Total         int    `json:"total"`
}

var (
        UserStatusActive   = "active"
        UserStatusNoActive = "notactive"
        UserStatusDisabled = "disabled"
)

// user...
type PostBatchUsersByExDepIdsRequest struct {
        ExUserIDs []string `json:"ex_user_ids"`
        Status    []string `json:"status"`
}
type PostBatchUsersByExDepIdsResponse struct {
        Code   int    `json:"code"`
        Msg    string `json:"msg"`
        Detail string `json:"detail"`
        Data   struct {
                Items []WpsUserItem `json:"items"`
        } `json:"data"`
}

type WpsUserItem struct {
        ID        string `json:"id"`
        UserName  string `json:"user_name"`
        LoginName string `json:"login_name"`
        Avatar    string `json:"avatar"`
        Email     string `json:"email"`
        ExUserId  string `json:"ex_user_id"`
        Phone     string `json:"phone"`
        Role      string `json:"role"`
        Status    string `json:"status"`
        Ctime     int    `json:"ctime"`
}

type BatchPostUsersRequest struct {
        UserIDs  []string `json:"user_ids"`
        Status   []string `json:"status"`
        WithDept bool     `json:"with_dept"`
}
type BatchPostUsersResponse struct {
        Code   int    `json:"code"`
        Msg    string `json:"msg"`
        Detail string `json:"detail"`
        Data   struct {
                Items []WpsUserWithDept `json:"items"`
        } `json:"data"`
}

// GetCode 实现 CodeChecker[int] 接口
func (r *BatchPostUsersResponse) GetCode() int <span class="cov0" title="0">{
        return r.Code
}</span>

type WpsUserWithDept struct {
        ID        string `json:"id"`
        ExUserID  string `json:"ex_user_id"`
        Gender    string `json:"gender"`
        Telephone string `json:"telephone"`
        Status    string `json:"status"`
        Depts     []struct {
                AbsPath string `json:"abs_path"`
                DeptID  string `json:"dept_id"`
                Name    string `json:"name"`
        } `json:"depts"`

        Ctime      int    `json:"ctime"`
        Role       string `json:"role"`
        LoginName  string `json:"login_name"`
        UserName   string `json:"user_name"`
        Avatar     string `json:"avatar"`
        Email      string `json:"email"`
        Phone      string `json:"phone"`
        Title      string `json:"title"`
        WorkPlace  string `json:"work_place"`
        EmployeeID string `json:"employee_id"`

        //Type string `json:"type"`
}

type GetUserByUserIdRequest struct {
        UserID string `json:"user_id"`
}

type GetUserByUserIdResponse struct {
        Code   int             `json:"code"`
        Msg    string          `json:"msg"`
        Detail string          `json:"detail"`
        Data   WpsUserWithDept `json:"data"`
}

type PostCreateUserRequest struct {
        Avatar           string   `json:"avatar"`
        DeptIDs          []string `json:"dept_ids"`
        Email            string   `json:"email"`
        EmployeeID       string   `json:"employee_id"`
        EmploymentStatus string   `json:"employment_status"`
        EmploymentType   string   `json:"employment_type"`
        ExUserID         string   `json:"ex_user_id"`
        Gender           string   `json:"gender"`
        LeaderID         string   `json:"leader_id"`
        LoginName        string   `json:"login_name"`
        Password         string   `json:"password"`
        Phone            string   `json:"phone"`
        Source           string   `json:"source"`
        Telephone        string   `json:"telephone"`
        Title            string   `json:"title"`
        Titles           struct {
                Mode      string `json:"mode"`
                TitleList []struct {
                        DeptID  string `json:"dept_id"`
                        TitleID string `json:"title_id"`
                } `json:"title_list"`
        } `json:"titles"`
        UserName  string `json:"user_name"`
        WorkPlace string `json:"work_place"`
}

type PostCreateUserResponse struct {
        Data struct {
                Avatar string `json:"avatar"`
                Ctime  int64  `json:"ctime"`
                Depts  []struct {
                        AbsPath string `json:"abs_path"`
                        DeptID  string `json:"dept_id"`
                        Name    string `json:"name"`
                } `json:"depts"`
                Email            string `json:"email"`
                EmployeeID       string `json:"employee_id"`
                EmploymentStatus string `json:"employment_status"`
                EmploymentType   string `json:"employment_type"`
                ExUserID         string `json:"ex_user_id"`
                Gender           string `json:"gender"`
                ID               string `json:"id"`
                LeaderID         string `json:"leader_id"`
                LoginName        string `json:"login_name"`
                Phone            string `json:"phone"`
                Role             string `json:"role"`
                Source           string `json:"source"`
                Status           string `json:"status"`
                Telephone        string `json:"telephone"`
                Title            string `json:"title"`
                Type             string `json:"type"`
                UserName         string `json:"user_name"`
                WorkPlace        string `json:"work_place"`
        } `json:"data"`
        Code int    `json:"code"`
        Msg  string `json:"msg"`
}

type PostCreateDeptRequest struct {
        ExDeptID string `json:"ex_dept_id"`
        Leaders  []struct {
                Order  int    `json:"order"`
                UserID string `json:"user_id"`
        } `json:"leaders"`
        Name     string `json:"name"`
        Order    int    `json:"order"`
        ParentID string `json:"parent_id"`
        Source   string `json:"source"` // Default: "inner"
}

type PostCreateDeptResponse struct {
        Data struct {
                AbsPath  string `json:"abs_path"`
                Ctime    int64  `json:"ctime"`
                ExDeptID string `json:"ex_dept_id"`
                ID       string `json:"id"`
                Leaders  []struct {
                        Order  int    `json:"order"`
                        UserID string `json:"user_id"`
                } `json:"leaders"`
                Name     string `json:"name"`
                Order    int    `json:"order"`
                ParentID string `json:"parent_id"`
                Source   string `json:"source"` // Default: "inner"
        } `json:"data"`
        Code int    `json:"code"`
        Msg  string `json:"msg"`
}

type PostUpdateDeptRequest struct {
        ExDeptID string   `json:"ex_dept_id"`
        Leaders  []Leader `json:"leaders"`
        Name     string   `json:"name"`
        Order    int      `json:"order"`
        ParentID string   `json:"parent_id"`
        Source   string   `json:"source"`
}

type Leader struct {
        Order  int    `json:"order"`
        UserID string `json:"user_id"`
}

type PostUpdateDeptResponse struct {
        Code int    `json:"code"`
        Msg  string `json:"msg"`
}

type PostUpdateUserRequest struct {
        Avatar           string    `json:"avatar"`
        Email            string    `json:"email"`
        EmployeeID       string    `json:"employee_id"`
        EmploymentStatus string    `json:"employment_status"`
        EmploymentType   string    `json:"employment_type"`
        ExUserID         string    `json:"ex_user_id"`
        Gender           string    `json:"gender"`
        LeaderID         string    `json:"leader_id"`
        LoginName        string    `json:"login_name"`
        Phone            string    `json:"phone"`
        Source           string    `json:"source"` // Default: "inner"
        Telephone        string    `json:"telephone"`
        Title            string    `json:"title"`
        Titles           TitleInfo `json:"titles"`
        UserName         string    `json:"user_name"`
        WorkPlace        string    `json:"work_place"`
}

type TitleInfo struct {
        Mode      string      `json:"mode"` // Default: "general"
        TitleList []UserTitle `json:"title_list"`
}

type UserTitle struct {
        DeptID  string `json:"dept_id"`
        TitleID string `json:"title_id"`
}

type PostUpdateUserResponse struct {
        Code int    `json:"code"`
        Msg  string `json:"msg"`
}

type PostBatchUserByPageRequest struct {
        PageSize  int      `json:"page_size"`
        PageNum   int      `json:"page_num"`
        PageToken string   `json:"page_token"`
        WithTotal bool     `json:"with_total"`
        WithDept  bool     `json:"with_dept"`
        Status    []string `json:"status"`
}

type PostBatchUserByPageResponse struct {
        Data struct {
                Items         []UserItem `json:"items"`
                NextPageToken string     `json:"next_page_token"`
                Total         int        `json:"total"`
        } `json:"data"`
        Code int    `json:"code"`
        Msg  string `json:"msg"`
}

type UserItem struct {
        Avatar           string `json:"avatar"`
        Ctime            int64  `json:"ctime"`
        Depts            []Dept `json:"depts"`
        Email            string `json:"email"`
        EmployeeID       string `json:"employee_id"`
        EmploymentStatus string `json:"employment_status"`
        EmploymentType   string `json:"employment_type"`
        ExUserID         string `json:"ex_user_id"`
        Gender           string `json:"gender"`
        ID               string `json:"id"`
        LeaderID         string `json:"leader_id"`
        LoginName        string `json:"login_name"`
        Phone            string `json:"phone"`
        Role             string `json:"role"`
        Source           string `json:"source"` // Default: "inner"
        Status           string `json:"status"`
        Telephone        string `json:"telephone"`
        Title            string `json:"title"`
        Type             string `json:"type"` // Default: "company_user"
        UserName         string `json:"user_name"`
        WorkPlace        string `json:"work_place"`
}

type Dept struct {
        AbsPath string `json:"abs_path"`
        DeptID  string `json:"dept_id"`
        Name    string `json:"name"`
}

type GetDeptByPageRequest struct {
        PageSize  int    `json:"page_size"`
        PageToken string `json:"page_token"`
        WithTotal bool   `json:"with_total"`
        Recursive bool   `json:"recursive"`
}

type GetDeptByPageResponse struct {
        Data struct {
                Items         []Department `json:"items"`
                NextPageToken string       `json:"next_page_token"`
                Total         int          `json:"total"`
        } `json:"data"`
        Code int    `json:"code"`
        Msg  string `json:"msg"`
}

type Department struct {
        AbsPath  string   `json:"abs_path"`
        Ctime    int64    `json:"ctime"`
        ExDeptID string   `json:"ex_dept_id"`
        ID       string   `json:"id"`
        Leaders  []Leader `json:"leaders"`
        Name     string   `json:"name"`
        Order    int      `json:"order"`
        ParentID string   `json:"parent_id"`
        Source   string   `json:"source"` // Default: "inner"
}

type GetUserDeptsByUserIdRequest struct {
        UserID string `json:"user_id"`
}
type GetUserDeptsByUserIdResponse struct {
        Code   int    `json:"code"`
        Detail string `json:"detail"`
        Msg    string `json:"msg"`
        Data   struct {
                Items []struct {
                        AbsPath  string `json:"abs_path"`
                        Ctime    int64  `json:"ctime"`
                        ExDeptID string `json:"ex_dept_id"`
                        ID       string `json:"id"`
                        Name     string `json:"name"`
                        Order    int64  `json:"order"`
                        ParentID string `json:"parent_id"`
                } `json:"items"`
        } `json:"data"`
}

type GetDeptChildrenRequest struct {
        DeptID    string `json:"dept_id"`
        Recursive bool   `json:"recursive"`
        PageSize  int    `json:"page_size"`
        PageToken string `json:"page_token"`
        WithTotal bool   `json:"with_total"`
}

//        type GetDeptChildrenResponse struct {
//                Code int    `json:"code"`
//                Msg  string `json:"msg"`
//                Data struct {
//                        Items []Department `json:"items"`
//                } `json:"data"`
//        }
type DeptItem struct {
        AbsPath  string `json:"abs_path"`
        Ctime    int64  `json:"ctime"`
        ExDeptID string `json:"ex_dept_id"`
        ID       string `json:"id"`
        Leaders  []struct {
                Order  int    `json:"order"`
                UserID string `json:"user_id"`
        } `json:"leaders"`
        Name     string `json:"name"`
        Order    int    `json:"order"`
        ParentID string `json:"parent_id"`
        Source   string `json:"source"` // 枚举值如 "inner" 可以用 string 类型
}
type GetDeptChildrenResponse struct {
        Data struct {
                Items         []DeptItem `json:"items"`
                NextPageToken string     `json:"next_page_token"`
                Total         int        `json:"total"`
        } `json:"data"`
        Code int    `json:"code"`
        Msg  string `json:"msg"`
}

type GetCompAllUsersRequest struct {
        PageSize  int      `json:"page_size"`
        PageToken string   `json:"page_token"`
        WithTotal bool     `json:"with_total"`
        WithDept  bool     `json:"with_dept"`
        Status    []string `json:"status"`
        Recursive bool     `json:"recursive"`
}

type GetCompAllUsersResponse struct {
        Data struct {
                Items         []UserItem `json:"items"`
                NextPageToken string     `json:"next_page_token"`
                Total         int        `json:"total"`
        } `json:"data"`
        Code int    `json:"code"`
        Msg  string `json:"msg"`
}

type GetUsersSearchRequest struct {
        Keyword                  string   `json:"keyword"`
        PageSize                 int64    `json:"page_size"`
        PageToken                string   `json:"page_token"`
        Status                   []string `json:"status"`
        SearchFieldConfigEnabled bool     `json:"search_field_config_enabled"`
        SearchSource             []string `json:"search_source"`
}

type UsersSearchUserItem struct {
        Avatar      string              `json:"avatar"`
        Ctime       int                 `json:"ctime"`
        Email       string              `json:"email"`
        ExUserID    string              `json:"ex_user_id"`
        HighLight   map[string][]string `json:"high_light"`
        ID          string              `json:"id"`
        LoginName   string              `json:"login_name"`
        Phone       string              `json:"phone"`
        Status      string              `json:"status"`
        Title       string              `json:"title"`
        UserName    string              `json:"user_name"`
        DefDeptID   string              `json:"def_dept_id"`
        DefDeptName string              `json:"def_dept_name"`
}
type GetUsersSearchResponse struct {
        Code   int    `json:"code"`
        Detail string `json:"detail"`
        Msg    string `json:"msg"`
        Data   struct {
                Items         []UsersSearchUserItem `json:"items"`
                NextPageToken string                `json:"next_page_token"`
        } `json:"data"`
}

type GetContactPermissionRequest struct {
        Scopes []string `json:"scopes"`
}
type GetContactPermissionResponse struct {
        Code   int    `json:"code"`
        Detail string `json:"detail"`
        Msg    string `json:"msg"`
        Data   struct {
                ContactPermission string `json:"contact_permission"`
        } `json:"data"`
}

type GetObjUploadUrlRequest struct {
}
type GetObjUploadUrlResponse struct {
        Code   int    `json:"code"`
        Detail string `json:"detail"`
        Msg    string `json:"msg"`
        Data   struct {
        } `json:"data"`
}

type CacheSetRequest struct {
        Key        string      `json:"key"`
        Value      interface{} `json:"value"`
        Expiration int         `json:"expiration"`
}

type CacheSetResponse struct{}
</pre>
		
		<pre class="file" id="file68" style="display: none">package wps

import (
        "context"
        "errors"
)

func ValidateWpsUser(ctx context.Context, user *UserItem) error <span class="cov0" title="0">{
        if user.ExUserID == "" </span><span class="cov0" title="0">{
                return errors.New("ex_user_id is empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package wps

import (
        "context"
        "encoding/json"
        "fmt"
        "nancalacc/internal/conf"
        "strings"
        "time"

        //httpwps "nancalacc/pkg/httputil/wps"

        "github.com/go-kratos/kratos/v2/log"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type wps struct {
        cfg *conf.Auth_Wpsapp
        log log.Logger
}

func NewWps(logger log.Logger) Wps <span class="cov0" title="0">{
        return &amp;wps{
                cfg: conf.Get().GetAuth().GetWpsapp(),
                log: logger,
        }
}</span>

// BATCH_POST_USERS_PATH        = "/v7/users/batch_read"
func (ws *wps) BatchPostUsers(ctx context.Context, accessToken string, input BatchPostUsersRequest) (BatchPostUsersResponse, error) <span class="cov0" title="0">{
        var resp BatchPostUsersResponse

        // 记录请求
        logAPIRequest(ctx, ws.log, "BatchPostUsers", "POST", BATCH_POST_USERS_PATH, input)

        // 创建请求
        wpsReq := NewWPSRequest(DOMAIN, ws.cfg.ClientId, ws.cfg.ClientSecret, WithLogger(ws.log))

        // 执行请求
        bs, err := wpsReq.PostJSON(ctx, BATCH_POST_USERS_PATH, accessToken, input)
        if err != nil </span><span class="cov0" title="0">{
                ws.log.Log(log.LevelError, "msg", "BatchPostUsers request failed", "err", err)
                return resp, err
        }</span>

        // 处理响应
        <span class="cov0" title="0">if err := handleAPIResponse(ctx, ws.log, "BatchPostUsers", bs, &amp;resp, 0); err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
func (ws *wps) BatchPostDepartments(ctx context.Context, accessToken string, input BatchPostDepartmentsRequest) (BatchPostDepartmentsResponse, error) <span class="cov0" title="0">{
        ws.log.Log(log.LevelInfo, "msg", "BatchPostDepartments", "req", input)

        var resp BatchPostDepartmentsResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        bs, err := wpsReq.PostJSON(context.Background(), BATCH_POST_DEPTS_PATH, accessToken, input)

        ws.log.Log(log.LevelInfo, "msg", "BatchPostDepartments", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

func (ws *wps) PostBatchDepartmentsByExDepIds(ctx context.Context, accessToken string, input PostBatchDepartmentsByExDepIdsRequest) (*PostBatchDepartmentsByExDepIdsResponse, error) <span class="cov0" title="0">{
        ws.log.Log(log.LevelInfo, "msg", "PostBatchDepartmentsByExDepIds", "req", input)
        var resp *PostBatchDepartmentsByExDepIdsResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        ws.log.Log(log.LevelInfo, "msg", "PostBatchDepartmentsByExDepIds", "uri", POST_DEPTS_BY_EXDEPTIDS_PATH, "input", input)
        bs, err := wpsReq.PostJSON(context.Background(), POST_DEPTS_BY_EXDEPTIDS_PATH, accessToken, input)

        ws.log.Log(log.LevelInfo, "msg", "PostBatchDepartmentsByExDepIds", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>

}

func (ws *wps) PostBatchDeleteDept(ctx context.Context, accessToken string, input PostBatchDeleteDeptRequest) (*PostBatchDeleteDeptResponse, error) <span class="cov0" title="0">{

        ws.log.Log(log.LevelInfo, "msg", "PostBatchDeleteDept", "req", input)
        var resp *PostBatchDeleteDeptResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        ws.log.Log(log.LevelInfo, "msg", "PostBatchDeleteDept", "uri", POST_DELETE_DEPTS_PATH, "input", input)
        bs, err := wpsReq.PostJSON(context.Background(), POST_DELETE_DEPTS_PATH, accessToken, input)

        ws.log.Log(log.LevelInfo, "msg", "PostBatchDeleteDept", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
func (ws *wps) PostBatchDeleteUser(ctx context.Context, accessToken string, input PostBatchDeleteUserRequest) (*PostBatchDeleteUserResponse, error) <span class="cov0" title="0">{
        ws.log.Log(log.LevelInfo, "msg", "PostBatchDeleteUser", "req", input)
        var resp *PostBatchDeleteUserResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        ws.log.Log(log.LevelInfo, "msg", "PostBatchDeleteUser", "uri", POST_DELETE_USERS_PATH, "input", input)
        bs, err := wpsReq.PostJSON(context.Background(), POST_DELETE_USERS_PATH, accessToken, input)

        ws.log.Log(log.LevelInfo, "msg", "PostBatchDeleteUser", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

func (ws *wps) PostRomoveUserIdFromDeptId(ctx context.Context, accessToken string, input PostRomoveUserIdFromDeptIdRequest) (*PostRomoveUserIdFromDeptIdResponse, error) <span class="cov0" title="0">{
        ws.log.Log(log.LevelInfo, "msg", "PostRomoveUserIdFromDeptId", "req", input)
        var resp *PostRomoveUserIdFromDeptIdResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        uri := strings.Replace(POST_DELETE_USERID_FROM_DEPTID_PATH, "{dept_id}", input.DeptID, 1)
        uri = strings.Replace(uri, "{user_id}", input.UserID, 1)

        ws.log.Log(log.LevelInfo, "msg", "PostRomoveUserIdFromDeptId", "uri", uri, "input", nil)
        bs, err := wpsReq.PostJSON(context.Background(), uri, accessToken, nil)

        ws.log.Log(log.LevelInfo, "msg", "PostRomoveUserIdFromDeptId", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
func (ws *wps) PostAddUserIdToDeptId(ctx context.Context, accessToken string, input PostAddUserIdToDeptIdRequest) (*PostAddUserIdToDeptIdResponse, error) <span class="cov0" title="0">{
        ws.log.Log(log.LevelInfo, "msg", "PostAddUserIdToDeptId", "req", input)
        var resp *PostAddUserIdToDeptIdResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        uri := strings.Replace(POST_ADD_USERID_TO_DEPTID_PATH, "{dept_id}", input.DeptID, 1)
        uri = strings.Replace(uri, "{user_id}", input.UserID, 1)

        ws.log.Log(log.LevelInfo, "msg", "PostAddUserIdToDeptId", "uri", uri, "input", nil)
        bs, err := wpsReq.PostJSON(context.Background(), uri, accessToken, nil)

        ws.log.Log(log.LevelInfo, "msg", "PostAddUserIdToDeptId", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
func (ws *wps) PostBatchUsersByExDepIds(ctx context.Context, accessToken string, input PostBatchUsersByExDepIdsRequest) (*PostBatchUsersByExDepIdsResponse, error) <span class="cov0" title="0">{

        ws.log.Log(log.LevelInfo, "msg", "PostBatchUsersByExDepIds", "req", input)

        var resp *PostBatchUsersByExDepIdsResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        ws.log.Log(log.LevelInfo, "msg", "PostBatchUsersByExDepIds", "uri", POST_USERS_BY_EXDEPTIDS_PATH, "input", input)
        bs, err := wpsReq.PostJSON(context.Background(), POST_USERS_BY_EXDEPTIDS_PATH, accessToken, input)

        ws.log.Log(log.LevelInfo, "msg", "PostBatchUsersByExDepIds", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>

}

func (ws *wps) GetDepartmentRoot(ctx context.Context, accessToken string, input GetDepartmentRootRequest) (GetDepartmentRootResponse, error) <span class="cov0" title="0">{

        ws.log.Log(log.LevelInfo, "msg", "GetDepartmentRoot", "req", input)

        var resp GetDepartmentRootResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        bs, err := wpsReq.GET(context.Background(), GET_DEPARTMENT_ROOT, accessToken, "")

        ws.log.Log(log.LevelInfo, "msg", "GetDepartmentRoot", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

func (ws *wps) GetUserByUserId(ctx context.Context, accessToken string, input GetUserByUserIdRequest) (GetUserByUserIdResponse, error) <span class="cov0" title="0">{
        ws.log.Log(log.LevelInfo, "msg", "GetUserByUserId", "req", input)

        var resp GetUserByUserIdResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        uri := strings.Replace(GET_USER_DEPT_BY_USERID, "{user_id}", input.UserID, 1)

        bs, err := wpsReq.GET(context.Background(), uri, accessToken, "")

        ws.log.Log(log.LevelInfo, "msg", "GetUserByUserId", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>

}

// TODO 内部网关的签名是不是不对
func (ws *wps) CacheSet(ctx context.Context, accessToken string, key string, value interface{}, expiration time.Duration) error <span class="cov0" title="0">{

        ws.log.Log(log.LevelInfo, "msg", "CacheSet", "req", key)
        return status.Error(codes.Unimplemented, "GetDeptByPage")

}</span>
func (ws *wps) CacheGet(ctx context.Context, accessToken string, key string) (interface{}, error) <span class="cov0" title="0">{

        ws.log.Log(log.LevelInfo, "msg", "CacheGet", "req", key)
        return nil, status.Error(codes.Unimplemented, "GetDeptByPage")

}</span>

func (ws *wps) CacheDel(ctx context.Context, accessToken, input string) error <span class="cov0" title="0">{
        ws.log.Log(log.LevelInfo, "msg", "CacheDel", "req", input)
        return status.Error(codes.Unimplemented, "GetDeptByPage")

}</span>

func (ws *wps) PostUpdateDept(ctx context.Context, accessToken string, input PostUpdateDeptRequest) (*PostUpdateDeptResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "PostUpdateDept")
}</span>
func (ws *wps) PostUpdateUser(ctx context.Context, accessToken string, input PostUpdateUserRequest) (*PostUpdateUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "PostUpdateUser")
}</span>

func (ws *wps) PostBatchUserByPage(ctx context.Context, accessToken string, input PostBatchUserByPageRequest) (*PostBatchUserByPageResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "PostBatchUserByPage")
}</span>

func (ws *wps) GetDeptByPage(ctx context.Context, accessToken string, input GetDeptByPageRequest) (*GetDeptByPageResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "GetDeptByPage")
}</span>

func (ws *wps) GetUserDeptsByUserId(ctx context.Context, accessToken string, input GetUserDeptsByUserIdRequest) (*GetUserDeptsByUserIdResponse, error) <span class="cov0" title="0">{
        ws.log.Log(log.LevelInfo, "msg", "GetUserDeptsByUserId", "req", input)

        var resp GetUserDeptsByUserIdResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        uri := strings.Replace(GET_USER_DEPT_BY_USERID, "{user_id}", input.UserID, 1)
        bs, err := wpsReq.GET(context.Background(), uri, accessToken, "")

        ws.log.Log(log.LevelInfo, "msg", "GetUserDeptsByUserId", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ws.log.Log(log.LevelInfo, "msg", "GetUserDeptsByUserId", "res", resp)
        if resp.Code != 0 </span><span class="cov0" title="0">{
                return nil, ErrCodeNot0
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

func (ws *wps) GetDeptChildren(ctx context.Context, accessToken string, input GetDeptChildrenRequest) (*GetDeptChildrenResponse, error) <span class="cov0" title="0">{

        ws.log.Log(log.LevelInfo, "msg", "GetDeptChildren", "req", input)

        var resp GetDeptChildrenResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        path := strings.Replace(GET_DEPT_CHILDREN, "{dept_id}", input.DeptID, 1)

        uri := fmt.Sprintf(
                "%s?recursive=%t&amp;page_size=%d&amp;with_total=%t",
                path,
                input.Recursive,
                input.PageSize,
                // input.PageToken,
                input.WithTotal,
        )

        if len(input.PageToken) &gt; 0 </span><span class="cov0" title="0">{
                uri += fmt.Sprintf("&amp;page_token=%s", input.PageToken)
        }</span>

        <span class="cov0" title="0">bs, err := wpsReq.GET(context.Background(), uri, accessToken, "")

        ws.log.Log(log.LevelInfo, "msg", "GetDeptChildren", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return nil, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return &amp;resp, nil</span>

}

func (ws *wps) GetCompAllUsers(ctx context.Context, accessToken string, input GetCompAllUsersRequest) (*GetCompAllUsersResponse, error) <span class="cov0" title="0">{

        ws.log.Log(log.LevelInfo, "msg", "GetCompAllUsers", "req", input)

        var resp GetCompAllUsersResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        uri := fmt.Sprintf(
                "%s?recursive=%t&amp;page_size=%d&amp;with_total=%t",
                GET_ALL_USER_PARH,
                input.Recursive,
                input.PageSize,
                input.WithTotal,
        )
        if len(input.Status) &gt; 0 </span><span class="cov0" title="0">{
                for _, status := range input.Status </span><span class="cov0" title="0">{
                        uri += fmt.Sprintf("&amp;status=%s", status)
                }</span>
        }
        <span class="cov0" title="0">if input.WithDept </span><span class="cov0" title="0">{
                uri += "&amp;with_dept=true"
        }</span>
        <span class="cov0" title="0">if len(input.PageToken) &gt; 0 </span><span class="cov0" title="0">{
                uri += fmt.Sprintf("&amp;page_token=%s", input.PageToken)
        }</span>
        <span class="cov0" title="0">ws.log.Log(log.LevelInfo, "msg", "GetCompAllUsers", "uri", uri)
        bs, err := wpsReq.GET(context.Background(), uri, accessToken, "")

        ws.log.Log(log.LevelInfo, "msg", "GetCompAllUsers", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return nil, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return &amp;resp, nil</span>
}

func (ws *wps) PostCreateDept(ctx context.Context, accessToken string, input PostCreateDeptRequest) (*PostCreateDeptResponse, error) <span class="cov0" title="0">{

        ws.log.Log(log.LevelInfo, "msg", "PostCreateDept", "req", input)

        var resp *PostCreateDeptResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        ws.log.Log(log.LevelInfo, "msg", "PostCreateDept", "uri", POST_CREATE_DEPT_PATH, "input", input)
        bs, err := wpsReq.PostJSON(context.Background(), POST_CREATE_DEPT_PATH, accessToken, input)

        ws.log.Log(log.LevelInfo, "msg", "PostCreateDept", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>

}

func (ws *wps) PostCreateUser(ctx context.Context, accessToken string, input PostCreateUserRequest) (*PostCreateUserResponse, error) <span class="cov0" title="0">{
        ws.log.Log(log.LevelInfo, "msg", "PostCreateUser", "req", input)

        var resp *PostCreateUserResponse

        // input := &amp;EcisaccountsyncIncrementRequest{
        //         ThirdCompanyId: thirdCompanyId,
        // }
        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        ws.log.Log(log.LevelInfo, "msg", "PostCreateUser", "uri", POST_CREATE_USER_PATH, "input", input)
        bs, err := wpsReq.PostJSON(context.Background(), POST_CREATE_USER_PATH, accessToken, input)

        ws.log.Log(log.LevelInfo, "msg", "PostCreateUser", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

func (ws *wps) GetUsersSearch(ctx context.Context, accessToken string, input GetUsersSearchRequest) (*GetUsersSearchResponse, error) <span class="cov0" title="0">{
        ws.log.Log(log.LevelInfo, "msg", "GetUsersSearch", "req", input)

        var resp *GetUsersSearchResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        ws.log.Log(log.LevelInfo, "msg", "GetUsersSearch", "uri", GET_USERS_SEARCH_PATH, "input", input)
        uri := fmt.Sprintf("%s?keyword=%s&amp;page_size=%d", GET_USERS_SEARCH_PATH, input.Keyword, input.PageSize)

        if input.PageToken != "" </span><span class="cov0" title="0">{
                uri += "&amp;page_token=true"
                uri += fmt.Sprintf("&amp;page_token=%s", input.PageToken)
        }</span>
        <span class="cov0" title="0">if len(input.Status) &gt; 0 </span><span class="cov0" title="0">{
                for _, status := range input.Status </span><span class="cov0" title="0">{
                        uri += fmt.Sprintf("&amp;status=%s", status)
                }</span>
        }
        <span class="cov0" title="0">if input.SearchFieldConfigEnabled </span><span class="cov0" title="0">{
                uri += "&amp;search_field_config_enabled=true"
        }</span>

        <span class="cov0" title="0">if len(input.SearchSource) &gt; 0 </span><span class="cov0" title="0">{
                for _, searchSource := range input.SearchSource </span><span class="cov0" title="0">{
                        uri += fmt.Sprintf("&amp;search_source=%s", searchSource)
                }</span>
        }
        <span class="cov0" title="0">bs, err := wpsReq.GET(context.Background(), uri, accessToken, "")

        ws.log.Log(log.LevelInfo, "msg", "GetUsersSearch", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

func (ws *wps) GetContactPermission(ctx context.Context, accessToken string, input GetContactPermissionRequest) (*GetContactPermissionResponse, error) <span class="cov0" title="0">{
        ws.log.Log(log.LevelInfo, "msg", "GetContactPermission", "req", input)

        var resp *GetContactPermissionResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        ws.log.Log(log.LevelInfo, "msg", "GetContactPermission", "uri", GET_CONTACT_PERMISSION_PATH, "input", input)
        var uri string
        for _, status := range input.Scopes </span><span class="cov0" title="0">{
                uri += fmt.Sprintf("&amp;scope=%s", status)
        }</span>
        <span class="cov0" title="0">bs, err := wpsReq.GET(context.Background(), GET_CONTACT_PERMISSION_PATH+"?"+uri, accessToken, "")

        ws.log.Log(log.LevelInfo, "msg", "GetContactPermission", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

// 内部网关
func (ws *wps) GetObjUploadUrl(ctx context.Context, accessToken string, input GetObjUploadUrlRequest) (*GetObjUploadUrlResponse, error) <span class="cov0" title="0">{
        ws.log.Log(log.LevelInfo, "msg", "GetObjUploadUrl", "req", input)

        var resp *GetObjUploadUrlResponse

        ak := ws.cfg.ClientId
        sk := ws.cfg.ClientSecret
        wpsReq := NewWPSRequest(DOMAIN, ak, sk, WithLogger(ws.log))

        // http: //encs-pri-cams-engine/{c}/asyncacc/v1/task

        uri := "http://119.3.173.229/api/cams/sdk/api/v1/wps3/presigned_upload"
        uri = "http://119.3.173.229/api/cams/sdk/api/v1/wps3/presigned_upload"

        ws.log.Log(log.LevelInfo, "msg", "GetObjUploadUrl", "uri", uri, "input", "")
        bs, err := wpsReq.GET(context.Background(), uri, accessToken, "")

        ws.log.Log(log.LevelInfo, "msg", "GetObjUploadUrl", "res", string(bs), "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(bs, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                return resp, ErrCodeNot0
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package wps

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "net/http"
        "net/url"

        "strings"
        "time"
)

type Wps4Auth struct {
        AccessKey string
        SecretKey string
}

var (
        Wps4AuthSign    = "Wps-Docs-Authorization"
        contentTypeSign = "application/json"
        wps4DateSign    = "Wps-Docs-Date"
        //connectionSign =

)

func NewWps4Auth(accessKey, secretKey string) *Wps4Auth <span class="cov0" title="0">{
        auth := &amp;Wps4Auth{}
        auth.AccessKey = accessKey
        auth.SecretKey = secretKey
        return auth
}</span>

func (a *Wps4Auth) BuildWps4Headers(method string, url *url.URL, data []byte, contentType string) *http.Header <span class="cov0" title="0">{
        if strings.TrimSpace(contentType) == "" </span><span class="cov0" title="0">{
                contentType = "application/json"
        }</span>

        <span class="cov0" title="0">header := http.Header{}
        auth, date := a.prepare(method, url, data, contentType)
        header.Set(Wps4AuthSign, auth)
        header.Set(contentTypeSign, contentType)
        header.Set(wps4DateSign, date)
        //header.Set(connectionSign, "keep-alive")
        return &amp;header</span>
}

func (a *Wps4Auth) prepare(method string, url *url.URL, data []byte, contentType string) (auth, date string) <span class="cov0" title="0">{
        path := url.Path
        if url.RawQuery != "" </span><span class="cov0" title="0">{
                path += fmt.Sprintf("?%s", url.RawQuery)
        }</span>

        <span class="cov0" title="0">var content []byte
        if data != nil </span><span class="cov0" title="0">{
                content = data
        }</span>

        <span class="cov0" title="0">date = time.Now().UTC().Format(http.TimeFormat)
        sig := a.sign(method, path, contentType, date, content)
        auth = fmt.Sprintf("WPS-4 %s:%s", a.AccessKey, sig)

        return</span>
}

func (a *Wps4Auth) sign(method, uri, contentType, date string, content []byte) (sign string) <span class="cov0" title="0">{
        bodySha := ""
        if content != nil </span><span class="cov0" title="0">{
                bodySha = a.getSha256(content)
        }</span>

        <span class="cov0" title="0">mac := hmac.New(sha256.New, []byte(a.SecretKey))
        mac.Write([]byte("WPS-4"))
        mac.Write([]byte(method))
        mac.Write([]byte(uri))
        mac.Write([]byte(contentType))
        mac.Write([]byte(date))
        mac.Write([]byte(bodySha))

        return hex.EncodeToString(mac.Sum(nil))</span>
}

func (a *Wps4Auth) getSha256(ontent []byte) string <span class="cov0" title="0">{
        h := sha256.New()
        h.Write(ontent)
        return hex.EncodeToString(h.Sum(nil))
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package wps

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"
        "time"

        "github.com/go-kratos/kratos/v2/log"
        "github.com/moul/http2curl"
)

const (
        defaultContentType  = "application/json"
        defaultTimeout      = 30 * time.Second
        AuthorizationHeader = "Authorization"
        RFC1123             = "Mon, 02 Jan 2006 15:04:05 GMT"
        // RFC1123             = "Monday, 02 Jan 2006 15:04:05 MST"
)

var (
        ErrInvalidRequest = errors.New("invalid request parameters")
        ErrHTTPRequest    = errors.New("HTTP request failed")
        openApiPathPrefix = "/openapi"
)

type WPSRequest struct {
        logger      log.Logger
        baseURL     string
        method      string
        path        string
        body        []byte
        contentType string
        ksoDate     string
        timeout     time.Duration
        headers     map[string]string
        queryParams map[string]string
        accessKey   string
        secretKey   string
        client      *http.Client
        accessToken string
}

type Option func(*WPSRequest)

func NewWPSRequest(baseURL, accessKey, secretKey string, opts ...Option) *WPSRequest <span class="cov0" title="0">{
        r := &amp;WPSRequest{
                baseURL:     strings.TrimRight(baseURL, "/"),
                accessKey:   accessKey,
                secretKey:   secretKey,
                timeout:     defaultTimeout,
                contentType: defaultContentType,
                headers:     make(map[string]string),
                queryParams: make(map[string]string),
                client:      &amp;http.Client{Timeout: defaultTimeout},
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(r)
        }</span>

        <span class="cov0" title="0">return r</span>
}

func WithLogger(logger log.Logger) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.logger = logger
        }</span>
}

// Option setters
func WithMethod(method string) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.method = strings.ToUpper(method)
        }</span>
}

func WithPath(path string) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                //r.path = strings.TrimLeft(path, "/")
                r.path = path
        }</span>
}

func WithBody(body []byte) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.body = body
        }</span>
}

func WithJSONBody(v interface{}) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                if b, err := json.Marshal(v); err == nil </span><span class="cov0" title="0">{
                        r.body = b
                        r.contentType = "application/json"
                }</span>
        }
}

func WithTimeout(timeout time.Duration) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.timeout = timeout
                r.client.Timeout = timeout
        }</span>
}

func WithHeader(key, value string) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.headers[key] = value
        }</span>
}

func WithQueryParam(key, value string) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.queryParams[key] = value
        }</span>
}

func WithContentType(contentType string) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.contentType = contentType
        }</span>
}

func WithKsoDate(date string) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.ksoDate = date
        }</span>
}

func WithAuthorization(accessToken string) Option <span class="cov0" title="0">{
        return func(r *WPSRequest) </span><span class="cov0" title="0">{
                r.accessToken = "Bearer " + accessToken
        }</span>
}

// Core methods
func (r *WPSRequest) BuildRequest() (*http.Request, error) <span class="cov0" title="0">{
        if r.method == "" || r.path == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: method and path are required", ErrInvalidRequest)
        }</span>

        // Build URL with query params
        <span class="cov0" title="0">u, err := url.Parse(fmt.Sprintf("%s%s", r.baseURL, r.path))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: invalid URL", ErrInvalidRequest)
        }</span>

        <span class="cov0" title="0">q := u.Query()
        for k, v := range r.queryParams </span><span class="cov0" title="0">{
                q.Add(k, v)
        }</span>
        <span class="cov0" title="0">u.RawQuery = q.Encode()

        // Create request
        req, err := http.NewRequest(r.method, u.String(), bytes.NewBuffer(r.body))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: failed to create request", ErrHTTPRequest)
        }</span>

        // Set headers
        <span class="cov0" title="0">if r.body != nil &amp;&amp; r.contentType != "" </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", r.contentType)
        }</span>
        <span class="cov0" title="0">if r.method == http.MethodGet &amp;&amp; r.contentType == "" </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", "")
        }</span>
        <span class="cov0" title="0">for k, v := range r.headers </span><span class="cov0" title="0">{
                req.Header.Set(k, v)
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

func (r *WPSRequest) Do(ctx context.Context) ([]byte, error) <span class="cov0" title="0">{
        req, err := r.BuildRequest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Add KSO signature
        <span class="cov0" title="0">signer, err := NewKsoSign(r.accessKey, r.secretKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create signer: %w", err)
        }</span>

        <span class="cov0" title="0">signPath := strings.TrimPrefix(req.URL.Path, openApiPathPrefix)
        if len(req.URL.RawQuery) &gt; 0 </span><span class="cov0" title="0">{
                signPath += "?" + req.URL.RawQuery
        }</span>

        <span class="cov0" title="0">sign, err := signer.KSO1Sign(r.method, signPath, r.contentType, r.ksoDate, r.body)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set(KsoDateHeader, sign.Date)
        req.Header.Set(KsoAuthHeader, sign.Authorization)
        req.Header.Set(AuthorizationHeader, r.accessToken)

        // command, err := http2curl.GetCurlCommand(req)
        _, err = http2curl.GetCurlCommand(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get curl err: %w", err)
        }</span>
        //r.logger.Log(log.LevelWarn, "request command", command)

        // Execute request
        <span class="cov0" title="0">resp, err := r.client.Do(req.WithContext(ctx))

        //r.logger.Log(log.LevelInfo, "response", resp, "err", err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %v", ErrHTTPRequest, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        //r.logger.Log(log.LevelInfo, "response body", string(body), "err", err)
        if resp.StatusCode &gt;= http.StatusBadRequest </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("resp.StatusCode %d egt %d", ErrHTTPRequest, resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return body, err</span>
}

// Convenience method
func (r *WPSRequest) PostJSON(ctx context.Context, path string, accessToken string, body interface{}) ([]byte, error) <span class="cov0" title="0">{
        req := NewWPSRequest(r.baseURL, r.accessKey, r.secretKey,
                WithMethod(http.MethodPost),
                WithPath(path),
                WithJSONBody(body),
                WithKsoDate(time.Now().UTC().Format(RFC1123)),
                WithAuthorization(accessToken),
                WithLogger(r.logger),
        )
        return req.Do(ctx)
}</span>

func (r *WPSRequest) GET(ctx context.Context, path string, accessToken string, query interface{}) ([]byte, error) <span class="cov0" title="0">{
        req := NewWPSRequest(r.baseURL, r.accessKey, r.secretKey,
                WithMethod(http.MethodGet),
                WithPath(path),
                WithContentType(""),
                WithKsoDate(time.Now().UTC().Format(RFC1123)),
                WithAuthorization(accessToken),
                WithLogger(r.logger),
        )
        return req.Do(ctx)
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package wps

import (
        "context"

        "github.com/go-kratos/kratos/v2/log"
)

var (
        Source = "sync"
)

func (ws *wps) PostEcisaccountsyncAll(ctx context.Context, accessToken string, input *EcisaccountsyncAllRequest) (EcisaccountsyncAllResponse, error) <span class="cov0" title="0">{
        var resp EcisaccountsyncAllResponse

        // 设置收集成本标志
        input.CollectCost = CollectCost

        // 记录请求
        logAPIRequest(ctx, ws.log, "PostEcisaccountsyncAll", "POST", ECISACCOUNTSYNC_PATH_INCREMENT, input)

        // 创建请求
        wpsReq := NewWPSRequest(DOMAIN, ws.cfg.ClientId, ws.cfg.ClientSecret, WithLogger(ws.log))

        // 执行请求
        bs, err := wpsReq.PostJSON(ctx, ECISACCOUNTSYNC_PATH_INCREMENT, accessToken, input)
        if err != nil </span><span class="cov0" title="0">{
                ws.log.Log(log.LevelError, "msg", "PostEcisaccountsyncAll request failed", "err", err)
                return resp, err
        }</span>

        // 使用泛型函数处理响应
        <span class="cov0" title="0">if err := handleAPIResponse(ctx, ws.log, "PostEcisaccountsyncAll", bs, &amp;resp, "200"); err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

func (ws *wps) PostEcisaccountsyncIncrement(ctx context.Context, accessToken string, input *EcisaccountsyncIncrementRequest) (EcisaccountsyncIncrementResponse, error) <span class="cov0" title="0">{
        var resp EcisaccountsyncIncrementResponse

        // 记录请求
        logAPIRequest(ctx, ws.log, "PostEcisaccountsyncIncrement", "POST", ECISACCOUNTSYNC_PATH_INCREMENT, input)

        // 创建请求
        wpsReq := NewWPSRequest(DOMAIN, ws.cfg.ClientId, ws.cfg.ClientSecret, WithLogger(ws.log))

        // 执行请求
        bs, err := wpsReq.PostJSON(ctx, ECISACCOUNTSYNC_PATH_INCREMENT, accessToken, input)
        if err != nil </span><span class="cov0" title="0">{
                ws.log.Log(log.LevelError, "msg", "PostEcisaccountsyncIncrement request failed", "err", err)
                return resp, err
        }</span>

        // 使用泛型函数处理响应
        <span class="cov0" title="0">if err := handleAPIResponse(ctx, ws.log, "PostEcisaccountsyncIncrement", bs, &amp;resp, "200"); err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package httputil

import (
        "bytes"
        "fmt"
        "io"
        "net/http"
        "time"
)

func PostJSON(uri string, jsonData []byte, timeout time.Duration) ([]byte, error) <span class="cov0" title="0">{
        httpClient := &amp;http.Client{Timeout: timeout}
        resp, err := httpClient.Post(uri, "application/json", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &gt;= http.StatusBadRequest </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP error: %s", resp.Status)
        }</span>

        <span class="cov0" title="0">bs, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return bs, nil</span>
}

func Post(uri string, data []byte, timeout time.Duration) ([]byte, error) <span class="cov0" title="0">{
        httpClient := &amp;http.Client{Timeout: timeout}
        resp, err := httpClient.Post(uri, "application/x-www-form-urlencoded", bytes.NewBuffer(data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &gt;= http.StatusBadRequest </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP error: %s", resp.Status)
        }</span>

        <span class="cov0" title="0">bs, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return bs, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
